/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <amxconst>
#include <xs>
#include <screenfade_util>
#include <cstrike>
#include <cs_player_models_api>
#include <hamsandwich>
#include <fakemeta>
#include <engine>
#include <fun>
#include <nvault>
#include <round_terminator>
#include <jailbreak_const>
#include <sqlx>

#pragma dynamic 65536
//#pragma semicolon 1

#define PLUGIN "Jailbreak_Main"
#define AUTHOR "Natsheh"

#define INVALID_CATEGORY -1
#define INVALID_KEY -1
#define INVALID_LINE -1

#define WEAPON_LINUXDIFF	4
#define PLAYER_LINUXDIFF	5
#define ENTITY_PDATA_SAFE 	2
#define OFFSET_TEAM	114
#define TASK_RADAR_SHOW_PLAYERS 3583463
#define TASK_END_ROUND 134256
#define TASK_PLAYER_GAG 84564
#define ADMIN_NOACCESS (1<<26)
#define SPECIALDAY_INMATES_REQUIREMENT 2
#define is_char(%1) (0 < (%1) <= 255)
#define CSW_SHIELD (1<<2)

#if !defined USE_TOGGLE
#define USE_TOGGLE 2
#endif

enum (+=1) {
	FILE_ERROR = 0,
	FILE_CATEGORY_CREATED,
	FILE_KEYVALUE_BUFFERED,
	FILE_KEYVALUE_UPDATED,
	FILE_KEYVALUE_CREATED,
	FILE_KEYVALUE_EMPTY
}

#define fm_get_user_team(%1)	(clamp(get_pdata_int(%1,OFFSET_TEAM),TEAM_UNASSIGNED,TEAM_SPECTATOR))
#define fm_set_user_team(%1,%2) \
if(pev_valid(%1) == ENTITY_PDATA_SAFE) \
{ \
	set_pdata_int(%1,OFFSET_TEAM,%2); \
}

#if AMXX_VERSION_NUM > 182
#define client_disconnect(id) client_disconnected(id)
#define strbreak argbreak
#endif

new const sDays[MAX_DAYS][] = {
	"DAY_SATURDAY",
	"DAY_SUNDAY",
	"DAY_MONDAY",
	"DAY_TUESDAY",
	"DAY_WEDNESDAY",
	"DAY_THURSDAY",
	"DAY_FRIDAY"
};

new const jb_cvar_cfg_file[] = "jailbreak.cfg";
new const jb_cvar_cfg_main_file[] = "jailbreak_main.cfg";
new const jb_cvar_mysql_cfg_file[] = "jailbreak_mysql.cfg";
new const jb_days_shop_items[] = "jailbreak_days_shopitems.ini";
new const jb_shop_ini_file[] = "jailbreak_shop.ini";
new const jb_classes_ini_file[] = "jailbreak_classes.ini";
new const jailbreak_ini_file[] = "jailbreak.ini";

new const iWeapons_bpammo[] = { 1, 52, 1, 90, 1, 32, 1, 100, 90, 1, 120, 100, 100, 90, 90, 90, 100, 120,
			30, 120, 200, 32, 90, 120, 90, 1, 35, 90, 90, 1, 100 };

new const gclasses_defmodels[][] = {
	"gign",
	"gsg9",
	"spetsnaz",
	"urban"
};

new const pclasses_defmodels[][] = {
	"leet",
	"terror",
	"guerilla",
	"arctic"
};

new const default_vknife_model[] = "models/v_knife.mdl";
new const default_pknife_model[] = "models/p_knife.mdl";

new g_fw_return;
new fw_jbmm_item_selected, fw_lr_item_selected, fw_lr_item_select, fw_lr_duel_start, fw_lr_duel_started,
fw_shop_item_select_pre, fw_shop_item_select_post, fw_shop_item_bought, fw_day_postselected, fw_day_preselected,
fw_day_end, fw_day_ended, fw_round_start, fw_round_started, fw_round_end, fw_round_ended, fw_day_start, fw_day_started,
fw_lr_duel_end, fw_lr_duel_ended, fw_jbmm_itemadded, fw_pretouch_wpnbox, fw_class_creation, fwd_teamhandling;
new Array:g_lr_itemname = Invalid_Array, Array:g_lr_itemaccess = Invalid_Array, Array:g_shop_items_name = Invalid_Array, 
 Array:g_shop_items_info = Invalid_Array, Array:g_shop_items_cost = Invalid_Array, Array:g_shop_items_access = Invalid_Array,
 Array:g_shop_items_team = Invalid_Array, Array:g_shop_items_bitsumdays = Invalid_Array, Array:g_jbmm_itemname = Invalid_Array,
 Array:g_jbmm_itemaccess = Invalid_Array, Array:g_jbmm_itemteam = Invalid_Array, Array:g_days_itemname = Invalid_Array,
 Array:g_days_itemaccess = Invalid_Array, Array:g_days_itemlength = Invalid_Array, Array:g_days_dayendtype = Invalid_Array,
 Array:g_classes_array = Invalid_Array, Array:g_array_logmessages = Invalid_Array, Trie:g_trie_shop_item_limit = Invalid_Trie, Trie:g_pTrie_SHOP = Invalid_Trie;
new g_jbmm_items, g_lr_items, g_shop_items, g_days_items, g_logmessages_hooks;

//configs variable
new CONFIGS_DIR[MAX_FILE_DIRECTORY_LEN];

// nvaults
new g_nvault_cash = INVALID_HANDLE, g_nvault_cells_button = INVALID_HANDLE, g_nvault_gag = INVALID_HANDLE;

new user_cash[MAX_PLAYERS+1], g_player_szName[MAX_PLAYERS][32];
new g_iLRPrisoner, g_iLRGuard;

new g_user_wpns_blocked[MAX_PLAYERS+1]; // Bitsum
new g_ex_iUser_enemies[MAX_PLAYERS+1];
new g_user_playersOnRadar[MAX_PLAYERS+1];

new g_votedays_voted;   // Bitsum
new g_votedays_vote[MAX_VOTEDAYS];
new g_votedays_chosen[MAX_VOTEDAYS];
new g_has_avotedaymenu ;  // Bitsum

new IsUserAlive, g_user_has_godmode;
new g_lr_inprogress = JB_LR_DEACTIVATED;
new g_day_inprogress = JB_DAY_CAGEDAY;

// Maxplayers
new g_iMaxplayers;

// Message's ID
new g_msgStatusIcon, g_msgTeamInfo, g_msgSayText, g_msgMoney, g_msgScoreInfo, g_msgHudTextArgs,
g_msgSendAudio, g_msgTextMsg;

// MOD (name + version)
new MOD[64];

enum (+=1)
{
	FLAG_ALL = -1,
	FLAG_ALIVE_ONLY,
	FLAG_DEAD_ONLY
}

// OFFSETS
stock const m_iPlayerTeam = 114;
stock const m_pPlayer = 41;

new BEACON_SOUND[MAX_FILE_DIRECTORY_LEN] = "buttons/blip1.wav";

new blue_duelSpr, red_duelSpr, beaconSpr;

new g_iClass[MAX_PLAYERS+1][TEAM_MAX];
new g_iNextClass[MAX_PLAYERS+1];
new Float:g_fPlayerDiscount[MAX_PLAYERS+1];
new g_iClasses;
new g_iUser_allies[MAX_PLAYERS+1] = { JB_ALLIES_DEFAULT, JB_ALLIES_DEFAULT, ... };
new g_iUser_enemies[MAX_PLAYERS+1] = { JB_ENEMIES_DEFAULT, JB_ENEMIES_DEFAULT, ... };
new bool:g_bUser_enemies_HasBoundVar[MAX_PLAYERS+1], bool:g_bUser_allies_HasBoundVar[MAX_PLAYERS+1];
new g_iUSER_KILLS[MAX_PLAYERS+1], g_iUserGagged[MAX_PLAYERS+1];
new g_pcvar_mp_friendlyfire, g_cvar_mp_friendlyfire;
new g_WinnerTeam;

new bool:bHAS_ROUND_ENDING = false, bool:bHAS_ROUND_ENDED = false, bool:bHAS_ROUND_STARTED = false;

new const SZTEAMS[][] = {
	"ANY",
	"PRISONER",
	"GUARD",
	"SPECTATOR"
};

// knife sounds
new const knife_sounds[][] = {
	"_deploy1.wav",
	"_hit1.wav",
	"_hit2.wav",
	"_hit3.wav",
	"_hit4.wav",
	"_hitwall1.wav",
	"_slash1.wav",
	"_slash2.wav",
	"_stab.wav"
};

new Array:g_iDayShopItems;

new const szXVAR_TYPES[][] = {
	"INT",
	"BITS",
	"CHAR",
	"FLOAT"
};

enum XVAR_TYPES (+=1)
{
	XVAR_TYPE_INTEGER = 0,
	XVAR_TYPE_BITS,
	XVAR_TYPE_CHARS,
	XVAR_TYPE_FLOAT
};

enum any:XVAR_DATA
{
	XVAR_ID,
	XVAR_TYPE,
	any:XVAR_VALUE
};

enum _:ITEM_LIMITATION_DATA (+=1)
{
	LIMIT_TIMES = 0,
	LIMIT_ROUNDS,
	LIMIT_ROUNDS_COUNTER[MAX_PLAYERS+1],
	LIMIT_FOR_EVERYONE,
	LIMIT_USER[MAX_PLAYERS+1]
};

enum _:DAY_SHOP_ITEMS (+=1)
{
	ITEM_SHOP_ITEM_NAME[MAX_SHOPITEM_NAME_LENGTH] = 0,
	ITEM_DAY_NAME[MAX_DAYITEM_NAME_LENGTH],
	ITEM_SHOP_ITEM_INFO[MAX_SHOPITEM_INFO_LENGTH],
	ITEM_NEWCOST[24],
	ITEM_TEAM,
	ITEM_ACCESS,
	ITEM_SHOP_LIMITS[ITEM_LIMITATION_DATA],
	Array:ITEM_ARRAY_XVARS
};

enum _:LOGS_MESSAGES_DATA (+=1)
{
	LOGMESSAGE_FUNC_ID = 0,
	LOGMESSAGE_FUNC_PLUGIN_ID,
	LOGMESSAGE_MESSAGE[MAX_LOG_MESSAGE_LENGTH]
};

enum _:CLASSES_KEYS (+=1)
{
	KEY_CLASS_TEAM = 0,
	KEY_CLASS_NAME,
	KEY_CLASS_MODEL,
	KEY_CLASS_MDL_SKIN,
	KEY_CLASS_MDL_BODY,
	KEY_CLASS_PRIMARY_WEAPON,
	KEY_CLASS_SECONDARY_WEAPON,
	KEY_CLASS_V_KNIFE,
	KEY_CLASS_P_KNIFE,
	KEY_CLASS_KNIFE_SOUNDS,
	KEY_CLASS_FLAGS,
	KEY_CLASS_AUTHID
};

new const szClasses_keys[][] = {
	"TEAM",
	"NAME",
	"MODEL",
	"MODEL_SKIN",
	"MODEL_BODY",
	"PRIMARY_WEAPON",
	"SECONDARY_WEAPON",
	"V_KNIFE",
	"P_KNIFE",
	"KNIFE_SOUNDS",
	"FLAGS",
	"STEAMID"
};

enum _:CLASSES_DATA (+=1)
{
	CLASS_TEAM[MAX_CLASS_TEAM_NAME_LENGTH] = 0,
	CLASS_NAME[MAX_CLASS_NAME_LENGTH],
	CLASS_MODEL[MAX_CLASS_PMODEL_LENGTH],
	CLASS_MODEL_SKIN,
	CLASS_MODEL_BODY,
	CLASS_PRIMWEAPONS[MAX_FILE_DIRECTORY_LEN],
	CLASS_SECWEAPONS[MAX_FILE_DIRECTORY_LEN],
	CLASS_V_KNIFE_MDL[MAX_FILE_DIRECTORY_LEN],
	CLASS_P_KNIFE_MDL[MAX_FILE_DIRECTORY_LEN],
	CLASS_KNIFE_SOUNDS[MAX_FILE_DIRECTORY_LEN],
	CLASS_FLAGS,
	CLASS_AUTHID[MAX_AUTHID_LENGTH]
};

new const sClasses[][CLASSES_DATA] = {
	{ "GUARD", "Hunter", "spetsnaz", 0, 0, "p90,mp5navy,ump45,tmp,mac10", "elite,usp,glock18", "", "", "", ADMIN_ALL, "" },

	{ "GUARD", "Assault", "gign", 0, 0, "m4a1,ak47,famas,galil", "deagle,usp,glock18", "", "", "", ADMIN_ALL, "" },
	
	{ "GUARD", "Heavy-Gunner", "gsg9", 0, 0, "m249", "deagle,usp,glock18", "", "", "", ADMIN_ALL, "" },
	
	{ "GUARD", "Sniper", "sas", 0, 0, "awp,scout", "deagle,usp,glock18", "", "", "", ADMIN_ALL, "" },
	
	{ "GUARD", "Shot-Gunner", "urban", 0, 0, "m3,xm1014", "deagle,usp,glock18", "", "", "", ADMIN_ALL, "" },
	
	{ "GUARD", "VIP", "vip", 0, 0, "m4a1,ak47,awp,p90,mp5navy,m3,xm1014", "deagle,usp,glock18", "", "", "", ADMIN_LEVEL_A, "" },
	
	{ "PRISONER", "L33t", "leet", 0, 0, "", "", "", "", "", ADMIN_ALL, "" },
	
	{ "PRISONER", "Terror", "terror", 0, 0, "", "", "", "", "", ADMIN_ALL, "" },
	
	{ "PRISONER", "Guerilla", "guerilla", 0, 0, "", "", "", "", "", ADMIN_ALL, "" },
	
	{ "PRISONER", "Arctic", "arctic", 0, 0, "", "", "", "", "",  ADMIN_ALL, "" }
};


enum CVARS_DATA_VARS
{
	STR_CVARSNAME[32],
	STR_CVARSVALUE[64],
	STR_CVARSDESCRIPTION[416]
};

enum _:(+=1)
{
	CVAR_GRATIO = 0,
	CVAR_PRATIO,
	CVAR_ADMIN_JOIN,
	CVAR_DUEL_LOST_CASH,
	CVAR_GGIVE_WPNS,
	CVAR_PGIVE_WPNS,
	CVAR_VDAY_TIMER,
	CVAR_VDAY_TIMER2,
	CVAR_LR_TIMER,
	CVAR_VDAY_ADMIN_EXVOTE,
	CVAR_VDAY_NOGUARDS,
	CVAR_FUNDAYS,
	CVAR_BUTTON_ACTIVATION,
	CVAR_BLOCK_BUTTONS_ONLR,
	CVAR_BLOCK_BUTTONS_ONFUNDAYS,
	CVAR_BLOCK_HEALING_ONLR,
	CVAR_BLOCK_HEALING_ONFUNDAYS,
	CVAR_FREEZE_PLAYERS_ONVOTEDAY,
	CVAR_SAVE_CASH_THROUGH,
	CVAR_SAVE_CASH_EVENT,
	CVAR_DONATE,
	
	CVARS_MAX
};

enum _:(+=1)
{
	CVAR_SAVE_TYPE = 0,
	CVAR_MYSQL_HOST,
	CVAR_MYSQL_USER,
	CVAR_MYSQL_PASS,
	CVAR_MYSQL_DATABASE,
	CVAR_MYSQL_TABLES_PREFIX,
	CVAR_MYSQL_CLASSES_TABLE,
	CVAR_MYSQL_CASH_TABLE,
	CVAR_MYSQL_TYPE
};

new const MYSQL_DATA[][CVARS_DATA_VARS] = {
	{ "jb_save_type", "0", "0 => load/save by using nVault | 1 => load/save by using mysql" },
	{ "jb_mysql_host", "127.0.0.1", "mysql server address" },
	{ "jb_mysql_user", "root", "mysql username" },
	{ "jb_mysql_pass", "", "mysql user password" },
	{ "jb_mysql_database", "root", "mysql database name" },
	{ "jb_sql_tables_prefix", "jb_", "mysql tables prefix" },
	{ "jb_sql_classes_table", "teams_classes", "mysql classes table name" },
	{ "jb_sql_cash_table", "users_cash", "mysql cash table name" },
	{ "jb_sql_type", "mysql", "sql type ( unused, left for future development )" }
};

new const CVARS_DATA[CVARS_MAX][CVARS_DATA_VARS] = {
	{ "jb_guards_ratio", "25", "Percentage value of how many players are allowed to join guards team" },
	{ "jb_prisoners_ratio", "100", "percentage value of how many players are allowed to join prisoners team"  },
	{ "jb_admin_join", "1", "0 => force ratio upon admins | 1 => allow admins to pass by the ratio value" },
	{ "jb_duel_loose_cash", "10000", "0 => to disable | greater than 0 => The amount of cash to loose if the a dueler killed a nondueler or vice versa!" },
	{ "jb_give_guard_weapons", "1", "0 => Disable the weapons for the guard classes | 1 => show guard class primary/secondary weapons menus for the player | 2 => give all the weapons class for the player" },
	{ "jb_give_prisoner_weapons", "2", "0 => Disable the weapons for the prisoner classes | 1 => show prisoner class primary/secondary weapons menus for the player | 2 => give all the weapons class for the player" },
	{ "jb_voteday_timer", "15", "special voteday timer length!" },
	{ "jb_voteday_daychosen_delay", "5", "chosen voteday delay timer!" },
	{ "jb_lastrequest_chosen_delay", "3", "last request duel countdown!" },
	{ "jb_voteday_admin_extravote", "1", "voteday admin's extra vote count!" },
	{ "jb_voteday_noguards", "1", "0 => Disabled | 1 => Specialday vote when there're no guards detected!" },
	{ "jb_fundays", "Friday,Thursday", "special votedays auto start on specific days, seperate each day with a comma!" },
	{ "jb_button_activation", "1", "button activation uppon attack ( 0 => Disabled | 1 => Enabled | 2 => Disable knife activation | 3 => Prisoners activates only \
	| 4 => Guards activates only | 5 => Prisoners activates only & Disable knife activation| 6 => Guards activates only & Disable knife activation )" },
	{ "jb_block_buttons_onlr", "0", "0 => Disabled | 1 => Block the usage of buttons on last request duels!" },	
	{ "jb_block_buttons_onfundays", "0", "0 => Disabled | 1 => Block the usage of buttons on fun/special days!" },
	{ "jb_block_healing_onlr", "1", "0 => Disabled | 1 => Block the usage of heal stations on last request duels!" },
	{ "jb_block_healing_onfundays", "1", "0 => Disabled | 1 => Block the usage of heal stations on fun/special days!" },
	{ "jb_freeze_players_onvoteday", "1", "0 => Disabled | 1 => Freeze players on special voteday until the vote ends!" },
	{ "jb_save_cash_through", "steamid", "'steamid' => save players cash by using their steamid as a key | 'name' => use their name | 'IP' => use their ipaddress" },
	{ "jb_save_cash_event", "a", "a => Save cash On disconnection | b => Save cash every new round | c => Save all the time" },
	{ "jb_cash_donation", "0", "0 => Disabled | 1 => Donation to other players is enabled / allowed!"}
};

enum JB_CELLS_STATE(+=1)
{
	JB_CELLS_ENTITY_INDEX = -1,
	JB_CELLS_CLOSE,
	JB_CELLS_OPEN
}

enum _:(+=1)
{
	ADMIN_MENU_MAIN_MENU = 0,
	ADMIN_MENU_REVIVE,
	ADMIN_MENU_SET_CHOOSE_OPTION,
	ADMIN_MENU_SET_CHOOSE_TARGET,
	ADMIN_MENU_SET_CHOOSE_VALUE
};

new const szAdminMenuItems[][] = {
	"ADMIN_MENU_CELLS_OPEN",
	"ADMIN_MENU_CELLS_CLOSE",
	"ADMIN_MENU_REVIVE",
	"ADMIN_MENU_SET"
};

new const szSetMenuItems[][][] = {
	{ "ADMIN_SET_M_HEALTH", "writevalue", "health" },
	{ "ADMIN_SET_M_ARMOR", "writevalue", "armor" },
	{ "ADMIN_SET_M_NOCLIP", "OnOff", "noclip" },
	{ "ADMIN_SET_M_GODMODE", "OnOff", "godmode" },
	{ "ADMIN_SET_M_GRAVITY", "writevalue", "gravity" },
	{ "ADMIN_SET_M_CELLS", "novalue", "cells" }
};

new const szAdminMenuTargetItems[][][] = {
	{ "ADMIN_M_ALL", 		"@a" 	},
	{ "ADMIN_M_ALL_ALIVE", "@aa" 	},
	{ "ADMIN_M_ALL_DEAD", 	"@ad" 	},
	{ "ADMIN_M_CT",			"@c" 	},
	{ "ADMIN_M_CT_ALIVE",	"@ca"	},
	{ "ADMIN_M_CT_DEAD",	"@cd"	},
	{ "ADMIN_M_T",			"@t"	},
	{ "ADMIN_M_T_ALIVE",	"@ta"	},
	{ "ADMIN_M_T_DEAD",		"@td"	}
};

enum (+=1)
{
	CONCMD_VOTEDAY = 0, CONCMD_SET, CONCMD_GIVE,
	CONCMD_INITIATESLR, CONCMD_CASH, CONCMD_REVIVE,
	CONCMD_TRANSFER, CONCMD_ENDDAY, CONCMD_ENDDUEL,
	CONCMD_CELLS, CONCMD_PURCHASE_DISCOUNT, CONCMD_TELEPORT,
	CONCMD_GAG
}

new const g_szJB_CONCOMMANDS[][] = {
	"jb_start_voteday", "jb_set", "jb_give",
	"jb_start_lr", "jb_cash", "jb_revive",
	"jb_transfer", "jb_end_day", "jb_end_lr",
	"jb_cells", "jb_discount", "jb_teleport",
	"jb_gag"
}

new const g_JB_CONCOMMANDS_ACCESS[] = {
	ADMIN_LEVEL_A, ADMIN_LEVEL_A, ADMIN_LEVEL_A,
	ADMIN_LEVEL_A, ADMIN_IMMUNITY, ADMIN_LEVEL_A,
	ADMIN_LEVEL_A, ADMIN_LEVEL_A, ADMIN_LEVEL_A,
	ADMIN_LEVEL_A, ADMIN_IMMUNITY, ADMIN_LEVEL_A,
	ADMIN_LEVEL_A
}

enum _:ADMIN_MENU_OPTIONS(+=1)
{
	ADMIN_MENU_OPTION_ACTION = 0,
	ADMIN_MENU_OPTION_TARGET,
	ADMIN_MENU_OPTION_VALUE
}

get_concmd_flags(id, &flags)
{
	get_concmd(id, .cmd="", .len1=0, .flags=flags, .info="", .len2=0, .flag=0);
}

new g_iAdminMenu_Option[MAX_PLAYERS+1][ADMIN_MENU_OPTIONS];

new g_iCvar_identity[CVARS_MAX], g_iMySqlCvar_identity[sizeof MYSQL_DATA], bool:MYSQL_ENABLED = false,
TABLE_CASH[16], TABLE_CLASSES[16], TABLES_PREFIX[8], g_iJB_CONCOMMAND_ID[sizeof g_szJB_CONCOMMANDS],
JB_CELLS_STATE:g_cells_iState = JB_CELLS_CLOSE;

//////////////////////////////////////////////////////
//////// PUBLIC VARIABLES ////////////////////////////
//////////////////////////////////////////////////////
public Float:FUNDAY_TIMER_LENGTH;					//
public LR_TIMER_LENGTH;								//
public VOTEDAY_TIMER_LENGTH = -1;						//
public Handle:JB_DB_TUPLE_HANDLER = Empty_Handle;	//
public CELLS_BUTTON = -1;							//
public g_iTODAY = TODAY_SATURDAY;					//
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

load_jailbreak_classes_file()
{
	new xArray[CLASSES_DATA], fp, sFile[64];
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, jb_classes_ini_file);
	
	if(!file_exists(sFile))
	{
		write_file(sFile, "; Classes Configuration");
		
		for(new i, szFlags[24]; i < sizeof sClasses; i++)
		{
			copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), sClasses[i][CLASS_NAME]);
			copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), sClasses[i][CLASS_TEAM]);
			copy(xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]), sClasses[i][CLASS_MODEL]);
			copy(xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]), sClasses[i][CLASS_PRIMWEAPONS]);
			copy(xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]), sClasses[i][CLASS_SECWEAPONS]);
			copy(xArray[CLASS_AUTHID], charsmax(xArray[CLASS_AUTHID]), sClasses[i][CLASS_AUTHID]);
			xArray[CLASS_FLAGS] = sClasses[i][CLASS_FLAGS];
			
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_MODEL], xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]));
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_PRIMARY_WEAPON], xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]));
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_SECONDARY_WEAPON], xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]));
			get_flags(xArray[CLASS_FLAGS], szFlags, charsmax(szFlags));
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_FLAGS], szFlags, charsmax(szFlags));
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_TEAM], xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]));
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_AUTHID], xArray[CLASS_AUTHID], charsmax(xArray[CLASS_AUTHID]));
		}
	}
	
	fp = fopen(sFile, "at+");
	
	if(!fp)
	{
		set_fail_state("Error opening the file!");
		return 0;
	}
	
	new sBuffer[256], szKey[48], registered,
		count = -1, j, i, maxloop, xArray2[CLASSES_DATA],
			sizeofkeys = sizeof szClasses_keys, szFile[64];
	
	while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
	{
		trim(sBuffer);
		
		if(!sBuffer[0] || strlen(sBuffer) <= 3 || sBuffer[0] == ';' || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			continue;
		
		if(sBuffer[0] == '[')
		{
			if((0 <= count < sizeofkeys) && g_iClasses > 0)
			{
				for(j = 0; j < sizeofkeys; j++)
				{
					if(!(registered & (1<<j)))
					{
						registered |= (1<<j);
						count++;
						
						switch( j )
						{
							case KEY_CLASS_TEAM: copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), "SPECTATORS");
							case KEY_CLASS_NAME: copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), "ENTER_CLASS_NAME");
							case KEY_CLASS_MODEL: copy(xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]), "NONE");
							case KEY_CLASS_MDL_BODY: xArray[CLASS_MODEL_BODY] = 0;
							case KEY_CLASS_MDL_SKIN: xArray[CLASS_MODEL_SKIN] = 0;
							case KEY_CLASS_V_KNIFE: copy(xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]), default_vknife_model);
							case KEY_CLASS_P_KNIFE: copy(xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]), default_pknife_model);
							case KEY_CLASS_PRIMARY_WEAPON: xArray[CLASS_PRIMWEAPONS][0] = 0;
							case KEY_CLASS_SECONDARY_WEAPON: xArray[CLASS_SECWEAPONS][0] = 0;
							case KEY_CLASS_KNIFE_SOUNDS: xArray[CLASS_KNIFE_SOUNDS][0] = 0;
							case KEY_CLASS_FLAGS: xArray[CLASS_FLAGS] = 0;
							case KEY_CLASS_AUTHID: xArray[CLASS_AUTHID][0] = 0;
						}
					}
				}
				
				ArraySetArray(g_classes_array, (g_iClasses-1), xArray);
			}
			
			count = 0;
			registered = (1<<KEY_CLASS_NAME);
			copyc(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), sBuffer[1], ']');
			
			for(i = 0, maxloop = g_iClasses; i < maxloop; i++)
			{
				ArrayGetArray(g_classes_array, i, xArray2);
				if(equal(xArray[CLASS_NAME], xArray2[CLASS_NAME]))
				{
					count = sizeofkeys;
					i = maxloop;
					break;
				}
			}
			
			if(count == sizeofkeys)
			{
				continue;
			}
			
			ArrayPushArray(g_classes_array, xArray);
			
			g_iClasses++;
			continue;
		}
		
		if(count >= sizeofkeys || !g_iClasses)
		{
			continue;
		}
		
		strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=');
		trim(szKey);
		trim(sBuffer);
		remove_quotes(szKey);
		remove_quotes(sBuffer);
		
		for(j = 0; j < sizeofkeys; j++)
		{
			if(equali(szClasses_keys[j], szKey) && !(registered & (1<<j)))
			{
				registered |= (1<<j);
				count++;
				
				ArrayGetArray(g_classes_array, (g_iClasses-1), xArray);
				
				switch( j )
				{
					case KEY_CLASS_AUTHID: copy(xArray[CLASS_AUTHID], charsmax(xArray[CLASS_AUTHID]), sBuffer);
					case KEY_CLASS_FLAGS: xArray[CLASS_FLAGS] = read_flags(sBuffer);
					case KEY_CLASS_NAME: copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), sBuffer);
					case KEY_CLASS_MODEL:
					{
						copy(xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]), sBuffer);
						formatex(szFile, charsmax(szFile), "models/player/%s/%s.mdl", sBuffer, sBuffer);
						PRECACHE_PLAYER_MODEL(szFile);
						formatex(szFile, charsmax(szFile), "models/player/%s/%sT.mdl", sBuffer, sBuffer);
						if(file_exists(szFile)) PRECACHE_PLAYER_MODEL(szFile);
					}
					case KEY_CLASS_MDL_BODY: xArray[CLASS_MODEL_BODY] = str_to_num(sBuffer);
					case KEY_CLASS_MDL_SKIN: xArray[CLASS_MODEL_SKIN] = str_to_num(sBuffer);
					case KEY_CLASS_PRIMARY_WEAPON: copy(xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]), sBuffer);
					case KEY_CLASS_SECONDARY_WEAPON: copy(xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]), sBuffer);
					case KEY_CLASS_TEAM: copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), sBuffer);
					case KEY_CLASS_V_KNIFE:
					{
						copy(xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]), sBuffer);
						PRECACHE_WEAPON_VIEW_MODEL(sBuffer);
					}
					case KEY_CLASS_P_KNIFE:
					{
						copy(xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]), sBuffer);
						PRECACHE_WEAPON_PLAYER_MODEL(sBuffer);
					}
					case KEY_CLASS_KNIFE_SOUNDS:
					{
						copy(xArray[CLASS_KNIFE_SOUNDS], charsmax(xArray[CLASS_KNIFE_SOUNDS]), sBuffer);
						
						for(i = 0; i < sizeof knife_sounds; i++)
						{
							formatex(szFile, charsmax(szFile), "%s%s", sBuffer, knife_sounds[i]);
							PRECACHE_SOUND(szFile);
						}
					}
				}
				
				ArraySetArray(g_classes_array, (g_iClasses-1), xArray);
				
				j = sizeofkeys;
			}
		}
	}
	fclose(fp);
	
	if(g_iClasses > 0) log_amx("[JAILBREAK] '%d' CLASS%s HAS BEEN SUCCESSFULLY LOADED !", g_iClasses, g_iClasses > 1 ? "ES":"");
	else log_amx("[JAILBREAK] NO CLASSES WERE FOUND PLEASE ADD FOR EACH TEAM AT-LEAST ONE CLASS !");
	log_amx("[JAILBREAK] FILE DIRECTORY : '%s'", sFile);
	
	return 1;
}

public plugin_end()
{
	// Classes menu - array
	ArrayDestroy(g_classes_array);
	
	// Jailbreak Main menu Arrays Count: 3
	ArrayDestroy(g_jbmm_itemname);
	ArrayDestroy(g_jbmm_itemaccess);
	ArrayDestroy(g_jbmm_itemteam);
	
	// Last request - arrays count: 2
	ArrayDestroy(g_lr_itemname);
	ArrayDestroy(g_lr_itemaccess);
	
	// Shop menu - arrays count: 6
	ArrayDestroy(g_shop_items_name);
	ArrayDestroy(g_shop_items_info);
	ArrayDestroy(g_shop_items_cost);
	ArrayDestroy(g_shop_items_access);
	ArrayDestroy(g_shop_items_team);
	ArrayDestroy(g_shop_items_bitsumdays);

	// Days menu - arrays count: 4
	ArrayDestroy(g_days_itemname);
	ArrayDestroy(g_days_itemaccess);
	ArrayDestroy(g_days_itemlength);
	ArrayDestroy(g_days_dayendtype);

	if(g_iDayShopItems != Invalid_Array)
	{
		for(new x, xArray[DAY_SHOP_ITEMS], loop = ArraySize(g_iDayShopItems); x < loop; x++)
		{
			ArrayGetArray(g_iDayShopItems, x, xArray);
			if(xArray[ITEM_ARRAY_XVARS] != any:Invalid_Array)
			{
				ArrayDestroy(xArray[ITEM_ARRAY_XVARS]);
			}
		}

		ArrayDestroy(g_iDayShopItems);
	}
	
	// close the nvaults..
	nvault_close(g_nvault_cash);
	nvault_close(g_nvault_cells_button);
	nvault_close(g_nvault_gag);
	
	// function arrays  count: 1
	ArrayDestroy(g_array_logmessages);
	
	// Shop menu - Tries  count: 2
	TrieDestroy(g_trie_shop_item_limit);
	TrieDestroy(g_pTrie_SHOP);
	
	// free the mysql tuple.
	if(JB_DB_TUPLE_HANDLER != Empty_Handle) SQL_FreeHandle(JB_DB_TUPLE_HANDLER);

	// destroying the mod forwards.
	DestroyForward( fw_jbmm_itemadded );
	DestroyForward( fw_jbmm_item_selected );
	DestroyForward( fw_lr_item_select );
	DestroyForward( fw_lr_item_selected );
	DestroyForward( fw_lr_duel_start );
	DestroyForward( fw_lr_duel_started );
	DestroyForward( fw_lr_duel_end );
	DestroyForward( fw_lr_duel_ended );
	DestroyForward( fw_shop_item_select_pre );
	DestroyForward( fw_shop_item_select_post );
	DestroyForward( fw_shop_item_bought );
	DestroyForward( fw_day_start );
	DestroyForward( fw_day_started );
	DestroyForward( fw_day_end );
	DestroyForward( fw_day_ended );
	DestroyForward( fw_day_preselected );
	DestroyForward( fw_day_postselected );
	DestroyForward( fw_round_start );
	DestroyForward( fw_round_started );
	DestroyForward( fw_round_end );
	DestroyForward( fw_round_ended );
	DestroyForward( fw_pretouch_wpnbox );
	DestroyForward( fwd_teamhandling );

	// reset the ff cvar value.
	if(g_cvar_mp_friendlyfire != get_pcvar_num(g_pcvar_mp_friendlyfire))
	{
		set_pcvar_num(g_pcvar_mp_friendlyfire, g_cvar_mp_friendlyfire);
	}
}

public plugin_precache()
{
	// getting the configs direct folder...
	get_configsdir(CONFIGS_DIR, charsmax(CONFIGS_DIR));
	
	// Forward for class creating !!!
	fw_class_creation = CreateMultiForward("jb_class_creation", ET_IGNORE);
	
	// Classes menu - array
	g_classes_array = ArrayCreate(CLASSES_DATA, 1);
	
	new BLUE_DUEL_SPRITE[MAX_FILE_DIRECTORY_LEN] = "sprites/duel_blue.spr";
	new RED_DUEL_SPRITE[MAX_FILE_DIRECTORY_LEN] = "sprites/duel_red.spr";
	new BEACON_SPRITE[MAX_FILE_DIRECTORY_LEN] = "sprites/laserbeam.spr";
	
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_GUARD_SPR", BLUE_DUEL_SPRITE, charsmax(BLUE_DUEL_SPRITE));
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_PRISONER_SPR", RED_DUEL_SPRITE, charsmax(RED_DUEL_SPRITE));
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_BEACON_SPR", BEACON_SPRITE, charsmax(BEACON_SPRITE));
	
	
	blue_duelSpr = PRECACHE_SPRITE_I(BLUE_DUEL_SPRITE);
	red_duelSpr = PRECACHE_SPRITE_I(RED_DUEL_SPRITE);
	beaconSpr = PRECACHE_SPRITE_I(BEACON_SPRITE);
	
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_BEACON_SOUND", BEACON_SOUND, charsmax(BEACON_SOUND));
	PRECACHE_SOUND(BEACON_SOUND);
	
	// Execute class creation fw...
	ExecuteForward(fw_class_creation, g_fw_return);
	
	// retrieving MySql Data from cvars...
	register_mysql_cvars();
	
	// Load Jailbreak MySql Cvars...
	new sFile[64];
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, jb_cvar_mysql_cfg_file);
	if(!file_exists(sFile))
	{
		write_file(sFile, "// JAILBREAK Mysql informations");
		
		static szBuffer[512];
		for(new i, maxloop = sizeof MYSQL_DATA; i < maxloop; i++)
		{
			formatex(szBuffer, charsmax(szBuffer), "// %s^n%s ^"%s^"^n", MYSQL_DATA[i][STR_CVARSDESCRIPTION], MYSQL_DATA[i][STR_CVARSNAME], MYSQL_DATA[i][STR_CVARSVALUE]);
			write_file(sFile, szBuffer);
		}
		
		log_amx("'%s' Jailbreak MYSQL Config file has been created!", sFile);
	}
	else
	{
		new fp = fopen(sFile, "rt");
		
		if(fp > 0)
		{
			new i, sBuffer[128], szCvar[32], mloop = sizeof MYSQL_DATA;
			
			while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
			{
				trim(sBuffer);
				
				if(!sBuffer[0] || (sBuffer[0] == '/' && sBuffer[1] == '/') || sBuffer[0] == ';' || strlen(sBuffer) < 5)
				{
					continue;
				}
				
				strbreak(sBuffer, szCvar, charsmax(szCvar), sBuffer, charsmax(sBuffer));
				remove_quotes(szCvar);
				remove_quotes(sBuffer);
				
				for(i = 0; i < mloop; i++)
				{
					if(equali(MYSQL_DATA[i][STR_CVARSNAME], szCvar))
					{
						set_pcvar_string(g_iMySqlCvar_identity[i], sBuffer);
						break;
					}
				}
			}
			fclose(fp);
			
			log_amx("'%s' Jailbreak MYSQL Config file has been loaded!", sFile);
		}
	}
	
	// is mysql enabled?
	if((MYSQL_ENABLED = (get_pcvar_num(g_iMySqlCvar_identity[CVAR_SAVE_TYPE]) > 0) ? true:false)==true) {
		// initial mysql process ( connecting, establishing tables, fetching classes from database );
		initial_tables();
	}
	
	if(!MYSQL_ENABLED)
	{
		// LOAD CLASSES from folder.
		load_jailbreak_classes_file();
	}
	
	// Disallowing buying...
	new info_map_para;
	if(!(info_map_para = find_ent_by_class(-1,"info_map_parameters")))
	{
		info_map_para = create_entity("info_map_parameters");
	}
	
	DispatchKeyValue(info_map_para, "buying", "3");
	DispatchSpawn(info_map_para);
}

logevent_message( const index=0, const szMessage[MAX_LOG_MESSAGE_LENGTH], any:... )
{
	static szBuffer[MAX_LOG_MESSAGE_LENGTH], iLen = 0;
	if(!iLen) iLen = formatex(szBuffer, charsmax(szBuffer), "JAILBREAK ");
	vformat(szBuffer[ iLen ], (charsmax(szBuffer) - iLen), szMessage, 3);

	if(!index)
	{
		server_print( szBuffer );
		log_message(szBuffer); // Is It a global even? if so log the event in the files...
	}

	fw_logmessages(szBuffer);
}

Show_weaponsmenu(id, wpns[], const title[], const handler[])
{
	if(!Check_weapons_available(id, true) || wpns[0] == EOS)
		return PLUGIN_CONTINUE;
	
	trim(wpns);
	remove_quotes(wpns);
	
	new sOutput[MAX_WEAPONS][24], sInfo[24], szTitle[128];
	str_explode(wpns, ',', sOutput, MAX_WEAPONS, charsmax(sOutput[]));
	
	formatex(szTitle, charsmax(szTitle), "%L", id, title);
	new iMenu = menu_create(szTitle, handler), iWeaponsCount;
	
	if(iMenu == INVALID_HANDLE)
	{
		return PLUGIN_CONTINUE;
	}

	for( new i = 0; i < MAX_WEAPONS; i++)
	{
		strtolower(sOutput[i]);
		formatex(sInfo, charsmax(sInfo), "weapon_%s", sOutput[i]);
		
		if(!get_weaponid(sInfo))
			continue;
		
		menu_additem(iMenu, sOutput[i], sInfo);
		iWeaponsCount++;
	}

	if(!iWeaponsCount)
	{
		menu_destroy(iMenu);
		return PLUGIN_HANDLED;
	}

	if(!menu_display(id, iMenu))
	{
		menu_destroy(iMenu);
	}

	return PLUGIN_HANDLED;
}

public primary_wpnshandle(const id, const menu, const item)
{
	if(item == MENU_EXIT || item == MENU_TIMEOUT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	if(item == MENU_MORE || item == MENU_BACK)
	{
		return PLUGIN_HANDLED;
	}

	if(!Check_weapons_available(id, false))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}

	new sName[32], sData[24];
	new iAccess, iCallback;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback);
	
	menu_destroy(menu);
	
	new wpnid = get_weaponid(sData);

	if(wpnid < 0 || !(wpnid  < sizeof iWeapons_bpammo))
	{
		return PLUGIN_HANDLED;
	}
	
	ham_give_weapon(id, sData);
	cs_set_user_bpammo(id, wpnid, iWeapons_bpammo[wpnid]);
	
	Show_Secondarywpns(id);
	return PLUGIN_HANDLED;
}

public Show_Secondarywpns(id)
{
	if(!Check_weapons_available(id, true))
		return;
	
	if(jb_is_user_class_valid(id, g_iClass[id][TEAM_GUARDS]) <= 0)
		return;

	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, g_iClass[id][TEAM_GUARDS], xArray);
	Show_weaponsmenu(id, xArray[CLASS_SECWEAPONS], "WEAPON_MENU_CHOOSE_SEC", "secondary_wpnshandle");
}

public secondary_wpnshandle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}

	if(!Check_weapons_available(id,false))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sName[32], sData[24];
	new iAccess, iCallback;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback);
	
	menu_destroy(menu);
	
	new wpnid = get_weaponid(sData);

	if(wpnid < 0 || !(wpnid  < sizeof iWeapons_bpammo))
	{
		return PLUGIN_HANDLED;
	}
	
	ham_give_weapon(id, sData);
	cs_set_user_bpammo(id, wpnid, iWeapons_bpammo[wpnid]);
	return PLUGIN_HANDLED;
}

bool:Check_weapons_available(id, bool:bMsg=false)
{
	if(!(1 <= id <= g_iMaxplayers))
	{
		return false;
	}
	if(g_lr_inprogress != JB_DUEL_NONE)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "LR_INPROGRESS");
		return false;
	}
	if(g_day_inprogress != JB_DAY_CAGEDAY)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "DAY_INPROGRESS");
		return false;
	}
	if(!check_flag(IsUserAlive,id))
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_NOT_ALIVE");
		return false;
	}
	
	return true;
}

give_weapons(id, wpns[], delimiter)
{
	if(!Check_weapons_available(id) || wpns[0] == EOS)
		return;
	
	new sOutput[MAX_WEAPONS][24];
	str_explode(wpns, delimiter, sOutput, MAX_WEAPONS, charsmax(sOutput[]));
	
	new wpnid, sWpnname[24];
	
	for(new i = 0; i < MAX_WEAPONS; i++)
	{
		formatex(sWpnname, charsmax(sWpnname), "weapon_%s", sOutput[i]);
		wpnid = get_weaponid(sWpnname);
		
		if(wpnid < 0 || !(wpnid  < sizeof iWeapons_bpammo))
		{
			continue;
		}
		
		ham_give_weapon(id, sWpnname);
		cs_set_user_bpammo(id, wpnid, iWeapons_bpammo[wpnid]);
	}
}

public pfn_keyvalue(Entity)  
{ 
	new ClassName[ 20 ], Dummy[ 2 ];
	copy_keyvalue( ClassName, charsmax( ClassName ), Dummy, charsmax( Dummy ), Dummy, charsmax( Dummy ) );
	
	if(equal(ClassName, "hostage_entity") ||
		equal(ClassName, "func_hostage_rescue") ||
		equal(ClassName, "func_bomb_target") ||
		equal(ClassName, "func_buyzone") ||
		equal(ClassName, "func_escapezone") ||
		equal(ClassName, "func_vip_safetyzone"))
	{
		remove_entity(Entity);
		return PLUGIN_HANDLED;
	}
	
	return PLUGIN_CONTINUE;
}

public plugin_natives()
{
	// Create a library !!!
	register_library("jailbreak_core");
	
	// JailBreak Main Menu - arrays count: 3
	g_jbmm_itemname = ArrayCreate(MAX_MMITEM_NAME_LENGTH, 1);
	g_jbmm_itemaccess = ArrayCreate(1, 1);
	g_jbmm_itemteam = ArrayCreate(1, 1);
	
	// Last request - arrays count: 2
	g_lr_itemname = ArrayCreate(MAX_LRITEM_NAME_LENGTH, 1);
	g_lr_itemaccess = ArrayCreate(1, 1);
	
	// Shop menu - arrays count: 6
	g_shop_items_name = ArrayCreate(MAX_SHOPITEM_NAME_LENGTH, 1);
	g_shop_items_info = ArrayCreate(MAX_SHOPITEM_INFO_LENGTH, 1);
	g_shop_items_cost = ArrayCreate(1, 1);
	g_shop_items_access = ArrayCreate(1, 1);
	g_shop_items_team = ArrayCreate(1, 1);
	g_shop_items_bitsumdays = ArrayCreate(1, 1);
	
	// Days menu - arrays count: 4
	g_days_itemname = ArrayCreate(MAX_DAYITEM_NAME_LENGTH, 1);
	g_days_itemaccess = ArrayCreate(1, 1);
	g_days_itemlength = ArrayCreate(1, 1);
	g_days_dayendtype = ArrayCreate(1, 1);
	
	// function arrays count: 1
	g_array_logmessages = ArrayCreate(LOGS_MESSAGES_DATA, 1);
	
	// day shop items arrays count: 1
	g_iDayShopItems = ArrayCreate(DAY_SHOP_ITEMS, 1);
	
	// limitation shop items tries count: 2
	g_trie_shop_item_limit = TrieCreate();
	g_pTrie_SHOP = TrieCreate();
	
	// registeration ...
	register_native("register_jailbreak_mmitem", "_register_jailbreak_mmitem");
	register_native("register_jailbreak_lritem", "_register_jailbreak_lritem");
	register_native("register_jailbreak_shopitem", "_register_jailbreak_shopitem");
	register_native("register_jailbreak_day", "_register_jailbreak_day");
	
	// lr natives
	register_native("jb_lr_show_targetsmenu", "_lr_show_targetsmenu");
	register_native("jb_get_current_duel", "_get_current_duel");
	register_native("jb_end_theduel", "_end_theduel");
	register_native("jb_get_duel_name", "_get_duel_name");
	register_native("jb_get_duels_registered", "_get_duels_registered");
	register_native("jb_get_duelid_byname", "_get_duelid_byname");
	
	// shop natives
	register_native("jb_set_user_cash", "_set_user_cash");
	register_native("jb_get_user_cash", "_get_user_cash");
	register_native("jb_update_shop_item", "_update_shop_item");
	register_native("jb_get_shop_items_registered", "_get_shop_items_registered");

	// Discounts
	register_native("jb_get_user_discount", "_get_user_discount");
	register_native("jb_set_user_discount", "_set_user_discount");
	
	// day natives
	register_native("jb_start_theday", "_start_theday");
	register_native("jb_end_theday", "_end_theday");
	register_native("jb_get_day_length", "_get_day_length");
	register_native("jb_set_day_length", "_set_day_length");
	register_native("jb_get_current_day", "_get_current_day");
	register_native("jb_get_day_name", "_get_day_name");
	register_native("jb_get_days_registered", "_get_days_registered");
	register_native("jb_get_dayid_byname", "_get_dayid_byname");
	
	// classes natives
	register_native("register_jailbreak_class", "_create_class");
	register_native("jb_get_user_classid", "_get_user_classid") ;// native jb_get_user_classid(id)
	register_native("jb_set_user_class", "_set_user_classid"); // native jb_set_user_classid(id, classid)
	register_native("jb_get_classname", "_get_classname"); // native jb_get_classname(classid, szReturn[], iLen)
	
	// native jb_get_classdata(classid, &team=-1, &flags=-1, &primarys=-1, &secondarys=-1, 
	// vknifemdl[]="", vKLen=0, pknifemdl="", pKLen=0, KSounds[]="", sKLen=0, model[]="", mlen=0)
	register_native("jb_get_classdata", "_get_classdata");
	
	register_native("jb_get_classes_count", "_get_classes_count"); // native jb_get_classes_count();
	register_native("jb_set_class_newname", "_set_class_newname"); // native jb_set_class_newname(classid, const new_name[])
	register_native("jb_is_user_class_valid", "_is_user_class_valid"); // native jb_is_class_valid(iClassid)
	register_native("jb_set_user_class_model", "_set_user_class_model");
	
	// block weapons
	register_native("jb_block_user_weapons", "_block_user_weapons");
	register_native("jb_is_user_weapons_blocked", "_is_user_weapons_blocked");
	
	// cells
	register_native("jb_cells", "_cells");
	
	//jailbreak ini file
	register_native("jb_ini_get_keyvalue", "jb_get_keyvalue");
	
	// logmessages hook/native
	register_native("register_jailbreak_logmessages", "register_logmessages");
	register_native("jb_logmessage", "_logmessage");
	register_native("jb_logmessage_action", "_logmessage_action");
	
	// today, days of the week
	register_native("jb_whats_today", "_whats_today");
	register_native("jb_get_weekdays_name", "_get_weekdays_name");
	
	// radar ff
	register_native("jb_display_on_player_radar", "_display_on_player_radar");
	
	// allies and enemies
	register_native("jb_set_user_allies", "native_jb_set_user_allies");
	register_native("jb_get_user_allies", "native_jb_get_user_allies");
	register_native("jb_set_user_enemies", "native_jb_set_user_enemies");
	register_native("jb_get_user_enemies", "native_jb_get_user_enemies");
	register_native("jb_bind_user_allies_var", "native_jb_bind_user_allies_var");
	register_native("jb_bind_user_enemies_var", "native_jb_bind_user_enemies_var");
}

load_jailbreak_configs_files()
{
	// Load Jailbreak Config Files
	new sFile[64];
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, jb_cvar_cfg_file);
	
	if(!file_exists(sFile))
	{
		new szBuffer[96], szCvarname[32], szValue[32], szPluginname[32], szAvoided_Plugin[32];
		get_plugin(-1, szAvoided_Plugin, charsmax(szAvoided_Plugin));
		write_file(sFile, "; Jailbreak Cvars^n^n");
		
		for(new i = 0, loop = get_plugins_cvarsnum(), iPointer, iPluginID; i < loop; i++)
		{
			get_plugins_cvar(i, szCvarname, charsmax(szCvarname), _, iPluginID, iPointer);
			get_pcvar_string(iPointer, szValue, charsmax(szValue));
			get_plugin(iPluginID, szPluginname, charsmax(szPluginname));
			
			if(equal(szAvoided_Plugin, szPluginname)) continue;
			
			if(!equali(szCvarname, "jb_", 3)) continue;
			formatex(szBuffer, charsmax(szBuffer), "^"%s^"    ^"%s^"    ; ( %s )", szCvarname, szValue, szPluginname);
			write_file(sFile, szBuffer);
		}
		
		log_amx("'%s' Jailbreak Cvars file has been created!", sFile);
	}
	else
	{
		server_cmd("exec %s", sFile);
		log_amx("'%s' Jailbreak Cvars file has been loaded!", sFile);
	}
	
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, jb_cvar_cfg_main_file);
	if(!file_exists(sFile))
	{
		new szBuffer[512];
		write_file(sFile, "; Jailbreak Main Cvars^n^n");
		
		for(new i = 0, loop = sizeof CVARS_DATA; i < loop; i++)
		{
			formatex(szBuffer, charsmax(szBuffer), "// %s^n%s ^"%s^"^n", CVARS_DATA[i][STR_CVARSDESCRIPTION], CVARS_DATA[i][STR_CVARSNAME], CVARS_DATA[i][STR_CVARSVALUE]);
			write_file(sFile, szBuffer);
		}
		
		log_amx("'%s' Jailbreak main Cvars file has been created!", sFile);
	}
	else
	{
		server_cmd("exec %s", sFile);
		log_amx("'%s' Jailbreak main Cvars file has been loaded!", sFile);
	}
}

public plugin_cfg()
{
	// open a vault
	g_nvault_cash = nvault_open("jailbreak_cash");
	if(g_nvault_cash == INVALID_HANDLE)
		set_fail_state("Failed to open jailbreak_cash nvault!");
	
	// open a vault
	g_nvault_cells_button = nvault_open("jailbreak_cells_button");
	if(g_nvault_cells_button == INVALID_HANDLE)	
		set_fail_state("Failed to open jailbreak_cells_button nvault!");
	
	// open a vault
	g_nvault_gag = nvault_open("jailbreak_gags");
	if(g_nvault_gag == INVALID_HANDLE)
		set_fail_state("Failed to open jailbreak_gags nvault!");

	new szMapname[32], szValue[64], timestp; get_mapname(szMapname, charsmax(szMapname));
	if(nvault_lookup(g_nvault_cells_button, szMapname, szValue, charsmax(szValue), timestp))
	{
		CELLS_BUTTON = str_to_num(szValue);
		UpdateCellsButton();
		server_print("* Cells button was located : %d", CELLS_BUTTON);
	}
	else
	{
		// added a delay because this is so heavy !!!
		set_task(5.0, "search_for_cellsbutton");
	}
	
	// load jailbreak configurations
	load_jailbreak_configs_files();
	
	// Shop items days configuration....
	for(new i, j, item_name[32], szDayname[MAX_DAYITEM_NAME_LENGTH]; i < g_shop_items; i++)
	{
		ArrayGetString(g_shop_items_name, i, item_name, charsmax(item_name));
		for(j = 0; j < g_days_items; j++)
		{
			ArrayGetString(g_days_itemname, j, szDayname, charsmax(szDayname));
			strtoupper(szDayname);
			copy(szValue, charsmax(szValue), "NO");
			get_file_keyvalue(jb_shop_ini_file, item_name, szDayname, szValue, charsmax(szValue));
			
			if(equali(szValue, "YES"))
			{
				ArraySetCell(g_shop_items_bitsumdays, i, ArrayGetCell(g_shop_items_bitsumdays,i)|(1<<j+1));
			}
		}
	}
	
	load_ini_days_shopitems(jb_days_shop_items);
}

public search_for_cellsbutton()
{
	// Cells button isn't found, lets try to find it automatically !
	if(!pev_valid(CELLS_BUTTON))
	{
		CELLS_BUTTON = -1;

		new szValue[64], szValue2[64], ent2, ent = find_ent_by_class(-1, "info_player_deathmatch"), Float:fOrigin[3];
		pev(ent, pev_origin, fOrigin);

		ent = 0;
		const Float:fRadius = 500.0;
	
		while(pev_valid((ent=find_ent_in_sphere(ent, fOrigin, fRadius))) != 0 && CELLS_BUTTON == -1)
		{
			pev(ent, pev_classname, szValue, charsmax(szValue));
			if( !equal(szValue, "func_door") &&
				!equal(szValue, "func_door_rotating") ) continue;
			
			// cells button requirements !!!
			pev(ent, pev_targetname, szValue, charsmax(szValue));

			// The func_door has no button just ignore!
			if(szValue[0] == EOS) continue;

			// searching for the button!!!
			ent2 = 0;
			while( (ent2 = find_ent_by_target(ent2, szValue)) > 0 )
			{
				// this isn't a button entity!
				pev(ent2, pev_classname, szValue2, charsmax(szValue2));

				if(equal(szValue2, "func_button") || equal(szValue2, "func_rot_button"))
				{
					// hopefully this is our cells button!
					save_map_cells_button(ent2);
					break;
				}
			}
		}

		if(CELLS_BUTTON == -1)
		{
			// Attempting to create a button and assign the cells to it.
			CELLS_BUTTON = CreateCellsButton();

			if(CELLS_BUTTON == -1)
			{
				server_print("^n[JAILBREAK CORE]^n");
				server_print("~ Failed to catch the cells button automatically please assign the cells button manually!^n");
				return 0;
			}
			else
			{
				server_print("* Cells button was created : %d", CELLS_BUTTON);
			}
		}
	}

	return 1;
}

CreateCellsButton()
{
	new ent = create_entity("func_button");

	if( !ent )
	{
		return -1;
	}

	set_pev(ent, pev_targetname, "cells_button");
	set_pev(ent, pev_solid, SOLID_BSP);
	set_pev(ent, pev_movetype, MOVETYPE_NONE);

	set_pev(ent, pev_spawnflags, SF_BUTTON_DONTMOVE|SF_BUTTON_TOGGLE);
	dllfunc(DLLFunc_Spawn, ent);

	if( find_ent_by_tname(-1, "cell") )
		set_pev(ent, pev_target, "cell");
	else if( find_ent_by_tname(-1, "cells") )
		set_pev(ent, pev_target, "cells");
	else
	{
		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);
		return -1;
	}

	engfunc(EngFunc_SetOrigin, ent, Float:{ 0.0, 0.0, 0.0 });

	return ent;
}

register_mysql_cvars()
{
	for(new i = 0, maxloop = sizeof MYSQL_DATA; i < maxloop; i++)
	{
		g_iMySqlCvar_identity[i] = register_cvar(MYSQL_DATA[i][STR_CVARSNAME], MYSQL_DATA[i][STR_CVARSVALUE]);
	}
}

initial_tables()
{
	// prepare tuple
	new szHost[32], szUser[32], szPass[32], szDatabase[32];
	get_pcvar_string(g_iMySqlCvar_identity[CVAR_MYSQL_HOST], szHost, charsmax(szHost));
	get_pcvar_string(g_iMySqlCvar_identity[CVAR_MYSQL_USER], szUser, charsmax(szUser));
	get_pcvar_string(g_iMySqlCvar_identity[CVAR_MYSQL_PASS], szPass, charsmax(szPass));
	get_pcvar_string(g_iMySqlCvar_identity[CVAR_MYSQL_DATABASE], szDatabase, charsmax(szDatabase));
	get_pcvar_string(g_iMySqlCvar_identity[CVAR_MYSQL_TABLES_PREFIX], TABLES_PREFIX, charsmax(TABLES_PREFIX));
	get_pcvar_string(g_iMySqlCvar_identity[CVAR_MYSQL_CLASSES_TABLE], TABLE_CLASSES, charsmax(TABLE_CLASSES));
	get_pcvar_string(g_iMySqlCvar_identity[CVAR_MYSQL_CASH_TABLE], TABLE_CASH, charsmax(TABLE_CASH));
	JB_DB_TUPLE_HANDLER = SQL_MakeDbTuple(szHost, szUser, szPass, szDatabase);
	
	if(JB_DB_TUPLE_HANDLER != Empty_Handle)
	{
		new iErrorCode, szError[512], Handle:iConnection;
		if((iConnection=SQL_Connect(JB_DB_TUPLE_HANDLER, iErrorCode, szError, charsmax(szError))) == Empty_Handle)
		{
			MYSQL_ENABLED = false;
			server_print("JAILBREAK CORE Connecting to DB Failed! [ %d / %s ]", iErrorCode, szError);
			log_error(AMX_ERR_GENERAL, "Error Code ( %d ) %s", iErrorCode, szError);
			return -1;
		}
		
		// create cash table
		SQL_QueryAndIgnore(iConnection, "CREATE TABLE IF NOT EXISTS `%s`.`%s%s` (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, authid VARCHAR(32) NOT NULL UNIQUE, nickname VARCHAR(32) NOT NULL, usercash INT(11) NOT NULL DEFAULT '0');", szDatabase, TABLES_PREFIX, TABLE_CASH);
		
		// create classes table
		SQL_QueryAndIgnore(iConnection, "CREATE TABLE IF NOT EXISTS `%s`.`%s%s`\
		(`%s` VARCHAR(%d) NOT NULL DEFAULT 'ANY',\
		`%s` VARCHAR(%d) NOT NULL UNIQUE,\
		`%s` VARCHAR(%d) NOT NULL,\
		`%s` INT DEFAULT '0',\
		`%s` INT DEFAULT '0',\
		`%s` VARCHAR(%d),\
		`%s` VARCHAR(%d),\
		`%s` VARCHAR(%d) NOT NULL DEFAULT '%s',\
		`%s` VARCHAR(%d) NOT NULL DEFAULT '%s',\
		`%s` VARCHAR(%d),\
		`%s` VARCHAR(%d),\
		`%s` INT DEFAULT '0');", szDatabase, TABLES_PREFIX, TABLE_CLASSES,
		szClasses_keys[KEY_CLASS_TEAM], MAX_CLASS_TEAM_NAME_LENGTH,
		szClasses_keys[KEY_CLASS_NAME], MAX_CLASS_NAME_LENGTH,
		szClasses_keys[KEY_CLASS_MODEL], MAX_CLASS_PMODEL_LENGTH,
		szClasses_keys[KEY_CLASS_MDL_BODY],
		szClasses_keys[KEY_CLASS_MDL_SKIN],
		szClasses_keys[KEY_CLASS_PRIMARY_WEAPON], MAX_CLASS_PRIM_WEAPONS_LEN,
		szClasses_keys[KEY_CLASS_SECONDARY_WEAPON], MAX_CLASS_SEC_WEAPONS_LEN,
		szClasses_keys[KEY_CLASS_V_KNIFE], MAX_FILE_DIRECTORY_LEN, default_vknife_model,
		szClasses_keys[KEY_CLASS_P_KNIFE], MAX_FILE_DIRECTORY_LEN, default_pknife_model,
		szClasses_keys[KEY_CLASS_KNIFE_SOUNDS], MAX_FILE_DIRECTORY_LEN,
		szClasses_keys[KEY_CLASS_AUTHID], MAX_AUTHID_LENGTH,
		szClasses_keys[KEY_CLASS_FLAGS]);
		
		// loading classes...
		new Handle:iQuery = SQL_PrepareQuery(iConnection,"SELECT * FROM `%s`.`%s%s`;", szDatabase, TABLES_PREFIX, TABLE_CLASSES);
		
		if(iQuery == Empty_Handle)
		{
			log_error(AMX_ERR_GENERAL, "Error: Failed to prepare query!");
			load_jailbreak_classes_file();
		}
		else if(!SQL_Execute(iQuery))
		{
			iErrorCode = SQL_QueryError(iQuery, szError, charsmax(szError));
			log_error(AMX_ERR_GENERAL, "Error Code ( %d ) %s", iErrorCode, szError);
			load_jailbreak_classes_file();
		}
		else if(SQL_AffectedRows(iQuery) < 1)
		{
			// free iQuery.
			SQL_FreeHandle(iQuery);
			
			log_error(AMX_ERR_NOTFOUND, "There are no classes were found inside the database^nPlease add classes inside this table ^"%s%s^" !", TABLES_PREFIX, TABLE_CLASSES);
			load_jailbreak_classes_file();
		}
		else
		{
			new iColTeam, iColName, iColModel, iColModelBody, iColModelSkin, iColPrimaryWpn, iColSecondaryWpn, iColVKnife, iColPKnife, iColKnifeSND, iColFlags, iColAuthid, xArray[CLASSES_DATA], szFile[MAX_FILE_DIRECTORY_LEN];
			iColTeam = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_TEAM]);
			iColName = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_NAME]);
			iColModel = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_MODEL]);
			iColModelBody = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_MODEL]);
			iColModelSkin = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_MODEL]);
			iColPrimaryWpn = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_PRIMARY_WEAPON]);
			iColSecondaryWpn = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_SECONDARY_WEAPON]);
			iColVKnife = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_V_KNIFE]);
			iColPKnife = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_P_KNIFE]);
			iColKnifeSND = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_KNIFE_SOUNDS]);
			iColFlags = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_FLAGS]);
			iColAuthid = SQL_FieldNameToNum(iQuery, szClasses_keys[KEY_CLASS_AUTHID]);
			
			while (SQL_MoreResults(iQuery))
			{
				SQL_ReadResult(iQuery, iColTeam, xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]));
				SQL_ReadResult(iQuery, iColName, xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]));
				SQL_ReadResult(iQuery, iColModel, xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]));
				xArray[CLASS_MODEL_BODY] = SQL_ReadResult(iQuery, iColModelBody);
				xArray[CLASS_MODEL_SKIN] = SQL_ReadResult(iQuery, iColModelSkin);
				SQL_ReadResult(iQuery, iColPrimaryWpn, xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]));
				SQL_ReadResult(iQuery, iColSecondaryWpn, xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]));
				SQL_ReadResult(iQuery, iColVKnife, xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]));
				SQL_ReadResult(iQuery, iColPKnife, xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]));
				SQL_ReadResult(iQuery, iColKnifeSND, xArray[CLASS_KNIFE_SOUNDS], charsmax(xArray[CLASS_KNIFE_SOUNDS]));
				SQL_ReadResult(iQuery, iColAuthid, xArray[CLASS_AUTHID], charsmax(xArray[CLASS_AUTHID]));
				xArray[CLASS_FLAGS] = SQL_ReadResult(iQuery, iColFlags);
				
				formatex(szFile, charsmax(szFile), "models/player/%s/%s.mdl", xArray[CLASS_MODEL], xArray[CLASS_MODEL]);
				PRECACHE_PLAYER_MODEL(szFile);
				formatex(szFile, charsmax(szFile), "models/player/%s/%sT.mdl", xArray[CLASS_MODEL], xArray[CLASS_MODEL]);
				if(file_exists(szFile)) PRECACHE_PLAYER_MODEL(szFile);
				
				PRECACHE_WEAPON_VIEW_MODEL(xArray[CLASS_V_KNIFE_MDL]);
				PRECACHE_WEAPON_PLAYER_MODEL(xArray[CLASS_P_KNIFE_MDL]);
				
				ArrayPushArray(g_classes_array, xArray);
				g_iClasses ++;
			}
			
			// free iQuery.
			SQL_FreeHandle(iQuery);
			
			log_amx("[JAILBREAK] '%d' CLASS%s HAS BEEN SUCCESSFULLY LOADED FROM THE DATABASE !", g_iClasses, g_iClasses > 1 ? "ES":"");
		}
		
		// free connection.
		SQL_FreeHandle(iConnection);
	}
	else
	{
		log_error(AMX_ERR_GENERAL, "Error: Failed to create the tuple!");
		load_jailbreak_classes_file();
	}
	
	return 0;
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	register_event("HLTV", "round_start", "a", "1=0", "2=0");
	register_event("StatusValue", "fw_statusvalue_target", "bce", "1=2", "2>0");
	register_event("StatusValue", "fw_statusvalue_notarget", "bce", "1=2", "2=0");

	register_event("ShowMenu", "fw_ShowMenu_Event", "b");
	register_event("VGUIMenu", "fw_VGUIMenu_Event", "b");
	
	register_logevent("round_started", 2, "0=World triggered", "1=Round_Start");
	register_logevent("round_end", 2, "0=World triggered", "1=Round_End", "1&Restart_Round");
	
	register_clcmd("jointeam", "clcmd_join");
	register_clcmd("chooseteam", "clcmd_join");
	
	register_clcmd("joinclass", "clcmd_joinclass");
	
	register_clcmd("radio1", "clcmd_radio1");
	register_clcmd("radio2", "clcmd_radio2");
	register_clcmd("radio3", "clcmd_radio3");
	register_clcmd("set_command_value", "clcmd_set_cmd_value", ADMIN_LEVEL_A);
	
	g_msgSendAudio = get_user_msgid("SendAudio");
	g_msgTextMsg = get_user_msgid("TextMsg");
	g_msgHudTextArgs = get_user_msgid("HudTextArgs");
	g_msgStatusIcon = get_user_msgid("StatusIcon");
	g_msgTeamInfo = get_user_msgid("TeamInfo");
	g_msgSayText = get_user_msgid("SayText");
	g_msgMoney = get_user_msgid("Money"); 
	g_msgScoreInfo = get_user_msgid("ScoreInfo");
	//g_msgRadar = get_user_msgid("Radar");
	
	register_message(g_msgSayText, "fw_SayText_message");
	register_message(g_msgTextMsg, "fw_text_message");
	register_message(g_msgHudTextArgs, "fw_hudtextargs_message");
	register_message(get_user_msgid("ShowMenu"), "teammenu_Hook");
	register_message(get_user_msgid("VGUIMenu"), "teammenuVGUI_Hook");
	register_message(g_msgMoney, "fw_message_money");
	register_message(get_user_msgid("Account"), "fw_message_account");
	register_message(g_msgScoreInfo, "fw_message_scoreinfo");
	register_message(g_msgTextMsg, "message_textmsg");
	register_message(g_msgSendAudio, "message_sendaudio");
	
	fw_jbmm_itemadded = CreateMultiForward("jb_mm_itemadded", ET_CONTINUE, FP_CELL, FP_CELL);
	fw_jbmm_item_selected = CreateMultiForward("jb_mm_itemselected", ET_IGNORE, FP_CELL, FP_CELL);
	fw_lr_item_select = CreateMultiForward("jb_lr_duel_select", ET_CONTINUE, FP_CELL, FP_CELL);
	fw_lr_item_selected = CreateMultiForward("jb_lr_duel_selected", ET_CONTINUE, FP_CELL, FP_CELL);
	fw_lr_duel_start = CreateMultiForward("jb_lr_duel_start", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL);
	fw_lr_duel_started = CreateMultiForward("jb_lr_duel_started", ET_IGNORE, FP_CELL, FP_CELL, FP_CELL);
	fw_lr_duel_end = CreateMultiForward("jb_lr_duel_end", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL);
	fw_lr_duel_ended = CreateMultiForward("jb_lr_duel_ended", ET_IGNORE, FP_CELL, FP_CELL, FP_CELL);
	fw_shop_item_select_pre = CreateMultiForward("jb_shop_item_preselect", ET_CONTINUE, FP_CELL, FP_CELL);
	fw_shop_item_select_post = CreateMultiForward("jb_shop_item_postselect", ET_CONTINUE, FP_CELL, FP_CELL);
	fw_shop_item_bought = CreateMultiForward("jb_shop_item_bought", ET_IGNORE, FP_CELL, FP_CELL);
	fw_day_start = CreateMultiForward("jb_day_start", ET_CONTINUE, FP_CELL);
	fw_day_started = CreateMultiForward("jb_day_started", ET_IGNORE, FP_CELL);
	fw_day_end = CreateMultiForward("jb_day_end", ET_CONTINUE, FP_CELL);
	fw_day_ended = CreateMultiForward("jb_day_ended", ET_IGNORE, FP_CELL);
	fw_day_preselected = CreateMultiForward("jb_day_preselected", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL);
	fw_day_postselected = CreateMultiForward("jb_day_postselected", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL);
	fw_round_start = CreateMultiForward("jb_round_start_pre", ET_CONTINUE);
	fw_round_started = CreateMultiForward("jb_round_start", ET_IGNORE);
	fw_round_end = CreateMultiForward("jb_round_end_pre", ET_CONTINUE);
	fw_round_ended = CreateMultiForward("jb_round_end", ET_IGNORE);
	fw_pretouch_wpnbox = CreateMultiForward("jb_pretouch_wpnbox", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL);
	fwd_teamhandling = CreateMultiForward("jb_team_join", ET_CONTINUE, FP_CELL);

	register_clcmd("say", "jailbreak_commands", ADMIN_LEVEL_A);
	register_clcmd("say_team", "jailbreak_commands", ADMIN_LEVEL_A);

	for(new i, maxloop = sizeof g_szJB_CONCOMMANDS; i < maxloop; i++)
	{
		g_iJB_CONCOMMAND_ID[ i ] = register_concmd(g_szJB_CONCOMMANDS[ i ], "jailbreak_commands", g_JB_CONCOMMANDS_ACCESS[ i ]);
	}
	
	register_concmd("jb_start_voteday", "concmd_start_voteday", ADMIN_LEVEL_A);
	register_concmd("jb_set_funday_timer", "concmd_apply_newtimer", ADMIN_LEVEL_A, "<funday name (part of name)> <new timer>");
	
	formatex(MOD, charsmax(MOD), "%s_v%s_By_%s", PLUGIN, VERSION, AUTHOR);
	register_cvar(MOD, "", FCVAR_SERVER|FCVAR_PROTECTED|FCVAR_SPONLY);
	
	for(new i = 0; i < sizeof CVARS_DATA; i++)
	{
		g_iCvar_identity[i] = register_cvar(CVARS_DATA[i][STR_CVARSNAME], CVARS_DATA[i][STR_CVARSVALUE]);
	}
	
	for(new i = CSW_P228, szWpn[24];  i <= CSW_P90; i++)
	{
		get_weaponname(i, szWpn, charsmax(szWpn));
		
		if(szWpn[0] == 'w' && szWpn[6] == '_')
		{
			RegisterHam(Ham_Item_AddToPlayer, szWpn, "fw_Ham_ItemAdd2Player");
			RegisterHam(Ham_Touch, szWpn, "fw_touch_weaponbox", 0);
		}
	}
	
	RegisterHam(Ham_Touch, "weaponbox", "fw_touch_weaponbox", 0);
	RegisterHam(Ham_Touch, "armoury_entity", "fw_touch_weaponbox", 0);
	RegisterHam(Ham_Touch, "weapon_shield", "fw_touch_weaponbox", 0);

	RegisterHam(Ham_Spawn, "player", "fw_player_spawned", 1);
	RegisterHam(Ham_Spawn, "player", "fw_player_spawning", 0);
	
	RegisterHam(Ham_TraceAttack, "player", "fw_player_traceattack_pre");
	RegisterHam(Ham_TakeDamage, "player", "fw_player_takedamage_pre");
	RegisterHam(Ham_TakeDamage, "player", "fw_player_takedamage_post", 1);

	RegisterHam(Ham_Item_Deploy, "weapon_knife", "fw_knife_deploy", 0);
	RegisterHam(Ham_Item_Deploy, "weapon_knife", "fw_knife_deploy", 1);
	
	RegisterHam(Ham_Killed, "player", "fw_player_killed_post", 1);
	
	RegisterHam(Ham_TraceAttack, "func_button", "fw_button_traceattack_post", 1);
	RegisterHam(Ham_CS_Restart, "func_door", "fw_restart_cells_post", 1);
	RegisterHam(Ham_Use, "func_button", "fw_button_use_post", 1);
	RegisterHam(Ham_Use, "func_button", "fw_button_use_pre", 0);
	RegisterHam(Ham_Use, "button_target", "fw_button_use_pre", 0);
	RegisterHam(Ham_Touch, "trigger_hurt", "fw_healing_use_pre", 0);
	RegisterHam(Ham_Use, "game_player_equip", "fw_button_use_pre", 0);
	RegisterHam(Ham_Use, "player_weaponstrip", "fw_button_use_pre", 0);
	RegisterHam(Ham_Use, "func_healthcharger", "fw_healing_use_pre", 0);
	
	formatex(MOD, charsmax(MOD), "%s_v%s", PLUGIN, VERSION);
	register_forward(FM_GetGameDescription, "fw_GetGameDescription");
	register_forward(FM_EmitSound, "fw_emitsound");
	
	register_logevent("fw_got_theBomb", 3, "2=Spawned_With_The_Bomb");
	
	g_iMaxplayers = get_maxplayers();
	g_lr_inprogress = JB_LR_DEACTIVATED;
	g_day_inprogress = JB_DAY_CAGEDAY;
	
	for(new j, i; j < TEAM_MAX; j++)
	{
		for(i = 0; i < g_iMaxplayers; i++)
		{
			g_iClass[i][j] = -1;
		}
	}
	
	g_pcvar_mp_friendlyfire = get_cvar_pointer("mp_friendlyfire");

	// MP_FRIENDLYFIRE ? remove cvar change loggings. ( JEEZ WAS SO ANNOYING )
	set_pcvar_flags(g_pcvar_mp_friendlyfire, (get_pcvar_flags(g_pcvar_mp_friendlyfire)|FCVAR_UNLOGGED));

	// Languages Support...
	register_dictionary("jailbreak_langs.txt");
}

public fw_player_traceattack_pre(iVictim, iAttacker, Float:flDamage, Float:fDirection[3], pTraceresult, iDamagebits)
{
	if(!is_user_connected(iAttacker) || iVictim == iAttacker || flDamage <= 0.0 ) return HAM_IGNORED;
	
	static bitsUserAllies;
	bitsUserAllies = g_bUser_allies_HasBoundVar[iAttacker] ? get_xvar_num(g_iUser_allies[iAttacker]) : g_iUser_allies[iAttacker];

	if(bitsUserAllies  != JB_ALLIES_DEFAULT )
	{
		if(check_flag(bitsUserAllies,iVictim))
		{
			SetHamParamFloat(3, Float:0.0);
			return HAM_SUPERCEDE;
		}
	}
	
	return HAM_IGNORED;
}

public fw_player_takedamage_pre(iVictim, iInflictor, iAttacker, Float:flDamage, iDamagebits)
{	
	if(!is_user_connected(iAttacker) || iVictim == iAttacker || flDamage <= 0.0) return HAM_IGNORED;
	
	static bitsUserAllies;
	bitsUserAllies = g_bUser_allies_HasBoundVar[iAttacker] ? get_xvar_num(g_iUser_allies[iAttacker]) : g_iUser_allies[iAttacker];
	g_ex_iUser_enemies[iAttacker] = g_bUser_enemies_HasBoundVar[iAttacker] ? get_xvar_num(g_iUser_enemies[iAttacker]) : g_iUser_enemies[iAttacker];

	if( check_flag(g_ex_iUser_enemies[iAttacker],iVictim) )
	{
		if(fm_get_user_team(iVictim) == fm_get_user_team(iAttacker))
		{
			flDamage = (flDamage * 2.86 );
			g_cvar_mp_friendlyfire = get_pcvar_num(g_pcvar_mp_friendlyfire);
			set_pcvar_num(g_pcvar_mp_friendlyfire, 1);
			SetHamParamFloat(4, flDamage);
			return HAM_HANDLED;
		}
	}
	else if( check_flag(bitsUserAllies,iVictim) )
	{
		SetHamParamFloat(4, Float:0.0);
		return HAM_HANDLED;
	}
	
	return HAM_IGNORED;
}

public fw_player_takedamage_post(iVictim, iInflictor, iAttacker, Float:flDamage, iDmgBits)
{
	if(!is_user_connected(iAttacker) || iVictim == iAttacker) return HAM_IGNORED;

	if( check_flag(g_ex_iUser_enemies[iAttacker],iVictim) )
	{
		if(fm_get_user_team(iVictim) == fm_get_user_team(iAttacker))
		{
			set_pcvar_num(g_pcvar_mp_friendlyfire, g_cvar_mp_friendlyfire);
		}
	}
	
	return HAM_IGNORED;
}

public clcmd_radio1(id)
{
	if(fm_get_user_team(id) == TEAM_GUARDS)
	{
		if(is_user_admin(id))
		{
			admin_menu(id, .menuid=ADMIN_MENU_MAIN_MENU);
			return PLUGIN_HANDLED;
		}
		else {
			join_menu(id);
			return PLUGIN_HANDLED;
		}
	}
	return PLUGIN_CONTINUE;
}

public clcmd_radio2(id)
{
	shop_menu(id);
	return PLUGIN_HANDLED;
}

public clcmd_radio3(id)
{
	if(fm_get_user_team(id) == TEAM_PRISONERS)
	{
		if(is_user_admin(id))
		{
			admin_menu(id, .menuid=ADMIN_MENU_MAIN_MENU);
			return PLUGIN_HANDLED;
		}
		else {
			join_menu(id);
			return PLUGIN_HANDLED;
		}
	}
	return PLUGIN_CONTINUE;
}

public fw_Ham_ItemAdd2Player(ent, player)
{
	static sClassname[24];
	pev(ent, pev_classname, sClassname, charsmax(sClassname));
	new iWpn = get_weaponid(sClassname);
	
	if( (CSW_P90 >= iWpn >= CSW_P228) && check_flag(g_user_wpns_blocked[player],iWpn) )
	{
		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);

		SetHamReturnInteger(false);
		return HAM_SUPERCEDE;
	}
	return HAM_IGNORED;
}

public fw_healing_use_pre(ent)
{
	new sClassname[24];
	pev(ent, pev_classname, sClassname, charsmax(sClassname));
	
	if(equal(sClassname, "trigger_hurt") && pev(ent, pev_dmg) > 0)
	{
		return HAM_IGNORED;
	}
	
	if(g_day_inprogress > DAY_NONE)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_HEALING_ONFUNDAYS]))
			return HAM_SUPERCEDE;
	}
	
	if(g_lr_inprogress > DUEL_NONE)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_HEALING_ONLR]))
			return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

public fw_restart_cells_post(cells)
{
	if(CELLS_BUTTON == INVALID_HANDLE || g_cells_iState == JB_CELLS_CLOSE)
	{
		return;
	}

	new szValue[64], szTargetname[64];
	pev(CELLS_BUTTON, pev_target, szValue, charsmax(szValue));
	pev(cells, pev_targetname, szTargetname, charsmax(szTargetname));

	if(equal(szValue, szTargetname))
	{
		logevent_message(.szMessage="The cells are closed!");
		g_cells_iState = JB_CELLS_CLOSE;
	}
}

public fw_button_use_post(button, caller, trigger)
{
	if(button == CELLS_BUTTON)
	{
		g_cells_iState = (g_cells_iState == JB_CELLS_CLOSE) ? JB_CELLS_OPEN : JB_CELLS_CLOSE;

		switch( g_cells_iState )
		{
			case JB_CELLS_OPEN: logevent_message(.szMessage="The cells are opened!");
			case JB_CELLS_CLOSE: logevent_message(.szMessage="The cells are closed!");
		}
	}
}

public fw_button_use_pre(button, caller, trigger)
{
	if(g_day_inprogress > DAY_NONE)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_BUTTONS_ONFUNDAYS]))
			return HAM_SUPERCEDE;
	}
	
	if(g_lr_inprogress > DUEL_NONE)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_BUTTONS_ONLR]))
			return HAM_SUPERCEDE;
	}

	return HAM_IGNORED;
}

public fw_GetGameDescription()
{
	forward_return(FMV_STRING, MOD);
	return (FMRES_SUPERCEDE);
}

public task_end_the_round(taskid)
{
	if(bHAS_ROUND_ENDED || !bHAS_ROUND_ENDING)
	{
		return;
	}
	
	bHAS_ROUND_ENDING = false;

	switch( g_WinnerTeam )
	{
		case TeamWinning_Terrorist: {
			TerminateRound( TR_RoundEndType_TeamExterminate, TeamWinning_Terrorist );
		}
		case TeamWinning_Ct: {
			TerminateRound( TR_RoundEndType_TeamExterminate, TeamWinning_Ct );
		}
		case TeamWinning_None: {
			TerminateRound( TR_RoundEndType_Draw );
		}
	}

	g_WinnerTeam = TeamWinning_None;
}

public fw_message_account(msgid, dest, id)
{
	const ARG_USER_ACCOUNT = 1;
	const ARG_ACCOUNT_VALUE = 2;
	const MSGID_ACCOUNT_MAX_ARGS = 2;
	if(get_msg_args() >= MSGID_ACCOUNT_MAX_ARGS)
	{
		if(get_msg_argtype(ARG_ACCOUNT_VALUE) == ARG_LONG)
		{
			if(get_msg_arg_int(ARG_ACCOUNT_VALUE) > -1) set_msg_arg_int(ARG_ACCOUNT_VALUE, ARG_LONG, user_cash[clamp(get_msg_arg_int(ARG_USER_ACCOUNT), 1, MAX_PLAYERS)]);
		}
	}
}

new const text_game_messages[][] = {
	"#Fire_in_the_hole",
	"#Game_radio",
	"#Game_teammate_attack",
	"#Game_teammate_kills",
	"#Killed_Teammate",
	"#Command_Not_Available",
	"#CT_cant_buy",
	"#Terrorist_cant_buy"
};

new const hudtextargs_game_messages[][] = {
	"hint_win_round_by_killing_enemy",
	"hint_press_buy_to_purchase",
	"hint_spotted_an_enemy",
	"hint_use_nightvision",
	"hint_lost_money",
	"hint_removed_for_next_hostage_killed",
	"hint_careful_around_hostages",
	"hint_careful_around_teammates",
	"hint_reward_for_killing_vip",
	"hint_win_round_by_killing_enemy",
	"hint_try_not_to_injure_teammates",
	"hint_you_are_in_targetzone",
	"hint_hostage_rescue_zone",
	"hint_terrorist_escape_zone",
	"hint_ct_vip_zone",
	"hint_terrorist_vip_zone",
	"hint_cannot_play_because_tk",
	"hint_use_hostage_to_stop_him",
	"hint_lead_hostage_to_rescue_point",
	"hint_you_have_the_bomb",
	"hint_you_are_the_vip",
	"hint_out_of_ammo",
	"hint_spotted_a_friend",
	"hint_spotted_an_enemy",
	"hint_prevent_hostage_rescue",
	"hint_rescue_the_hostages",
	"hint_press_use_so_hostage_will_follow"
};

public fw_hudtextargs_message(msgid, dest, id)
{
	static szHint[40];
	get_msg_arg_string(1, szHint, charsmax(szHint));
	
	const hgmsg_size = sizeof hudtextargs_game_messages;

	for(new i; i < hgmsg_size; i++)
		if (equal(szHint[6], hudtextargs_game_messages[i][5]))
			return PLUGIN_HANDLED;	
	
	return PLUGIN_CONTINUE;
}

public fw_SayText_message(msgid, dest, id)
{
	static sender; sender = get_msg_arg_int( 1 );
	if(g_iUserGagged[sender] != 0)
	{
		client_cmd(sender, "spk ^"barney/youtalkmuch.wav^"");
		client_print(sender, print_center, "You talk too much!!!");
		return PLUGIN_HANDLED;
	}
	return PLUGIN_CONTINUE;
}

public fw_text_message(msgid, dest, id)
{
	if(get_msg_args() < 2) return PLUGIN_CONTINUE;
	
	static szBuffer[40];
	get_msg_arg_string(2, szBuffer, charsmax(szBuffer));
	
	const tgmsg_size = sizeof text_game_messages;
	
	for(new i; i < tgmsg_size; i++)
		if (equal(szBuffer, text_game_messages[i]))
			return PLUGIN_HANDLED;	
	
	return PLUGIN_CONTINUE;
}

public fw_message_money(msgid, dest, id)
{ 
	if(get_msg_argtype( 1 ) == ARG_LONG)
	{
		set_msg_arg_int( 1 , ARG_LONG, user_cash[id]);
	}
}

public fw_message_scoreinfo(msgid, dest, id)
{
	new target = get_msg_arg_int( 1 );
	
	set_msg_arg_int( 2 , ARG_SHORT, g_iUSER_KILLS[target]);
}

public fw_player_killed_post(iVictim, iKiller, shouldgib)
{
	remove_flag(IsUserAlive,iVictim);
	
	if( ( 1 <= iKiller <= g_iMaxplayers ) && iKiller != iVictim )
	{
		set_user_frags(iKiller, ++g_iUSER_KILLS[iKiller]);
		
		// making sure the scoreboard gets updated!!!
		message_begin(MSG_ALL, g_msgScoreInfo, _, 0);
		write_byte(iKiller);
		write_short(g_iUSER_KILLS[iKiller]);
		write_short(get_user_deaths(iKiller));
		write_short(0);
		write_short(get_user_team(iKiller));
		message_end();
		
		if( fm_get_user_team(iVictim) == fm_get_user_team(iKiller) && check_flag(g_ex_iUser_enemies[iKiller],iVictim) )
		{
			set_pcvar_num(g_pcvar_mp_friendlyfire, g_cvar_mp_friendlyfire);
		}
	}
	
	if(g_lr_inprogress != DUEL_NONE)
	{
		if( (g_iMaxplayers >= iKiller > 0) && g_lr_inprogress != JB_LR_ACTIVATED && 
			( ((iKiller == g_iLRPrisoner || iKiller == g_iLRGuard ) && (iVictim != g_iLRPrisoner && iVictim != g_iLRGuard)) ||
		      ((iKiller != g_iLRPrisoner && iKiller != g_iLRGuard ) && (iVictim == g_iLRPrisoner || iVictim == g_iLRGuard)) ) )
		{
			new cash_loose_amount = get_pcvar_num(g_iCvar_identity[CVAR_DUEL_LOST_CASH]);
			
			if(cash_loose_amount > 0)
			{
				new sName[32];
				get_user_name(iKiller, sName, charsmax(sName));
				
				cprint_chat(0, _, "%L", LANG_PLAYER, "LR_LOOSE_CASH", sName, cash_loose_amount);
				jb_set_user_cash(iKiller, jb_get_user_cash(iKiller)-cash_loose_amount);
			}
		}
		
		if(iVictim == g_iLRPrisoner || iVictim == g_iLRGuard || (get_prisonersnum(FLAG_ALIVE_ONLY) * get_guardsnum(FLAG_ALIVE_ONLY)) == 0)
		{
			_end_theduel();
		}
	}
	else if(g_day_inprogress > DAY_NONE)
	{
		#if AMXX_VERSION_NUM > 182
		if(iKiller != iVictim && pev_valid(iKiller) && fm_get_user_team(iVictim) == fm_get_user_team(iKiller))
		{
			set_ent_data(iKiller, "CBasePlayer", "m_iTeamKills", 0);
			set_ent_data(iKiller, "CBasePlayer", "m_bJustKilledTeammate", false);
		}
		#endif

		switch( ArrayGetCell(g_days_dayendtype, g_day_inprogress) )
		{
			case DAY_GUARDS_VS_PRISONERS:
			{
				// PRISONER LAST REQUEST!
				if( get_prisonersnum(FLAG_ALIVE_ONLY) <= 1 )
				{
					_end_theday();
				}
			}
			case DAY_ONE_SURVIVOR:
			{
				CheckDayOneSurvivorRemaining();
			}
		}
	}
	
	if(g_day_inprogress == JB_DAY_CAGEDAY && get_prisonersnum(FLAG_ALIVE_ONLY) == 1 && get_guardsnum(FLAG_ALIVE_ONLY) > 0)
	{
		if(g_lr_inprogress == JB_LR_DEACTIVATED)
		{
			new winner = get_last_prisoner_alive(.bInclude_bots=true);

			if(winner > 0 && g_iLRPrisoner != winner)
			{
				g_lr_inprogress = JB_LR_ACTIVATED;
				g_iLRPrisoner = winner;

				logevent_message(.szMessage="Last request is activated!");

				if(!is_user_bot(winner))
				{
					Show_lastrequestmenu(winner);
				}
			}
		}
	}
	
	return HAM_IGNORED;
}

CheckDayOneSurvivorRemaining()
{
	new players[32], pnum;
	get_players(players, pnum, "ah");

	if(pnum <= 1)
	{
		if(pnum == 1)
		{
			new szName[32], player = players[ 0 ];
			get_user_name(player, szName, charsmax(szName));
			client_print(0, print_center, "%s Win!", szName);
			server_print("JAILBREAK | %s has won the specialday!", szName);

			new szDayname[MAX_DAYITEM_NAME_LENGTH];
			ArrayGetString(g_days_itemname, g_day_inprogress, szDayname, charsmax(szDayname));

			logevent_message_action("has won the '%s' day!", player, 0, szDayname);
		}

		_end_theday();
	}
}

public fw_button_traceattack_post(entButton, attacker, Float:dmg, Float:direction[3], trace, bits)
{
	if( !(1 <= attacker <= g_iMaxplayers) || !check_flag(IsUserAlive,attacker) ) return;
	
	static Float:fHealth;
	pev(entButton, pev_health, fHealth);
	
	// button already gets activated by getting shot!
	if(fHealth > 0.0) return;
	
	static weaponid, team;
	weaponid = get_user_weapon(attacker);
	team = fm_get_user_team(attacker);
	
	switch(get_pcvar_num(g_iCvar_identity[CVAR_BUTTON_ACTIVATION]))
	{
		case 0: return;
		case 1: if(dmg <= 0.0) return;
		case 2: if(weaponid != CSW_KNIFE) return;
		case 3: if(team != TEAM_PRISONERS) return;
		case 4: if(team != TEAM_GUARDS) return;
		case 5: if(team != TEAM_PRISONERS || weaponid != CSW_KNIFE) return;
		case 6: if(team != TEAM_GUARDS || weaponid != CSW_KNIFE) return;
	}
	
	if(weaponid > 0)
	{
		new szWpname[24];
		get_weaponname(weaponid, szWpname, charsmax(szWpname));
		ExecuteHamB(Ham_Use, entButton, attacker, find_ent_by_owner(-1, szWpname, attacker), USE_TOGGLE, 0.0);
	}
	else
	{
		ExecuteHamB(Ham_Use, entButton, attacker, attacker, USE_TOGGLE, 0.0);
	}
}

stock const m_rgpPlayerItems_CWeaponBox[ 6 ] = { 34 , 35 , ... };

cs_get_weaponbox_type( iWeaponBox )
{
	new iWeapon;
	for( new i = 0; i <= 5; i++ )
	{
		if(pev_valid(iWeaponBox) != ENTITY_PDATA_SAFE)
		{
			continue;
		}

		iWeapon = get_pdata_cbase( iWeaponBox, m_rgpPlayerItems_CWeaponBox[ i ], 4 );
		
		if( iWeapon > 0 )
		{
			return cs_get_weapon_id( iWeapon );
		}
	}
	return 0;
}

public fw_touch_weaponbox(entwpnbox, toucher)
{
	if(!(1 <= toucher <= g_iMaxplayers) || !check_flag(IsUserAlive,toucher))
		return HAM_IGNORED;
	
	static sClassname[16], iWpn, bool:bGamePlayerEquip;
	pev(entwpnbox, pev_classname, sClassname, charsmax(sClassname));
	bGamePlayerEquip = false;
	
	if(equal(sClassname, "armoury_entity"))
	{
		iWpn = cs_get_armoury_type(entwpnbox);
	}
	else if(equal(sClassname, "weaponbox"))
	{
		iWpn = cs_get_weaponbox_type(entwpnbox);
	}
	else if(equal(sClassname, "weapon_", 7))
	{
		iWpn = get_weaponid(sClassname);
		bGamePlayerEquip = true;
	}

	if( !iWpn )
	{
		return HAM_IGNORED;
	}
	
	static bool:bBlock, gFwReturn;
	bBlock = (check_flag(g_user_wpns_blocked[toucher],iWpn)) ? true:false;
	gFwReturn = JB_IGNORED;
	ExecuteForward(fw_pretouch_wpnbox, gFwReturn, entwpnbox, toucher, bBlock);
	
	if(gFwReturn >= JB_HANDLED || bBlock)
	{
		if( bGamePlayerEquip )
		{
			set_pev(entwpnbox, pev_flags, FL_KILLME);
			dllfunc(DLLFunc_Think, entwpnbox);
		}

		return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

public concmd_apply_newtimer(id, level, cid)
{
	if(!cmd_access(id, level, cid, 2))
	{
		return PLUGIN_HANDLED;
	}
	
	new szDayname[64], szNewTime[16];
	read_argv(1, szDayname, charsmax(szDayname));
	read_argv(2, szNewTime, charsmax(szNewTime));
	remove_quotes(szDayname);
	remove_quotes(szNewTime);
	
	new iDayid = get_itemid_inarray_bystring(szDayname, g_days_itemname, false);
	
	if(iDayid > DAY_NONE)
	{
		ArrayGetString(g_days_itemname, iDayid, szDayname, charsmax(szDayname));

		new Float:fLength = floatstr(szNewTime);
		ArraySetCell(g_days_itemlength, iDayid, fLength);
		
		if(fLength > 0.0)
		{
			FUNDAY_TIMER_LENGTH = fLength;
			remove_task(TASK_DAY_LENGTH);
			set_task(1.0, "task_day_length", TASK_DAY_LENGTH, _, _, "b");
		}
		else
		{
			FUNDAY_TIMER_LENGTH = 0.0;
			remove_task(TASK_DAY_LENGTH);
		}
		
		new szName[32];
		get_user_name(id, szName, charsmax(szName));
		
		console_print(id, "'%s' %L", szDayname, id, "ADMIN_YOUVE_CHANGED_DAYTIMER");
		if(!id) log_amx("[%s] timer has been changed by the server console !", szDayname);
		else log_amx("[%s] timer has been changed by #%d(%s) !", szDayname, get_user_userid(id), szName);
	}
	
	return PLUGIN_HANDLED;
}

public concmd_start_voteday(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
	{
		return PLUGIN_HANDLED;
	}
	
	if(!Check_day_available(id))
	{
		console_print(id, "%L", id, "ADMIN_YOU_CANT_START_VOTEDAY");
		return PLUGIN_HANDLED;
	}
	
	start_theday(VOTE_DAY);
	
	new sName[32];
	get_user_name(id, sName, charsmax(sName));
	console_print(id, "%L", id, "ADMIN_YOUVE_STARTED_VOTEDAY");
	cprint_chat(0, _, "%L", LANG_PLAYER, "ADMIN_STARTED_VOTEDAY", sName);
	
	logevent_message_action("Admin has started a voteday!", id, 0);
	
	return PLUGIN_HANDLED;
}

public fw_statusvalue_target(id)
{
	static iTarget;
	iTarget = read_data(2);

	if( g_iMaxplayers >= iTarget >= 1 && check_flag(IsUserAlive,iTarget) ) 
	{
		logevent_message_action("is Looking @", id, iTarget);
	}
}

public fw_statusvalue_notarget(id)
{
	logevent_message_action("is no longer Looking @ anyone", id);
}

public fw_emitsound(const entity, const channel, const sound[], Float:vol, Float:attn, flag, pitch)
{
	if(!is_user_connected(entity)) return FMRES_IGNORED;
	
	if(!check_flag(IsUserAlive,entity))
		return FMRES_IGNORED;
	
	static classid; classid = g_iClass[entity][clamp(fm_get_user_team(entity), 0, charsmax(g_iClass[]))];
	
	if(jb_is_user_class_valid(entity, classid) <= 0)
		return FMRES_IGNORED;
	
	static xArray[CLASSES_DATA], szWeaponplayermdl[MAX_FILE_DIRECTORY_LEN];
	ArrayGetArray(g_classes_array, classid, xArray);
	pev(entity, pev_weaponmodel2, szWeaponplayermdl, charsmax(szWeaponplayermdl));
	
	if(xArray[CLASS_KNIFE_SOUNDS][0] == EOS || szWeaponplayermdl[0] == EOS || !equal(xArray[CLASS_P_KNIFE_MDL],szWeaponplayermdl))
		return FMRES_IGNORED;
	
	for(new i, sSound[64]; i < sizeof knife_sounds; i++)
	{
		if(equal(sound[13], knife_sounds[i]))
		{
			formatex(sSound, charsmax(sSound), "%s%s", xArray[CLASS_KNIFE_SOUNDS], knife_sounds[i]);
			emit_sound(entity, channel, sSound, vol, attn, flag, pitch);
			return FMRES_SUPERCEDE;
		}
	}
	return FMRES_IGNORED;
}

public fw_knife_deploy(const Knife)
{
	if(pev_valid(Knife) != ENTITY_PDATA_SAFE)
	{
		return HAM_IGNORED;
	}

	new id = get_pdata_cbase(Knife, m_pPlayer, WEAPON_LINUXDIFF);
	new classid = g_iClass[id][clamp(fm_get_user_team(id), 0, charsmax(g_iClass[]))];
	
	if(!check_flag(IsUserAlive,id) || jb_is_user_class_valid(id,classid) <= 0 || cs_get_user_shield(id))
	{
		return HAM_IGNORED;
	}
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, classid, xArray);
	
	set_pev(id, pev_viewmodel2, xArray[CLASS_V_KNIFE_MDL]);
	set_pev(id, pev_weaponmodel2, xArray[CLASS_P_KNIFE_MDL]);
	
	return HAM_IGNORED;
}

public fw_got_theBomb()
{
	new sName[32], sText[64];
	read_logargv(0, sText, charsmax(sText));
	parse_loguser(sText, sName, charsmax(sName));
	
	new id = get_user_index(sName);
	
	message_begin(MSG_ONE_UNRELIABLE, g_msgStatusIcon, _, id);
	write_byte(0);
	write_string("c4");
	message_end() ;
	
	ham_strip_weapon(id, "weapon_c4");
	//strip_weapons(id)
	engclient_cmd(id, "weapon_knife");
}

public clcmd_joinclass(id)
{
	// ignore bots.
	if(is_user_bot(id))
	{
		return PLUGIN_CONTINUE;
	}
	
	class_menu(id);
	return PLUGIN_HANDLED;
}

public teammenuVGUI_Hook(iMsgid, dest, id)
{
	// IGNORE BOTS
	if(is_user_bot(id))
	{
		return PLUGIN_CONTINUE;
	}
	
	const MENU_ID_JOIN_TEAM = 2;
	const MENU_ID_JOIN_CLASS_CT = 27;
	const MENU_ID_JOIN_CLASS_T = 26;

	switch( get_msg_arg_int(1) )
	{
		case MENU_ID_JOIN_TEAM, MENU_ID_JOIN_CLASS_CT, MENU_ID_JOIN_CLASS_T:
		{
			return PLUGIN_HANDLED;
		}
	}

	return PLUGIN_CONTINUE;
}

public fw_VGUIMenu_Event( id )
{
	new iMenuID = read_data( 1 );

	const MENU_ID_JOIN_TEAM = 2;
	const MENU_ID_JOIN_CLASS_CT = 27;
	const MENU_ID_JOIN_CLASS_T = 26;

	switch( iMenuID )
	{
		case MENU_ID_JOIN_TEAM:
		{
			join_menu(id);
		}
		case MENU_ID_JOIN_CLASS_CT, MENU_ID_JOIN_CLASS_T:
		{
			class_menu(id);
		}
	}
}

public message_textmsg( msg_id, msg_dest, msg_entity )
{
	if(get_msg_args() < 2 || get_msg_argtype(2) != ARG_STRING) return PLUGIN_CONTINUE;
	
	static message[16];
	get_msg_arg_string( 2, message, sizeof message - 1 );
	
	// -- #CTs_Win ; #Terrorists_Win ; #Round_Draw
	if(equal(message, "#CTs_Win"))
	{
		logevent_message(.szMessage="Guards win!");
		return PLUGIN_HANDLED;
	}

	if(equal(message, "#Terrorists_Win"))
	{
		logevent_message(.szMessage="Prisoners win!");
		return PLUGIN_HANDLED;
	}

	if(equal(message, "#Round_Draw"))
	{
		logevent_message(.szMessage="Round Draw!");
		return PLUGIN_HANDLED;
	}
	return PLUGIN_CONTINUE;
}

public message_sendaudio( msg_id, msg_dest, msg_entity )
{
	if(get_msg_args() < 2 || get_msg_argtype(2) != ARG_STRING)
	{
		return PLUGIN_CONTINUE;
	}
	
	// -- %!MRAD_terwin ; %!MRAD_ctwin ; %!MRAD_rounddraw
	static message[24];
	get_msg_arg_string( 2, message, sizeof message - 1 );

	if(equal(message, "%!MRAD_rounddraw") || equal(message, "%!MRAD_ctwin") || equal(message, "%!MRAD_terwin"))
	{
		return PLUGIN_HANDLED;
	}
	
	return PLUGIN_CONTINUE;
}

public teammenu_Hook(iMsgid, dest, id)
{
	// IGNORE BOTS
	if(is_user_bot(id) || get_msg_args() < 4 || get_msg_argtype(4) != ARG_STRING)
	{
		return PLUGIN_CONTINUE;
	}
	
	static StrMessage[24];
	get_msg_arg_string(4, StrMessage, charsmax(StrMessage));
	
	// join team
	if(equal(StrMessage, "#Team_Select", strlen("#Team_Select")) || equal(StrMessage, "#IG_Team_Select", strlen("#IG_Team_Select")))
	{
		return PLUGIN_HANDLED;
	}
	else if(equal(StrMessage, "#Terrorist_Select") || equal(StrMessage, "#CT_Select"))
	{
		return PLUGIN_HANDLED;
	}

	return PLUGIN_CONTINUE;
}

public fw_ShowMenu_Event( id )
{
	static StrMessage[24];
	read_data(4, StrMessage, charsmax(StrMessage));

	if(equal(StrMessage, "#Team_Select", strlen("#Team_Select")) || equal(StrMessage, "#IG_Team_Select", strlen("#IG_Team_Select")))
	{
		join_menu(id);
	}
	else if(equal(StrMessage, "#Terrorist_Select") || equal(StrMessage, "#CT_Select"))
	{
		class_menu(id);
	}
}

public client_authorized(id)
{
	// change  to vgui menu..
	set_user_info(id, "_vgui_menus", "1");
	
	if(!is_user_bot(id) && !is_user_hltv(id))
	{
		// load user cash
		load_user_cash(id);

		//Is User Gagged?
		check_user_gagged(id);
	}
	
	g_iClass[id][TEAM_ANY] = -1;
	g_iClass[id][TEAM_SPECTATOR] = -1;
	g_iClass[id][TEAM_GUARDS] = -1;
	g_iClass[id][TEAM_PRISONERS] = -1;
	
	g_iNextClass[id] = -1;
	g_fPlayerDiscount[id] = 0.0;

	if(g_lr_inprogress != DUEL_NONE)
	{
		if(g_iLRPrisoner > 0) EF_AttachToPlayer(g_iLRPrisoner, 40.0, red_duelSpr, 9999.0, .iDest = MSG_ONE, .host = id);
		if(g_iLRGuard    > 0) EF_AttachToPlayer(g_iLRGuard,    40.0, blue_duelSpr, 9999.0, .iDest = MSG_ONE, .host = id);
	}
}

public client_remove(id)
{
	if(g_lr_inprogress != JB_LR_DEACTIVATED)
	{
		// one of the duelers ran out!
		if(id == g_iLRGuard || id == g_iLRPrisoner)
		{
			_end_theduel();
		}
	}
	else if(g_day_inprogress == JB_DAY_VOTEDAY)
	{
		if(get_prisonersnum(FLAG_ALIVE_ONLY) < SPECIALDAY_INMATES_REQUIREMENT)
		{
			cprint_chat(0, 'n', "%L", LANG_SERVER, "DAY_REQUIRES");
			_end_theday();
		}
	}
	else if(g_day_inprogress != JB_DAY_CAGEDAY)
	{
		new iTotal_Alive_players = (get_guardsnum(FLAG_ALIVE_ONLY) + get_prisonersnum(FLAG_ALIVE_ONLY));
		new iTotal_players = (get_guardsnum(FLAG_ALL) + get_prisonersnum(FLAG_ALL));
		switch( ArrayGetCell(g_days_dayendtype, g_day_inprogress) )
		{
			case DAY_ONE_SURVIVOR: CheckDayOneSurvivorRemaining();
			case DAY_TIMER: if(iTotal_players <= 1) _end_theday();
			case DAY_GUARDS_VS_PRISONERS: if(iTotal_Alive_players <= 1 || iTotal_players <= 1) _end_theday();
		}
	}

	if(g_day_inprogress == JB_DAY_CAGEDAY)
	{
		if(g_lr_inprogress == JB_LR_DEACTIVATED && get_prisonersnum(FLAG_ALIVE_ONLY) == 1 && get_guardsnum(FLAG_ALIVE_ONLY) > 0 )
		{
			new winner = get_last_prisoner_alive(.bInclude_bots=true);
			if(winner > 0 && !g_iLRPrisoner)
			{
				g_lr_inprogress = JB_LR_ACTIVATED;
				g_iLRPrisoner = winner;

				logevent_message(.szMessage="Last request is activated!");

				if(!is_user_bot(winner))
				{
					Show_lastrequestmenu(winner);
				}
			}
		}
	}
}

public client_disconnect(id)
{
	// save user cash on disconnection.
	new szFlags[4];
	get_pcvar_string(g_iCvar_identity[CVAR_SAVE_CASH_EVENT], szFlags, charsmax(szFlags));
	if(read_flags("a") & read_flags(szFlags) && !is_user_bot(id) && !is_user_hltv(id))
	{
		save_user_cash(id);
	}

	// If user is gagged update gag time.
	if(g_iUserGagged[id] > 0)
	{
		update_gag_punishment_time(id);
	}
	
	// reset user variables.
	g_iUSER_KILLS[id] = 0;
	g_iUserGagged[id] = 0;
	
	// remove flags...
	remove_flag(g_votedays_voted,id);
	remove_flag(g_has_avotedaymenu,id);
	remove_flag(IsUserAlive,id);

	// remove tasks
	remove_task(id + TASK_PLAYER_GAG);
}

check_user_gagged(id)
{
	new szAuthID[32], szLength[16], iTimestamp;
	get_user_authid(id, szAuthID, charsmax(szAuthID));
	if(nvault_lookup(g_nvault_gag, szAuthID, szLength, charsmax(szLength), iTimestamp))
	{
		g_iUserGagged[id] = str_to_num(szLength);

		if(g_iUserGagged[id] > 0)
		{
			set_task( floatmax(60.0 * g_iUserGagged[id], 60.0), "task_remove_gag", id + TASK_PLAYER_GAG );
		}

		return 1;
	}

	return 0;
}

update_gag_punishment_time(id)
{
	new szAuthID[32], szLength[16], iTimestamp;
	get_user_authid(id, szAuthID, charsmax(szAuthID));
	if(nvault_lookup(g_nvault_gag, szAuthID, szLength, charsmax(szLength), iTimestamp))
	{
		num_to_str(max( ((iTimestamp + (str_to_num(szLength) * 60)) - get_systime()) , 0), szLength, charsmax(szLength));

		if(szLength[0] == '0')
		{
			nvault_remove(g_nvault_gag, szAuthID);
		}
		else
		{
			nvault_set(g_nvault_gag, szAuthID, szLength);
		}

		return 1;
	}

	return 0;
}

load_user_cash(id)
{
	user_cash[id] = 0;
	
	new sAuthid[64], timestamp, sValue[20], sSaveThrough[5];
	get_pcvar_string(g_iCvar_identity[CVAR_SAVE_CASH_THROUGH], sSaveThrough, charsmax(sSaveThrough));
	
	switch( sSaveThrough[0] )
	{
		case 's', 'a', 'S', 'A': get_user_authid(id, sAuthid, charsmax(sAuthid));
		case 'N', 'n':
		{
			get_user_name(id, g_player_szName[id-1], charsmax(g_player_szName[]));
			copy(sAuthid, charsmax(sAuthid), g_player_szName[id-1])
		}
		case 'I', 'i': get_user_ip(id, sAuthid, charsmax(sAuthid));
	}
	
	if(MYSQL_ENABLED)
	{
		if( sSaveThrough[0] == 'N' || sSaveThrough[0] == 'n' )
		{
			SQL_Escape_String(sAuthid, charsmax(sAuthid));
		}

		static szQuery[256], aData[3]; aData[0] = id; aData[2] = '0';
		formatex(szQuery, charsmax(szQuery), "SELECT * FROM `%s%s` WHERE authid='%s';", TABLES_PREFIX, TABLE_CASH, sAuthid);
		SQL_ThreadQuery(JB_DB_TUPLE_HANDLER, "mysql_cash_handler_table", szQuery, aData, sizeof aData);
		return;
	}
	
	if(nvault_lookup(g_nvault_cash, sAuthid, sValue, charsmax(sValue), timestamp))
	{
		user_cash[id] = str_to_num(sValue);
	}

	switch( sSaveThrough[0] )
	{
		case 's', 'a', 'S', 'A':
		{
			get_user_ip(id, sAuthid, charsmax(sAuthid));
			if(nvault_lookup(g_nvault_cash, sAuthid, sValue, charsmax(sValue), timestamp))
			{
				user_cash[id] += str_to_num(sValue);
				nvault_remove(g_nvault_cash, sAuthid);
			}

			get_user_name(id, sAuthid, charsmax(sAuthid));
			if(nvault_lookup(g_nvault_cash, sAuthid, sValue, charsmax(sValue), timestamp))
			{
				user_cash[id] += str_to_num(sValue);
				nvault_remove(g_nvault_cash, sAuthid);
			}
		}
		case 'N', 'n':
		{
			get_user_ip(id, sAuthid, charsmax(sAuthid));
			if(nvault_lookup(g_nvault_cash, sAuthid, sValue, charsmax(sValue), timestamp))
			{
				user_cash[id] += str_to_num(sValue);
				nvault_remove(g_nvault_cash, sAuthid);
			}

			get_user_authid(id, sAuthid, charsmax(sAuthid));
			if(nvault_lookup(g_nvault_cash, sAuthid, sValue, charsmax(sValue), timestamp))
			{
				user_cash[id] += str_to_num(sValue);
				nvault_remove(g_nvault_cash, sAuthid);
			}
		}
		case 'I', 'i': 
		{
			get_user_authid(id, sAuthid, charsmax(sAuthid));
			if(nvault_lookup(g_nvault_cash, sAuthid, sValue, charsmax(sValue), timestamp))
			{
				user_cash[id] += str_to_num(sValue);
				nvault_remove(g_nvault_cash, sAuthid);
			}

			get_user_name(id, sAuthid, charsmax(sAuthid));
			if(nvault_lookup(g_nvault_cash, sAuthid, sValue, charsmax(sValue), timestamp))
			{
				user_cash[id] += str_to_num(sValue);
				nvault_remove(g_nvault_cash, sAuthid);
			}
		}
	}
}

find_player_account(szTarget[32], &funds, const viewer)
{
	SQL_Escape_String(szTarget, charsmax(szTarget));

	if(MYSQL_ENABLED)
	{
		static szQuery[256], aData[3]; aData[0] = get_user_userid(viewer); aData[2] = '3';
		formatex(szQuery, charsmax(szQuery), "SELECT * FROM `%s%s` WHERE authid='%s';", TABLES_PREFIX, TABLE_CASH, szTarget);
		SQL_ThreadQuery(JB_DB_TUPLE_HANDLER, "mysql_cash_handler_table", szQuery, aData, sizeof aData);
		return 2;
	}

	new szString[16], iTimestamp;
	if( nvault_lookup(g_nvault_cash, szTarget, szString, charsmax(szString), iTimestamp) > 0 )
	{
		funds = str_to_num(szString);
		return 1;
	}

	return 0;
}

save_user_cash(id)
{
	if(!is_user_connected(id)) return;
	
	new sAuthid[32], szName[64], sAmount[20];
	get_pcvar_string(g_iCvar_identity[CVAR_SAVE_CASH_THROUGH], sAmount, charsmax(sAmount));
	get_user_name(id, szName, charsmax(szName));
	
	switch( sAmount[0] )
	{
		case 's', 'a', 'S', 'A': get_user_authid(id, sAuthid, charsmax(sAuthid));
		case 'N', 'n': copy(sAuthid, charsmax(sAuthid), g_player_szName[id-1]);
		case 'I', 'i': get_user_ip(id, sAuthid, charsmax(sAuthid));
	}
	
	if(MYSQL_ENABLED)
	{
		static szQuery[256], Trie:iTempTrie, aData[3]; iTempTrie = Trie:aData[0] = Trie:aData[1] = TrieCreate(); aData[2] = '1';
		TrieSetString(iTempTrie, "NAME", szName);
		TrieSetString(iTempTrie, "AUTHID", sAuthid);
		SQL_Escape_String(szName, charsmax(szName));
		
		formatex(szQuery, charsmax(szQuery), "INSERT INTO `%s%s` (`nickname`, `usercash`, `authid`) VALUES ('%s', '0', '%s') ON DUPLICATE KEY UPDATE `nickname`='%s', `usercash`='%d';", TABLES_PREFIX, TABLE_CASH, szName, sAuthid, szName, user_cash[id]);
		SQL_ThreadQuery(JB_DB_TUPLE_HANDLER, "mysql_cash_handler_table", szQuery, aData, sizeof aData);
		return;
	}
	
	num_to_str(user_cash[id], sAmount, charsmax(sAmount));
	nvault_set(g_nvault_cash, sAuthid, sAmount);
}

public mysql_cash_handler_table(failstate, Handle:query, error[], errnum, data[], size, Float:queuetime)
{
	switch( data[2] )
	{
		case '0': // load
		{
			if( failstate == TQUERY_SUCCESS )
			{
				static index, sAuthid[32], szName[64]; index = data[0];
				
				// ignore, user is no longer connected.
				if(!is_user_connecting(index)) return;
				
				get_user_name(index, szName, charsmax(szName));
				get_user_authid(index, sAuthid, charsmax(sAuthid));	
				
				if(SQL_NumResults(query) == 0)
				{
					new Trie:iTempTrie = Trie:data[0] = Trie:data[1] = TrieCreate();
					TrieSetString(iTempTrie, "NAME", szName);
					TrieSetString(iTempTrie, "AUTHID", sAuthid);
					SQL_Escape_String(szName, charsmax(szName));
					
					static szQuery[256]; data[2] = '2';
					formatex(szQuery, charsmax(szQuery), "INSERT INTO `%s%s` (`authid`, `nickname`, `usercash`) VALUES ('%s', '%s', '0');", TABLES_PREFIX, TABLE_CASH, sAuthid, szName);
					SQL_ThreadQuery(JB_DB_TUPLE_HANDLER, "mysql_cash_handler_table", szQuery, data, size);
					return;
				}

				new szRealAuthID[32];
				SQL_ReadResult(query, SQL_FieldNameToNum(query, "authid"), szRealAuthID, charsmax(szRealAuthID));
				
				if(!equal(szRealAuthID, sAuthid)) return;

				user_cash[index] = SQL_ReadResult(query, SQL_FieldNameToNum(query, "usercash"));
				log_amx("JAILBREAK | %s's cash (%d) has been successfully loaded!", szName, user_cash[index]);
				server_print("JAILBREAK | %s's cash (%d) has been successfully loaded!", szName, user_cash[index]);
			}
			else
			{
				log_error(AMX_ERR_GENERAL, "Error Code: %d | Error: ^"%s^"", errnum, error);
				server_print("Error Code: %d | Error: ^"%s^"", errnum, error);
			}
		}
		case '1': // save
		{
			// retrieve the trie pointer.
			new Trie:iTempTrie = Trie:data[0];
			
			if( failstate == TQUERY_SUCCESS )
			{
				new szName[32], sAuthID[32];
				TrieGetString(iTempTrie, "NAME", szName, charsmax(szName));
				TrieGetString(iTempTrie, "AUTHID", sAuthID, charsmax(sAuthID));
				
				log_amx("JAILBREAK | [%s] %s cash has been successfully saved!", sAuthID, szName);
				server_print("JAILBREAK | [%s] %s cash has been successfully saved!", sAuthID, szName);
			}
			else
			{
				log_error(AMX_ERR_GENERAL, "Error Code: %d | Error: ^"%s^"", errnum, error);
				server_print("Error Code: %d | Error: ^"%s^"", errnum, error);
			}
			
			// free the temporary trie
			TrieDestroy(iTempTrie);
		}
		case '2':
		{
			// retrieve the trie pointer.
			new Trie:iTempTrie = Trie:data[0];
			
			if( failstate == TQUERY_SUCCESS )
			{
				new szName[32];
				TrieGetString(iTempTrie, "NAME", szName, charsmax(szName));
				log_amx("JAILBREAK | %s cash is a new entry!", szName);
				server_print("JAILBREAK | %s cash is a new entry!", szName);
			}
			else
			{
				log_error(AMX_ERR_GENERAL, "Error Code: %d | Error: ^"%s^"", errnum, error);
				server_print("Error Code: %d | Error: ^"%s^"", errnum, error);
			}
			
			// free the temporary trie
			TrieDestroy(iTempTrie);
		}
		case '3':
		{
			if( failstate == TQUERY_SUCCESS )
			{
				new userid = data[0], id;

				if(userid > 0)
				{
					if(!(id = find_player("k", userid)))
					{
						return;
					}
				}

				if(SQL_NumResults(query) == 0)
				{
					if(!id)
					{
						server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return;
					}

					cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
				}

				new szName[32], szTarget[32], iValue = SQL_ReadResult(query, SQL_FieldNameToNum(query, "usercash"));
				get_user_name(id, szName, charsmax(szName));
				SQL_ReadResult(query, SQL_FieldNameToNum(query, "nickname"), szTarget, charsmax(szTarget));

				if( id )
				{
					cprint_chat(id, 'n', "%L", id, "CHAT_CHECK_PLAYER_CASH", szTarget, iValue);
					logevent_message(0, "'%s' checked player '%s' cash '%d'", szName, szTarget, iValue);
					return;
				}

				server_print("%L", LANG_SERVER, "COMMAND_CHECK_PLAYER_CASH", szTarget, iValue);
				return;
			}
			else
			{
				log_error(AMX_ERR_GENERAL, "Error Code: %d | Error: ^"%s^"", errnum, error);
				server_print("Error Code: %d | Error: ^"%s^"", errnum, error);
			}
		}
	}
}


SQL_Escape_String(dest[], len)
{
	replace_all(dest, len, "\\"   ,   "\\\\" );
	replace_all(dest, len, "\0"   ,   "\\0"  );
	replace_all(dest, len, "\n"   ,   "\\n"  );
	replace_all(dest, len, "\r"   ,   "\\r"  );
	replace_all(dest, len, "\x1a" ,   "\Z"   );
	replace_all(dest, len, "'"    ,    "\^'" );
	replace_all(dest, len, "^""   ,   "\^""  );
}

remove_map_cells_button()
{
	CELLS_BUTTON = -1;

	new szMapname[32];
	get_mapname(szMapname, charsmax(szMapname));
	nvault_remove(g_nvault_cells_button, szMapname);
}

save_map_cells_button(target_button)
{
	CELLS_BUTTON = target_button;

	UpdateCellsButton();
	
	new szMapname[32], szStr[16];
	get_mapname(szMapname, charsmax(szMapname));
	
	num_to_str(target_button, szStr, charsmax(szStr));
	nvault_set(g_nvault_cells_button, szMapname, szStr);
}

UpdateCellsButton()
{
	new szTarget[32], szClass[32], iTarget;
	pev(CELLS_BUTTON, pev_target, szTarget, charsmax(szTarget));

	while((iTarget = find_ent_by_tname(iTarget, szTarget)) > 0)
	{
		pev(iTarget, pev_classname, szClass, charsmax(szClass));
		pev(iTarget, pev_target, szTarget, charsmax(szTarget));

		if(equal(szClass, "func_door") || equal(szClass, "func_door_rotating"))
		{
			pev(iTarget, pev_targetname, szTarget, charsmax(szTarget));
			set_pev(CELLS_BUTTON, pev_target, szTarget);
			break;
		}
	}
}

public clcmd_join(id)
{
	if(pev_valid(id) != ENTITY_PDATA_SAFE)
	{
		return PLUGIN_HANDLED;
	}

	const m_bTeamChanged = 501;
	set_pdata_bool(id, m_bTeamChanged, false);
	
	switch( fm_get_user_team(id) )
	{
		case TEAM_GUARDS:
		{
			if(g_iClass[id][TEAM_GUARDS] == -1)
			{
				class_menu(id);
				return PLUGIN_HANDLED;
			}
			
			Show_jailbreakmenu(id);
		}
		case TEAM_PRISONERS:
		{
			if(g_iClass[id][TEAM_PRISONERS] == -1)
			{
				class_menu(id);
				return PLUGIN_HANDLED;
			}
			
			Show_jailbreakmenu(id);
		}
		default:
		{
			join_menu(id);
		}
	}
	return PLUGIN_HANDLED;
}

get_ratio_left(Float:fRatio=1.0, team=TEAM_ANY, flag=FLAG_ALL)
{
	static p[32], num, connected_players;
	get_players(p, connected_players);
	
	switch( team )
	{
		case TEAM_PRISONERS: num = get_prisonersnum(flag);
		case TEAM_GUARDS: num = get_guardsnum(flag);
		case TEAM_SPECTATOR:
		{
			switch( flag )
			{
				case FLAG_ALL: get_players(p, num, "he", "SPECTATOR");
				case FLAG_ALIVE_ONLY: get_players(p, num, "ahe", "SPECTATOR");
				case FLAG_DEAD_ONLY: get_players(p, num, "bhe", "SPECTATOR");
			}
		}
	}
	
	return clamp((floatround((connected_players * fRatio) - num, floatround_ceil)), 0, g_iMaxplayers);
}

public join_menu(id)
{
	if(is_user_bot(id) || is_user_hltv(id) || !is_user_connected(id)) return PLUGIN_CONTINUE;
	
	new sText[128];
	formatex(sText, charsmax(sText), "%L", id, "TEAM_MENU_TITLE");
	new iMenu = menu_create(sText, "join_menu_handle", true);
	
	new gratio = get_ratio_left(get_pcvar_float(g_iCvar_identity[CVAR_GRATIO])/100.0, TEAM_GUARDS, FLAG_ALL);
	new pratio = get_ratio_left(get_pcvar_float(g_iCvar_identity[CVAR_PRATIO])/100.0, TEAM_PRISONERS, FLAG_ALL);
	
	if(is_user_admin(id) && get_pcvar_num(g_iCvar_identity[CVAR_ADMIN_JOIN]))
	{
		gratio++
		pratio++
	}
	
	switch( get_user_team(id) )
	{
		case TEAM_GUARDS: gratio = 0;
		case TEAM_PRISONERS: pratio = 0;
	}
	
	new iReturn;
	ExecuteForward(fwd_teamhandling, iReturn, id);
	
	switch( iReturn )
	{
		case JB_BLOCK_JOIN_BOTH: { pratio = 0; gratio = 0; }
		case JB_BLOCK_JOIN_GUARDS: gratio = 0;
		case JB_BLOCK_JOIN_PRISONERS: pratio = 0;
	}
	
	pratio ? formatex(sText, charsmax(sText), "%L", id, "TEAM_MENU_PRISONERS"):formatex(sText, charsmax(sText), "%L", id, "TEAM_MENU_PRISONERS_LOCKED");
	menu_additem(iMenu, sText, "IDENTIFIER_JOINMENU", pratio > 0 ? 0:ADMIN_NOACCESS);
	
	gratio ? formatex(sText, charsmax(sText), "%L^n^n", id, "TEAM_MENU_GUARDS"):formatex(sText, charsmax(sText), "%L^n^n", id, "TEAM_MENU_GUARDS_LOCKED");
	menu_additem(iMenu, sText, "IDENTIFIER_JOINMENU", gratio > 0 ? 0:ADMIN_NOACCESS);
	
	formatex(sText, charsmax(sText), "%L", id, "TEAM_MENU_SPEC");
	menu_additem(iMenu, sText, "IDENTIFIER_JOINMENU");
	
	menu_display(id, iMenu);
	return PLUGIN_HANDLED;
}

public join_menu_handle(id, menu, item)
{
	if(item < 0)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}

	new sName[64], pAccess;
	new sData[20], iCallback;
	menu_item_getinfo(menu, item, pAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback);

	if(contain(sName, "\d") != -1)
	{
		menu_destroy(menu);

		join_menu(id);
		return PLUGIN_HANDLED;
	}

	set_user_team(id, item + 1);

	// inform players who has the chooseteam menu opened for the update.
	new players[32], pnum;
	get_players(players, pnum, "ch");

	for(new i, player, iPage, iOldMenu, iNewMenu; i < pnum; i++)
	{
		player = players[i]; iNewMenu = -1; iOldMenu = 0;

		if(player != id && player_menu_info(player, iOldMenu, iNewMenu, iPage) && iNewMenu != -1)
		{
			if(menu_items(iNewMenu) != 3)
			{
				continue;
			}

			menu_item_getinfo(iNewMenu, item, pAccess, sData, charsmax(sData), "", 0, iCallback);
			if(equal(sData, "IDENTIFIER_JOINMENU"))
			{
				join_menu(player);
			}
		}
	}
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}

public class_menu(id)
{
	if(is_user_bot(id) || is_user_hltv(id) || !is_user_connected(id)) return PLUGIN_CONTINUE;
	
	new iTeam = fm_get_user_team(id);
	
	if( !(TEAM_PRISONERS <= iTeam <= TEAM_GUARDS) )
	{
		return PLUGIN_HANDLED;
	}
	
	new sText[64], szAuthID[MAX_AUTHID_LENGTH];
	get_user_authid(id, szAuthID, charsmax(szAuthID));
	formatex(sText, charsmax(sText), "%L", id, "CLASS_MENU_TITLE");
	new iMenu = menu_create(sText, "class_menu_handle", true);
	
	new sInfo[2], xlen = strlen(SZTEAMS[iTeam]), iClassesCount = 0;
	
	const NO_ACCESS = ADMIN_NOACCESS;
	
	for(new i = 0, paccess, xArray[CLASSES_DATA]; i < g_iClasses; i++)
	{
		ArrayGetArray(g_classes_array, i, xArray)
		
		if(equali(SZTEAMS[iTeam], xArray[CLASS_TEAM], xlen) || equali(SZTEAMS[TEAM_ANY], xArray[CLASS_TEAM], xlen))
		{
			paccess = (((get_user_flags(id) & xArray[CLASS_FLAGS]) == xArray[CLASS_FLAGS]) ||
						xArray[CLASS_FLAGS] == ADMIN_ALL ||
						equal(szAuthID, xArray[CLASS_AUTHID])) ? 0 : NO_ACCESS;
			sInfo[0] = i;
			menu_additem(iMenu, xArray[CLASS_NAME], sInfo, paccess);
			iClassesCount++;
		}
	}
	
	if(!iClassesCount)
	{
		menu_destroy(iMenu);
		return PLUGIN_CONTINUE;
	}

	menu_display(id, iMenu);
	return PLUGIN_HANDLED;
}

public class_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sName[32], pAccess;
	new sData[2], iCallback;
	menu_item_getinfo(menu, item, pAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback);
	menu_destroy(menu);
	
	new xClassid = sData[0];
	
	if(jb_is_user_class_valid(id, xClassid) <= 0)
	{
		class_menu(id);
		return PLUGIN_HANDLED;
	}
	
	if(check_flag(IsUserAlive,id))
	{
		g_iNextClass[id] = xClassid;
		cprint_chat(id, _, "%L", id, "CLASS_RELOADED");
		return PLUGIN_HANDLED;
	}
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, xClassid, xArray);
	g_iNextClass[id] = -1;
	join_class(id, xClassid);
	
	// set user class model;
	jb_set_user_class_model(id);
	return PLUGIN_HANDLED;
}

set_user_team(id, team)
{
	if(is_user_alive(id)) user_silentkill(id);

	// set user team...
	fm_set_user_team(id, team)

	switch( team )
	{
		case TEAM_GUARDS: engclient_cmd(id, "jointeam", "2");
		case TEAM_PRISONERS: engclient_cmd(id, "jointeam", "1");
		case TEAM_SPECTATOR: engclient_cmd(id, "jointeam", "6");
		case TEAM_ANY:
		{
			new sString[2];
			team = random_num(TEAM_PRISONERS, TEAM_GUARDS);
			num_to_str(team, sString, charsmax(sString));
			engclient_cmd(id, "jointeam", sString);
		}
	}
	
	static const TeamInfo[TEAM_MAX][] = 
	{ 
		"UNASSIGNED",
		"TERRORIST",
		"CT",
		"SPECTATOR" 
	};

	emessage_begin(MSG_ALL, g_msgTeamInfo, {0,0,0}, 0);
	ewrite_byte(id); 
	ewrite_string(TeamInfo[ clamp(team,0,charsmax(TeamInfo)) ]);
	emessage_end();
}

strip_weapons(id)
{
	strip_user_weapons(id);
	ham_give_weapon(id, "weapon_knife");
}

// takes a weapon from a player efficiently
ham_strip_weapon(id, const weapon[])
{
	if(!equal(weapon,"weapon_",7)) return 0;
	
	new wId = get_weaponid(weapon);
	if(!wId) return 0;
	
	new wEnt = find_ent_by_owner(-1, weapon, id);
	if(!wEnt) return 0;	
	
	if(get_user_weapon(id) == wId) ExecuteHamB(Ham_Weapon_RetireWeapon,wEnt);
	
	if(!ExecuteHamB(Ham_RemovePlayerItem,id,wEnt)) return 0;
	
	ExecuteHamB(Ham_Item_Kill,wEnt);
	//set_pev(wEnt, pev_flags, FL_KILLME);
	set_pev(id, pev_weapons, (pev(id,pev_weapons) & ~(1<<wId)));
	
	// this block should be used for Counter-Strike:
	if(wId == CSW_C4)
	{
		cs_set_user_plant(id, 0, 0);
		cs_set_user_bpammo(id, CSW_C4, 0);
	}
	else if((1<<wId) & ((1<<CSW_SMOKEGRENADE)|(1<<CSW_FLASHBANG)|(1<<CSW_HEGRENADE)))
	{
		cs_set_user_bpammo(id, wId, 0);
	}
	
	return 1;
}

// gives a player a weapon efficiently
ham_give_weapon(id, const weapon[])
{
	if(!equal(weapon, "weapon_",7)) return 0;
	
	new wEnt = engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString, weapon));
	if(!pev_valid(wEnt)) return 0;
	
	set_pev(wEnt,pev_spawnflags, SF_NORESPAWN);
	dllfunc(DLLFunc_Spawn, wEnt);
	
	if(!ExecuteHamB(Ham_AddPlayerItem, id, wEnt))
	{
		if(pev_valid(wEnt)) set_pev(wEnt,pev_flags, pev(wEnt,pev_flags)|FL_KILLME);
		return 0;
	}
	
	ExecuteHamB(Ham_Item_AttachToPlayer, wEnt, id);
	return 1;
}

public fw_player_spawning(id)
{
	if(!is_user_connected(id)) return;
	
	new iTeam = fm_get_user_team(id);
	if( !(TEAM_PRISONERS <= iTeam <= TEAM_GUARDS) ) return;
	new classid = g_iClass[id][iTeam],
	nextclassid = g_iNextClass[id];
	
	// got an invalid classid ?
	if(jb_is_user_class_valid(id,classid) <= 0) classid = -1;
	if(jb_is_user_class_valid(id,nextclassid) <= 0) nextclassid = -1;
	
	if(classid == -1 && nextclassid == -1)
	{
		nextclassid = find_available_class(id);
	}
	
	if(nextclassid > -1)
	{
		new xArray[CLASSES_DATA];
		join_class(id, nextclassid);
		ArrayGetArray(g_classes_array, nextclassid, xArray);
		
		g_iNextClass[id] = -1;
		
		// set user class model;
		jb_set_user_class_model(id);
	}
}

find_available_class(id)
{
	new iTeam = fm_get_user_team(id);
	if( !(TEAM_PRISONERS <= iTeam <= TEAM_GUARDS) ) return -1;

	for(new i, xArray[CLASSES_DATA], teamlen = strlen(SZTEAMS[iTeam]); i < g_iClasses; i++)
	{
		ArrayGetArray(g_classes_array, i, xArray);
		
		if(equali(SZTEAMS[iTeam], xArray[CLASS_TEAM], teamlen))
		{
			if((get_user_flags(id) & xArray[CLASS_FLAGS]) || !xArray[CLASS_FLAGS])
			{
				return i;
			}
		}
	}
	
	return -1;
}

join_class(id, classid)
{
	new iTeam = fm_get_user_team(id);

	if( !(TEAM_PRISONERS <= iTeam <= TEAM_GUARDS) ) return;
	
	for(new i; i < TEAM_MAX; i++)
	{
		g_iClass[id][i] = -1;
	}
	
	g_iClass[id][iTeam] = classid;
	engclient_cmd(id, "joinclass", "5");

	CheckWinConditions();
}

public fw_player_spawned(id)
{
	if(!is_user_alive(id))
		return;
	
	set_flag(IsUserAlive,id);
	remove_flag(g_user_has_godmode,id);
	
	if(g_lr_inprogress != DUEL_NONE && get_prisonersnum(FLAG_ALIVE_ONLY) != 1)
	{
		_end_theduel();
	}
	
	// Reset user rendernig
	set_user_rendering(id);
	
	// strip user weapons
	strip_weapons(id);
	
	new iTeam = fm_get_user_team(id);

	if( !(TEAM_PRISONERS <= iTeam <= TEAM_GUARDS) ) return;

	new iClass = g_iClass[id][iTeam];
	
	// if its not a valid class...
	if(jb_is_user_class_valid(id,iClass) <= 0)
		return;
	
	// set user class model
	jb_set_user_class_model(id);
	
	if(Check_weapons_available(id) && !is_user_bot(id))
	{
		new xArray[CLASSES_DATA];
		ArrayGetArray(g_classes_array, iClass, xArray);
		
		switch( iTeam )
		{
			case TEAM_GUARDS:
			{
				switch( get_pcvar_num(g_iCvar_identity[CVAR_GGIVE_WPNS]) )
				{
					case 1: Show_weaponsmenu(id, xArray[CLASS_PRIMWEAPONS], "WEAPON_MENU_CHOOSE_PRIM", "primary_wpnshandle");
					case 2:
					{
						give_weapons(id, xArray[CLASS_PRIMWEAPONS], ',');
						give_weapons(id, xArray[CLASS_SECWEAPONS], ',');
					}
				}
			}
			case TEAM_PRISONERS:
			{
				switch( get_pcvar_num(g_iCvar_identity[CVAR_PGIVE_WPNS]) )
				{
					case 1: Show_weaponsmenu(id, xArray[CLASS_PRIMWEAPONS], "WEAPON_MENU_CHOOSE_PRIM", "primary_wpnshandle");
					case 2:
					{
						give_weapons(id, xArray[CLASS_PRIMWEAPONS], ',');
						give_weapons(id, xArray[CLASS_SECWEAPONS], ',');
					}
				}
			}
		}
	}
	
	if(g_day_inprogress == JB_DAY_VOTEDAY) // if its a voteday event...
	{
		set_user_godmode(id, 1); // set user godmode
	}
}

public round_start()
{
	server_print("* Jailbreak Round preparing!");

	if(bHAS_ROUND_STARTED)
	{
		return;
	}

	logevent_message(.szMessage="Round has started!");
	logevent_message(0, "Today is '%L'", LANG_SERVER, sDays[g_iTODAY]);

	new gfwReturn;
	ExecuteForward(fw_round_start, gfwReturn);
	
	if(gfwReturn >= JB_HANDLED) return;

	// pass one day forwad when round end
	switch(g_iTODAY)
	{
		case DAY_SAT: g_iTODAY = DAY_SUN;
		case DAY_SUN: g_iTODAY = DAY_MON;
		case DAY_MON: g_iTODAY = DAY_TUE;
		case DAY_TUE: g_iTODAY = DAY_WED;
		case DAY_WED: g_iTODAY = DAY_THU;
		case DAY_THU: g_iTODAY = DAY_FRI;
		case DAY_FRI: g_iTODAY = DAY_SAT;
	}
	
	// Save players cash every new round.
	new szFlags[4];
	get_pcvar_string(g_iCvar_identity[CVAR_SAVE_CASH_EVENT], szFlags, charsmax(szFlags));
	if(read_flags("b") & read_flags(szFlags))
	{
		new players[32], players_num;
		get_players(players, players_num, "ch");
		for(new i; i < players_num; i++)
		{
			save_user_cash(players[i]);
		}
	}
	
	Check_Shop_Items_Limitation();
	
	set_task(2.0, "Check_today_event");

	bHAS_ROUND_STARTED = true;
	bHAS_ROUND_ENDED = false;
	bHAS_ROUND_ENDING = false;
}

public round_started()
{
	if(!bHAS_ROUND_STARTED)
	{
		round_start();
		round_started();
		return;
	}

	server_print("* Jailbreak Round started!");
	ExecuteForward(fw_round_started, g_fw_return);
}

Check_Shop_Items_Limitation()
{
	new id, pnum, players[32];
	get_players(players, pnum, "ch");
	
	for(new x, i, z, xArray3[DAY_SHOP_ITEMS], loop = ArraySize(g_iDayShopItems); x < loop; x++)
	{
		ArrayGetArray(g_iDayShopItems, x, xArray3);
		
		if((z=xArray3[ITEM_SHOP_LIMITS][LIMIT_TIMES]) != -1)
		{
			switch( xArray3[ITEM_SHOP_LIMITS][LIMIT_FOR_EVERYONE] )
			{
				case 1: {
					if(xArray3[ITEM_SHOP_LIMITS][LIMIT_USER][0] == z) continue;
					
					if(xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER][0] <= 0)
					{
						xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER][0] = xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS];
						arrayset(xArray3[ITEM_SHOP_LIMITS][LIMIT_USER], z, 33);
					}
					else
					{
						xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER][0]--;
					}
				}
				case 0:
				{
					for( i = 0; i < pnum; i++)
					{
						id = players[i];
						if(xArray3[ITEM_SHOP_LIMITS][LIMIT_USER][id] == z) continue;
						
						if(xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER][id] <= 0)
						{
							xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER][id] = xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS];
							xArray3[ITEM_SHOP_LIMITS][LIMIT_USER][id] = z;
						}
						else
						{
							xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER][id]--;
						}
					}
				}
			}
			
			ArraySetArray(g_iDayShopItems, x, xArray3);
		}
	}
	
	for(new i, z, x, xArray2[ITEM_LIMITATION_DATA], sItemname[MAX_SHOPITEM_NAME_LENGTH]; i < g_shop_items; i++)
	{
		ArrayGetString(g_shop_items_name, i, sItemname, charsmax(sItemname));
		TrieGetArray(g_trie_shop_item_limit, sItemname, xArray2, sizeof xArray2);
		
		if((z=xArray2[LIMIT_TIMES]) > 0)
		{
			if( xArray2[LIMIT_FOR_EVERYONE] )
			{
				if(xArray2[LIMIT_USER][0] == z)
				{
					continue;
				}

				if(xArray2[LIMIT_ROUNDS_COUNTER][0] <= 0)
				{
					xArray2[LIMIT_ROUNDS_COUNTER][0] = xArray2[LIMIT_ROUNDS];
					arrayset(xArray2[LIMIT_USER], z, sizeof xArray2[LIMIT_USER]);
				}
				else
				{
					xArray2[LIMIT_ROUNDS_COUNTER][0]--;
				}
			}
			else
			{
				for( x = 0; x < pnum; x++)
				{
					id = players[x];

					if(xArray2[LIMIT_USER][id] == z)
					{
						continue;
					}

					if(xArray2[LIMIT_ROUNDS_COUNTER][id] <= 0)
					{
						xArray2[LIMIT_ROUNDS_COUNTER][id] = xArray2[LIMIT_ROUNDS];
						xArray2[LIMIT_USER][id] = z;
					}
					else
					{
						xArray2[LIMIT_ROUNDS_COUNTER][id]--;
					}
				}
			}
			
			TrieSetArray(g_trie_shop_item_limit, sItemname, xArray2, sizeof xArray2);
		}
	}
}

public Check_today_event()
{
	if(Check_lr_available())
	{
		if(g_lr_inprogress == JB_LR_ACTIVATED)
		{
			return;
		}

		new winner = get_last_prisoner_alive(.bInclude_bots=true);
		if(winner > 0)
		{
			if(!is_user_bot(winner)) Show_lastrequestmenu(winner);
			g_iLRPrisoner = winner;

			g_lr_inprogress = JB_LR_ACTIVATED;
			logevent_message(.szMessage="Last request is activated!");
		}
	}
	else if(Check_today_isfunday())
	{
		start_theday(VOTE_DAY);
		logevent_message(.szMessage="Today is a special day!");
	}
}

bool:Check_today_isfunday()
{
	if(!Check_day_available(.msg=false))
	{
		return false;
	}

	if( get_pcvar_num(g_iCvar_identity[CVAR_VDAY_NOGUARDS]) && !get_guardsnum() )
	{
		return true;
	}
	
	new sString[64], sOutput[MAX_DAYS][10];
	get_pcvar_string(g_iCvar_identity[CVAR_FUNDAYS], sString, charsmax(sString));
	str_explode(sString, ',', sOutput, MAX_DAYS, charsmax(sOutput[]));
	
	for(new j = 0; j < MAX_DAYS; j++)
	{
		formatex(sString, charsmax(sString), "%L", LANG_SERVER, sDays[g_iTODAY]);
		if(equali(sString, sOutput[j]))
		{
			return true;
		}
	}
	return false;
}

// native jb_end_theduel()
public _end_theduel()
{
	switch( g_lr_inprogress )
	{
		case JB_LR_DEACTIVATED:
		{
			g_iLRGuard = g_iLRPrisoner = 0;
			return -1;
		}
		case JB_LR_IN_COUNTDOWN:
		{
			remove_task(g_iLRPrisoner+TASK_BEACON);
			remove_task(g_iLRGuard+TASK_BEACON);
			remove_task(TASK_LR_TIMER);

			remove_attachment_fromplayer(g_iLRPrisoner);
			remove_attachment_fromplayer(g_iLRGuard);

			g_user_wpns_blocked[g_iLRPrisoner] = 0;
			g_user_wpns_blocked[g_iLRGuard] = 0;

			if(!Check_lr_available())
			{
				g_iLRPrisoner = 0;
				g_lr_inprogress = JB_LR_DEACTIVATED;
				logevent_message(.szMessage="Last request is deactivated!");
			}
			else
			{
				g_iLRGuard = LR_TIMER_LENGTH = 0;
				g_lr_inprogress = JB_LR_ACTIVATED;
			}

			return 1;
		}
		case JB_LR_ACTIVATED:
		{
			if(!Check_lr_available())
			{
				g_iLRPrisoner = 0;
				g_lr_inprogress = JB_LR_DEACTIVATED;
				logevent_message(.szMessage="Last request is deactivated!");
			}
			else
			{
				g_iLRGuard = LR_TIMER_LENGTH = 0;
				g_lr_inprogress = JB_LR_ACTIVATED;
			}

			return 1;
		}
	}
	
	new gfwReturn;
	ExecuteForward(fw_lr_duel_end, gfwReturn, g_iLRPrisoner, g_iLRGuard, g_lr_inprogress)
	
	if(gfwReturn >= JB_HANDLED) return 0;
	
	g_user_wpns_blocked[g_iLRPrisoner] = 0;
	g_user_wpns_blocked[g_iLRGuard] = 0;
	
	if(is_user_connected(g_iLRPrisoner))
	{
		remove_attachment_fromplayer(g_iLRPrisoner);
	}

	if(is_user_connected(g_iLRGuard))
	{
		remove_attachment_fromplayer(g_iLRGuard);
	}
	
	remove_task(g_iLRPrisoner+TASK_BEACON);
	remove_task(g_iLRGuard+TASK_BEACON);
	remove_task(TASK_LR_TIMER);
	
	new szLRDuelName[MAX_LRITEM_NAME_LENGTH], iWinner = g_iLRPrisoner, iLoser = g_iLRGuard;

	ExecuteForward(fw_lr_duel_ended, g_fw_return, g_iLRPrisoner, g_iLRGuard, g_lr_inprogress);
	g_iLRGuard = LR_TIMER_LENGTH = 0;

	if(g_lr_inprogress >= 0)
	{
		ArrayGetString(g_lr_itemname, g_lr_inprogress, szLRDuelName, charsmax(szLRDuelName));
	}

	g_lr_inprogress = JB_LR_ACTIVATED;

	if( ( 1 <= iWinner <= g_iMaxplayers ) &&
			 ( 1 <= iLoser <= g_iMaxplayers )  )
	{
		new bool:bIsWinnerAlive = (is_user_alive(iWinner) == 1) ? true:false,
			bool:bIsLoserAlive = (is_user_alive(iLoser) == 1) ? true:false,
			iTemp = iWinner;

		if(bIsLoserAlive && !bIsWinnerAlive)
		{
			iWinner = iLoser;
			iLoser = iTemp;
		}
		else if(!bIsLoserAlive && !bIsWinnerAlive || bIsLoserAlive && bIsWinnerAlive)
		{
			iTemp = 0;
		}

		if(iTemp != 0)
		{
			logevent_message_action("Last request game '%s' has won against", iWinner, iLoser, szLRDuelName);
		}

		logevent_message(0, "Last request game '%s' has ended!", szLRDuelName);
	}

	if(!Check_lr_available())
	{
		g_iLRPrisoner = 0;
		g_lr_inprogress = JB_LR_DEACTIVATED;
		logevent_message(.szMessage="Last request is deactivated!");
	}

	return 1;
}

get_last_prisoner_alive(bool:bInclude_bots=false)
{
	new players[32], pnum;
	
	if(bInclude_bots)
	{
		get_players(players, pnum, "ahe", "TERRORIST");
		return (pnum == 1) ? players[0]:0;
	}
	
	get_players(players, pnum, "ache", "TERRORIST");
	return (pnum == 1) ? players[0]:0;
}

// before the round actually ends.
public OnRoundEnd( const RoundEndType:type )
{
	if( bHAS_ROUND_ENDING )
	{
		return PLUGIN_HANDLED;
	}

	new returnNum = PLUGIN_CONTINUE;

	ExecuteForward(fw_round_end, returnNum);
	
	if(returnNum >= JB_HANDLED)
	{
		return PLUGIN_HANDLED;
	}
	
	if(g_day_inprogress > DAY_NONE)
	{
		switch ( ArrayGetCell(g_days_dayendtype, g_day_inprogress) )
		{
			case DAY_ONE_SURVIVOR: returnNum = PLUGIN_HANDLED;
			case DAY_GUARDS_VS_PRISONERS: returnNum = PLUGIN_CONTINUE;
			case DAY_TIMER: returnNum = FUNDAY_TIMER_LENGTH > 0.0 ? PLUGIN_HANDLED : PLUGIN_CONTINUE;
		}
	}
	
	if(returnNum == PLUGIN_CONTINUE)
	{
		logevent_message(.szMessage="Round is ending...");
		bHAS_ROUND_ENDING = true;
	}

	return returnNum;
}

public round_end()
{
	server_print("* Jailbreak Round ended!");

	if(bHAS_ROUND_ENDED)
	{
		return;
	}

	bHAS_ROUND_ENDED = true;
	
	remove_task(TASK_END_ROUND);
	remove_task(TASK_VOTEDAY_TIMER);
	remove_task(TASK_LR_TIMER);
	
	ExecuteForward(fw_round_ended, g_fw_return);
	
	logevent_message(.szMessage="Round has ended!");

	remove_task();
	remove_task(TASK_LR_TIMER);

	if(g_lr_inprogress != DUEL_NONE)
	{
		_end_theduel();
	}

	if(g_day_inprogress != DAY_NONE)
	{
		_end_theday();
	}

	bHAS_ROUND_ENDING = false;
	bHAS_ROUND_STARTED = false;
}

get_guardsnum(flags=FLAG_ALL)
{
	new gnum, g[32];
	
	switch( flags )
	{
		case FLAG_ALL: get_players(g, gnum, "he", "CT"); // alive & dead guards
		case FLAG_ALIVE_ONLY: get_players(g, gnum, "ahe", "CT"); // alive guards
		case FLAG_DEAD_ONLY: get_players(g, gnum, "bhe", "CT"); // dead guards
		default: gnum = -1
	}
	
	return gnum;
}

get_prisonersnum(flags=FLAG_ALL)
{
	new pnum, p[32];
	
	switch( flags )
	{
		case FLAG_ALL: get_players(p, pnum, "he", "TERRORIST"); // alive & dead prisoners
		case FLAG_ALIVE_ONLY: get_players(p, pnum, "ahe", "TERRORIST"); // alive prisoners
		case FLAG_DEAD_ONLY: get_players(p, pnum, "bhe", "TERRORIST"); // dead prisoners
		default: pnum = -1;
	}
	
	return pnum;
}

Show_jailbreakmenu(id)
{
	new sBuf[64], paccess;
	
	formatex(sBuf, charsmax(sBuf), "%L", id, "MAIN_MENU_TITLE");
	new iMenu = menu_create(sBuf, "jailbreakmenu_handle", true);
	
	if(fm_get_user_team(id) == TEAM_PRISONERS)
	{
		paccess = Check_lr_available(id, false) ? 0:ADMIN_NOACCESS;
		formatex(sBuf, charsmax(sBuf), "%L", id, !paccess ? "MAIN_MENU_ITEM_LR":"MAIN_MENU_ITEM_LR_L");
		menu_additem(iMenu, sBuf, "LREQUEST", paccess);
	}
	
	paccess = Check_shop_available(id, false) ? 0:ADMIN_NOACCESS;
	formatex(sBuf, charsmax(sBuf), "%L", id, !paccess ? "MAIN_MENU_ITEM_SHOP":"MAIN_MENU_ITEM_SHOP_L");
	menu_additem(iMenu, sBuf, "SHOP", paccess);
	
	paccess = Check_day_available(id, false) ? 0:ADMIN_NOACCESS;
	formatex(sBuf, charsmax(sBuf), "%L", id, !paccess ? "MAIN_MENU_ITEM_FUNDAYS":"MAIN_MENU_ITEM_FUNDAYS_L");
	menu_additem(iMenu, sBuf, "DAYS", paccess);
	
	new sItemname[32], sItemdata[32], iItemaccess, iItemteam;
	
	for(new i = 0, gfwReturn; i < g_jbmm_items; i++)
	{
		iItemteam = ArrayGetCell(g_jbmm_itemteam, i);
		
		if((iItemteam != fm_get_user_team(id)) &&  iItemteam != TEAM_ANY)
		{
			continue;
		}
		
		ArrayGetString(g_jbmm_itemname, i, sItemname, charsmax(sItemname));
		iItemaccess = ArrayGetCell(g_jbmm_itemaccess, i);
		
		ExecuteForward(fw_jbmm_itemadded, gfwReturn, id, i);
		
		switch( gfwReturn )
		{
			case JB_MENU_ITEM_DONT_SHOW: continue;
			case JB_MENU_ITEM_UNAVAILABLE:
			{
				iItemaccess = ADMIN_NOACCESS;
				formatex(sBuf, charsmax(sBuf), "\d%L", id, sItemname);
			}
			default: formatex(sBuf, charsmax(sBuf), "%L", id, sItemname);
		}
		
		num_to_str(i, sItemdata, charsmax(sItemdata));
		menu_additem(iMenu, sBuf, sItemdata, iItemaccess);
	}
	
	formatex(sBuf, charsmax(sBuf), "%L", id, "MAIN_MENU_CHANGE_TEAM");
	menu_additem(iMenu, sBuf, "JOIN");
	
	paccess = (get_user_flags(id) & ADMIN_LEVEL_A) ? 0:ADMIN_NOACCESS;
	formatex(sBuf, charsmax(sBuf), "%L", id, !paccess ? "MAIN_MENU_ITEM_ADMIN_MENU":"MAIN_MENU_ITEM_ADMIN_MENU_L");
	menu_additem(iMenu, sBuf, "ADMIN_MENU", paccess);
	
	menu_setprop(iMenu, MPROP_NUMBER_COLOR, "\w");
	menu_display(id, iMenu);
}

public jailbreakmenu_handle(const id, const menu, const item)
{
	if(item == MENU_EXIT || item == MENU_TIMEOUT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sData[32], sName[64], iCallback, iAccess;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback);
	
	// destroyin the menu..
	menu_destroy(menu);
	
	if(contain(sName, "\d") != -1)
	{
		Show_jailbreakmenu(id);
		return PLUGIN_HANDLED;
	}
	if(equal(sData, "SHOP"))
	{
		shop_menu(id);
		return PLUGIN_HANDLED;
	}
	if(equal(sData, "DAYS"))
	{
		days_menu(id);
		return PLUGIN_HANDLED;
	}
	if(equal(sData, "JOIN"))
	{
		join_menu(id);
		return PLUGIN_HANDLED;
	}
	if(equal(sData, "LREQUEST"))
	{
		Show_lastrequestmenu(id);
		return PLUGIN_HANDLED;
	}
	if(equal(sData, "ADMIN_MENU"))
	{
		admin_menu(id);
		return PLUGIN_HANDLED;
	}
	
	ExecuteForward(fw_jbmm_item_selected, g_fw_return, id, str_to_num(sData));
	return PLUGIN_HANDLED;
}


// register_jailbreak_mmitem(const name[], access, team)
public _register_jailbreak_mmitem(plugin, argc)
{
	if(argc != 3) return -2;
	
	new item_name[32], item_access, item_team;
	get_string(1, item_name, charsmax(item_name));
	item_access = get_param(2);
	item_team = get_param(3);
	
	if(strlen(item_name) < 3)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item name is too short!", plugin, 1);
		return -1;
	}
	if(!(TEAM_PRISONERS <= item_team <= TEAM_SPECTATOR) && item_team != TEAM_ANY )
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item team is not defined!", plugin, 4);
		return -1;
	}
	if(get_itemid_inarray_bystring(item_name, g_jbmm_itemname) > -1)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item with this name is already registered!", plugin, 1);
		return -1;
	}
	
	ArrayPushString(g_jbmm_itemname, item_name);
	ArrayPushCell(g_jbmm_itemaccess, item_access);
	ArrayPushCell(g_jbmm_itemteam, item_team);
	
	g_jbmm_items ++;
	return g_jbmm_items-1;
}

public clcmd_set_cmd_value(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
		return PLUGIN_HANDLED;
	
	new szValue[12];
	read_argv(1, szValue, charsmax(szValue));
	remove_quotes(szValue);
	
	g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_VALUE] = str_to_num(szValue);
	admin_menu(id, ADMIN_MENU_SET_CHOOSE_VALUE);
	return PLUGIN_HANDLED;
}

admin_menu(id, menuid=ADMIN_MENU_MAIN_MENU)
{
	new p_iMenu, szText[64], szMenuID[32];
	num_to_str(menuid, szMenuID, charsmax(szMenuID));
	
	switch(menuid)
	{
		case ADMIN_MENU_MAIN_MENU:
		{
			formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_MENU_TITLE");
			p_iMenu = menu_create(szText, "admenu_handler", true);
			
			for(new i; i < sizeof szAdminMenuItems; i++)
			{
				formatex(szText, charsmax(szText), "%L", LANG_PLAYER, szAdminMenuItems[i]);
				menu_additem(p_iMenu, szText, szMenuID);
			}
		}
		case ADMIN_MENU_REVIVE:
		{
			formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_REV_MENU_TITLE");
			p_iMenu = menu_create(szText, "admenu_handler", true);
			
			menu_additem(p_iMenu, "Revive Self", szMenuID);

			for(new i; i < sizeof szAdminMenuTargetItems; i++)
			{
				formatex(szText, charsmax(szText), "%L", LANG_PLAYER, szAdminMenuTargetItems[i][0]);
				menu_additem(p_iMenu, szText, szMenuID);
			}
			
			formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_REV_M_REV_SPECIFIED");
			menu_additem(p_iMenu, szText, szMenuID);
		}
		case ADMIN_MENU_SET_CHOOSE_OPTION:
		{
			formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_SET_MENU_TITLE");
			p_iMenu = menu_create(szText, "admenu_handler", true);
			
			for(new i; i < sizeof szSetMenuItems; i++)
			{
				formatex(szText, charsmax(szText), "%L", LANG_PLAYER, szSetMenuItems[i][0]);
				menu_additem(p_iMenu, szText, szMenuID);
			}
		}
		case ADMIN_MENU_SET_CHOOSE_TARGET:
		{
			formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_SET_TARGET_M_TITLE");
			p_iMenu = menu_create(szText, "admenu_handler", true);
			
			menu_additem(p_iMenu, "Set yourself!", szMenuID);

			for(new i; i < sizeof szAdminMenuTargetItems; i++)
			{
				formatex(szText, charsmax(szText), "%L", LANG_PLAYER, szAdminMenuTargetItems[i][0]);
				menu_additem(p_iMenu, szText, szMenuID);
			}
			
			formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_SET_M_T_SPECIFIED");
			menu_additem(p_iMenu, szText, szMenuID);
		}
		case ADMIN_MENU_SET_CHOOSE_VALUE:
		{
				new iOption = g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_ACTION];
				formatex(szText, charsmax(szText), "%L^n%L", LANG_PLAYER, "ADMIN_SET_VALUE_M_TITLE", LANG_PLAYER, szSetMenuItems[iOption][0]);
				p_iMenu = menu_create(szText, "admenu_handler", true);
				
				if(equal(szSetMenuItems[iOption][1], "OnOff"))
				{
					formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ON");
					menu_additem(p_iMenu, szText, szMenuID);
					formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "OFF");
					menu_additem(p_iMenu, szText, szMenuID);
				}
				else if(equal(szSetMenuItems[iOption][1], "writevalue"))
				{
					formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_SET_VALUE_M", g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_VALUE]);
					menu_additem(p_iMenu, szText, szMenuID);
					formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "ADMIN_SET_VALUE_M_SUBMIT");
					menu_additem(p_iMenu, szText, szMenuID);
				}
				else if(equal(szSetMenuItems[iOption][1], "novalue"))
				{
					menu_destroy(p_iMenu);
					return;
				}
		}
	}
	menu_display(id, p_iMenu);
}

public admenu_handler(id, menu, item)
{
	if(item == MENU_EXIT || item == MENU_TIMEOUT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}

	if(item == MENU_BACK || item == MENU_MORE)
	{
		return PLUGIN_HANDLED;
	}
	
	new iAccess, szData[32], szName[32], iCallback;
	menu_item_getinfo(menu, item, iAccess, szData, charsmax(szData), szName, charsmax(szName), iCallback);
	
	menu_destroy(menu);
	
	if(equal(szData, "REVIVE_PLAYER"))
	{
		formatex(szData, charsmax(szData), "#%d", get_user_userid(get_user_index(szName)));
		amxclient_cmd(id, "jb_revive", szData);
		Show_playersmenu(id, "ADMIN_REV_PLAYERS_MENU_TITLE", "admenu_handler", "REVIVE_PLAYER", 0, TEAM_ANY, FLAG_DEAD_ONLY, true);
		return PLUGIN_HANDLED;
	}
	
	if(equal(szData, "SET_PLAYER"))
	{
		g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_TARGET] = get_user_userid(get_user_index(szName));
		admin_menu(id, ADMIN_MENU_SET_CHOOSE_VALUE);
		return PLUGIN_HANDLED;
	}
	
	new iMenuID = str_to_num(szData);
	
	switch( iMenuID )
	{
		case ADMIN_MENU_MAIN_MENU:
		{
			switch( item )
			{
				case 0: amxclient_cmd(id, "jb_cells", "O");
				case 1: amxclient_cmd(id, "jb_cells", "C");
				case 2: admin_menu(id, ADMIN_MENU_REVIVE);
				case 3: admin_menu(id, ADMIN_MENU_SET_CHOOSE_OPTION);
			}
		}
		case ADMIN_MENU_REVIVE:
		{
			if(item == 0)
			{
				formatex(szData, charsmax(szData), "#%d", get_user_userid(id));
				amxclient_cmd(id, "jb_revive", szData);
				admin_menu(id, ADMIN_MENU_REVIVE);
			}
			else if(item == 10) // item 10 is special.
			{
				Show_playersmenu(id, "ADMIN_REV_PLAYERS_MENU_TITLE", "admenu_handler", "REVIVE_PLAYER", 0, TEAM_ANY, FLAG_DEAD_ONLY, true);
			}
			else if(item)
			{
				amxclient_cmd(id, "jb_revive", szAdminMenuTargetItems[item-1][1]);
				admin_menu(id, ADMIN_MENU_REVIVE);
			}
		}
		case ADMIN_MENU_SET_CHOOSE_OPTION:
		{
			if(item == 5) // item 5 is special.
			{
				amxclient_cmd(id, "jb_set", "cells");
				admin_menu(id, ADMIN_MENU_SET_CHOOSE_OPTION);
				return PLUGIN_HANDLED;
			}
		
			g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_ACTION] = item;
			admin_menu(id, ADMIN_MENU_SET_CHOOSE_TARGET);
		}
		case ADMIN_MENU_SET_CHOOSE_TARGET:
		{
			if(item == 0)
			{
				g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_TARGET] = get_user_userid(id);
				admin_menu(id, ADMIN_MENU_SET_CHOOSE_VALUE);
			}
			else if(item == 10) // item 10 is special.
			{
				Show_playersmenu(id, "ADMIN_SET_PLAYERS_MENU_TITLE", "admenu_handler", "SET_PLAYER", 0, TEAM_ANY, FLAG_ALIVE_ONLY, true);
			}
			else if(item)
			{
				g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_TARGET] = -item;
				admin_menu(id, ADMIN_MENU_SET_CHOOSE_VALUE);
			}
		}
		case ADMIN_MENU_SET_CHOOSE_VALUE:
		{
			new iOption = g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_ACTION], szTarget[32], iTarget =  g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_TARGET];
			if(iTarget <= 0)
			{
				copy(szTarget, charsmax(szTarget), szAdminMenuTargetItems[(iTarget * -1)][1])
			}
			else {
					num_to_str(iTarget, szTarget[1], sizeof(szTarget) - 2);
					szTarget[0] = '#';
			}
			
			if(equal(szSetMenuItems[iOption][1], "OnOff"))
			{
				new szArgs[128];
				formatex(szArgs, charsmax(szArgs), "/set %s %s %d", szSetMenuItems[iOption][2], szTarget, (item == 0) ? 1 : 0);
				amxclient_cmd(id, "say", szArgs);
				admin_menu(id);
			}
			else if(equal(szSetMenuItems[iOption][1], "writevalue"))
			{
				switch( item )
				{
					case 0:
					{
						client_cmd(id, "messagemode set_command_value");
						client_print(id, print_center, "%L", id, "ADMIN_INSERT_SET_VALUE_CENTER");
					}
					case 1:
					{
						new szArgs[128];
						formatex(szArgs, charsmax(szArgs), "/set %s %s %d", szSetMenuItems[iOption][2], szTarget, g_iAdminMenu_Option[id][ADMIN_MENU_OPTION_VALUE]);
						amxclient_cmd(id, "say", szArgs);
						admin_menu(id);
					}
				}
			}
		}
	}
	return PLUGIN_HANDLED;
}

Show_lastrequestmenu(id)
{
	if(!Check_lr_available(id, true))
	{
		return;
	}
	
	if(!g_lr_items)
	{
		log_amx("There is no items in the API jailbreak lastrequest menu.");
		return;
	}
	
	new sBuf[128], iItemsCount = 0;
	formatex(sBuf, charsmax(sBuf), "%L", LANG_PLAYER, "LR_MENU_TITLE");
	new iMenu = menu_create(sBuf, "lastrequestmenu_handle", true), sItemname[32], sItemdata[16], iItemaccess;
	
	const NO_ACCESS = ADMIN_NOACCESS;
	
	for(new i, gReturn; i < g_lr_items; i++)
	{
		ArrayGetString(g_lr_itemname, i, sItemname, charsmax(sItemname));
		iItemaccess = ArrayGetCell(g_lr_itemaccess, i);
		
		ExecuteForward(fw_lr_item_select, gReturn, id, i);
		
		switch( gReturn )
		{
			case JB_MENU_ITEM_DONT_SHOW: continue;
			case JB_MENU_ITEM_UNAVAILABLE: iItemaccess = NO_ACCESS;
		}
		
		formatex(sBuf, charsmax(sBuf), "%s%s", (get_user_flags(id) & iItemaccess) ? "\r":"", sItemname);
		num_to_str(i, sItemdata, charsmax(sItemdata));
		menu_additem(iMenu, sBuf, sItemdata, iItemaccess);
		iItemsCount++;
	}
	
	if(!iItemsCount)
	{
		menu_destroy(iMenu);
		return;
	}

	menu_display(id, iMenu);
}

public lastrequestmenu_handle(id, menu, item)
{
	if(item == MENU_EXIT || item == MENU_TIMEOUT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}

	if(item == MENU_MORE || item == MENU_BACK)
	{
		return PLUGIN_HANDLED;
	}
	
	if(!Check_lr_available(id))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sData[16], sName[64], iCallback, iAccess, gFwReturn;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback);
	new itemid = str_to_num(sData);
	
	menu_destroy(menu);
	
	ExecuteForward(fw_lr_item_selected, gFwReturn, id, itemid);
	
	if(gFwReturn != JB_LR_NOT_AVAILABLE && gFwReturn != JB_LR_OTHER_MENU)
	{
		Show_playersmenu(id, "LR_MENU_CHOOSE_TARG_TITLE", "lrmenu_handle2", sData, iAccess, TEAM_GUARDS, FLAG_ALIVE_ONLY);
	}
	
	return PLUGIN_HANDLED;
}

public _lr_show_targetsmenu(plugin, argc)
{
	new id = get_param(1), iDuelid = get_param(2), iAccess = get_param(3);
	
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: Player #%d is not connected!", id);
		return;
	}
	
	if(!(0 <= iDuelid < g_lr_items))
	{
		log_error(AMX_ERR_NATIVE, "Error: Duel id #%d is out of range!", iDuelid);
		return;
	}
	
	new sData[16];
	num_to_str(iDuelid, sData, charsmax(sData));
	Show_playersmenu(id, "LR_MENU_CHOOSE_TARG_TITLE", "lrmenu_handle2", sData, iAccess, TEAM_GUARDS, FLAG_ALIVE_ONLY);
}

public lrmenu_handle2(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	if(!Check_lr_available(id))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sPlayername[32], sData[16], sDuelname[32],
	 param[5], iAccess, iCallback;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sPlayername, charsmax(sPlayername), iCallback);
	
	menu_destroy(menu);
	
	new player = find_player("af", sPlayername), itemid = str_to_num(sData);
	
	if(!player)
	{
		Show_lastrequestmenu(id);
		client_print(id, print_center, "%s does not exist!", sPlayername);
		return PLUGIN_HANDLED;
	}

	new gfwReturn;
	ExecuteForward(fw_lr_duel_start, gfwReturn, id, player, itemid);
	
	if(gfwReturn == JB_LR_NOT_AVAILABLE) return PLUGIN_HANDLED;
	
	g_lr_inprogress = JB_LR_IN_COUNTDOWN;
	
	param[3] = 200; // alpha
	param[0] = 255; // red
	set_task(1.0, "player_beacon", id+TASK_BEACON, param, sizeof param, "b");
	param[0] = 0; // red
	param[2] = 255; // blue
	set_task(1.0, "player_beacon", player+TASK_BEACON, param, sizeof param, "b");
	
	EF_AttachToPlayer(id, 40.0, red_duelSpr, 9999.0);
	EF_AttachToPlayer(player, 40.0, blue_duelSpr, 9999.0);
	
	strip_weapons(id);
	strip_weapons(player);
	
	set_user_health(id, 100);
	set_user_health(player, 100);
	
	ArrayGetString(g_lr_itemname, itemid, sDuelname, charsmax(sDuelname));
	
	logevent_message_action("LR '%s' challenging", id, player, sDuelname);
	
	param[0] = itemid;
	g_iLRPrisoner = param[1] = id;
	g_iLRGuard = param[2] = player;
	if(!(LR_TIMER_LENGTH=clamp(get_pcvar_num(g_iCvar_identity[CVAR_LR_TIMER]), 0, 15)))
	{
		LR_TIMER(param, TASK_LR_TIMER);
	}
	else
	{
		set_task(1.0, "LR_TIMER", TASK_LR_TIMER, param, 3, "a", LR_TIMER_LENGTH + 1);
	}
	return PLUGIN_HANDLED;
}

public LR_TIMER(const param[], const taskid)
{
	new itemid = param[0], prisoner = param[1], guard = param[2], sDuelname[32], szName[32], szPName[32];
	ArrayGetString(g_lr_itemname, itemid, sDuelname, charsmax(sDuelname));
	get_user_name(guard, szName, charsmax(szName));
	get_user_name(prisoner, szPName, charsmax(szPName));
	
	set_hudmessage(0, 255, 0, -1.0, 0.35, 1, 1.0, 1.0, _, _, -1);
	show_hudmessage(0, "[%s]^n%s Vs %s^n%d", sDuelname, szName, szPName, LR_TIMER_LENGTH);
	
	if(!LR_TIMER_LENGTH)
	{
		g_lr_inprogress = itemid;
		ExecuteForward(fw_lr_duel_started, g_fw_return, g_iLRPrisoner, g_iLRGuard, g_lr_inprogress);
		logevent_message(0, "Last request '%s' vs '%s' game '%s' has started!", szName, szPName, sDuelname);
		remove_task(taskid);
		return;
	}
	
	LR_TIMER_LENGTH--;
}

public player_beacon(const param[], const taskid)
{
	new id = taskid - TASK_BEACON;
	
	if(!check_flag(IsUserAlive,id) || g_lr_inprogress == JB_LR_DEACTIVATED)
	{
		remove_task(taskid);
		return;
	}
	
	emit_sound(id, CHAN_AUTO, BEACON_SOUND, VOL_NORM, ATTN_NORM, 0, PITCH_HIGH);
	
	new iOrigin[3];
	get_user_origin(id, iOrigin);
	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY, iOrigin, id);
	write_byte(TE_BEAMCYLINDER);	// TE id
	write_coord(iOrigin[0]);	 	// x
	write_coord(iOrigin[1]);		// y
	write_coord(iOrigin[2]-20);		// z
	write_coord(iOrigin[0]+20);    	// x axis
	write_coord(iOrigin[1]+20);   	// y axis
	write_coord(iOrigin[2]+200);	// z axis
	write_short(beaconSpr);		// sprite
	write_byte(1);			// startframe   
	write_byte(10);			// framerate   
	write_byte(3);			// life
	write_byte(10);  		// width
	write_byte(10);   		// noise  
	write_byte(param[0]);  		// red  
	write_byte(param[1]);   		// green
	write_byte(param[2]); 		// blue
	write_byte(param[3]);		// brightness
	write_byte(0);			// speed
	message_end();
}

remove_attachment_fromplayer(plr, host=0)
{
	message_begin(!host ? MSG_ALL : MSG_ONE, SVC_TEMPENTITY, _, host);
	write_byte(TE_KILLPLAYERATTACHMENTS);
	write_byte(plr);
	message_end();
}

EF_AttachToPlayer(const plr, const Float:fl_YOffset, const mindex, const Float:fLife, const iDest = MSG_ALL, const Float:fMSGOrigin[3] = { 0.0, 0.0, 0.0 }, const host = 0)
{
    engfunc(EngFunc_MessageBegin, iDest, SVC_TEMPENTITY, fMSGOrigin, host);
    write_byte(TE_PLAYERATTACHMENT);
    write_byte(plr);
    engfunc(EngFunc_WriteCoord, fl_YOffset );
    write_short(mindex);
    write_short(min( floatround( fLife * 10.0 ), 0x7FFF ));
    message_end();
}

Show_playersmenu(id, const title[], const handler[], const sInfo[], iAccess=0, plrteam=TEAM_ANY, flag=FLAG_ALL, bool:bShowSelf=false)
{
	new players[32], pnum;
	
	switch( flag )
	{
		case FLAG_ALL: get_players(players, pnum, "h");
		case FLAG_ALIVE_ONLY: get_players(players, pnum, "ah");
		case FLAG_DEAD_ONLY: get_players(players, pnum, "bh");
	}
	
	if(!pnum) return 0;

	new sTitle[128], playersnum, player, i, sPlayername[32];
	formatex(sTitle, charsmax(sTitle), "%L", LANG_PLAYER, title);
	new iMenu = menu_create(sTitle, handler, true)
	
	for( i = 0; i < pnum; i++ )
	{
		player = players[i];
		
		if((plrteam != fm_get_user_team(player) && plrteam != TEAM_ANY) || id == player && !bShowSelf)
		{
			continue;
		}
		
		get_user_name(player, sPlayername, charsmax(sPlayername));
		menu_additem(iMenu, sPlayername, sInfo, iAccess);
		
		playersnum++;
	}
	
	if(!playersnum)
	{
		menu_destroy(iMenu);
		return 0;
	}
	
	menu_setprop(iMenu, MPROP_NUMBER_COLOR, "\y")
	menu_display(id, iMenu)
	
	return playersnum;
}

bool:Check_lr_available(id=0, bool:bMsg=false)
{
	if( !(0 <= id <= g_iMaxplayers) )
	{
		return false;
	}
	if(g_lr_inprogress != JB_LR_ACTIVATED && g_lr_inprogress != JB_LR_DEACTIVATED)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", !id ? LANG_SERVER:id, "LR_INPROGRESS");
		return false;
	}
	if(g_day_inprogress != JB_DAY_CAGEDAY)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", !id ? LANG_SERVER:id, "DAY_INPROGRESS");
		return false;
	}
	if(id != 0 && !check_flag(IsUserAlive,id))
	{
		if(bMsg) cprint_chat(id, 'n', "%L", !id ? LANG_SERVER:id, "MENU_NOT_ALIVE");
		return false;
	}
	if(id != 0 && get_user_team(id) != TEAM_PRISONERS)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", !id ? LANG_SERVER:id, "MENU_PRISONERS_ONLY");
		return false;
	}
	if(get_prisonersnum(FLAG_ALIVE_ONLY) > 1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", !id ? LANG_SERVER:id, "MENU_LR_LAST_PRISONER_ONLY");
		return false;
	}
	if(get_guardsnum(FLAG_ALIVE_ONLY) == 0)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", !id ? LANG_SERVER:id, "MENU_LR_NO_GUARDS");
		return false;
	}
	if(get_prisonersnum(FLAG_ALIVE_ONLY) == 0)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", !id ? LANG_SERVER:id, "MENU_LR_NO_PRISONERS");
		return false;
	}
	
	return true;
}

// native register_jailbreak_lritem(const name[], iAccess)
public _register_jailbreak_lritem(plugin, argc)
{
	if(argc == 0) // no args dedicated...
		return -1
	
	new sItem[64]
	get_string(1, sItem, charsmax(sItem))
	new iAccess = get_param(2)
	
	if(strlen(sItem) < 1)
	{
		formatex(sItem, charsmax(sItem), "LR_INVAILD_ITEM_NAME")
	}
	
	ArrayPushString(g_lr_itemname, sItem)
	ArrayPushCell(g_lr_itemaccess, iAccess)
	
	g_lr_items++
	return g_lr_items-1
}

public _get_current_duel(plugin, argc)
{
	set_param_byref(1, g_iLRGuard)
	set_param_byref(2, g_iLRPrisoner)
	
	return g_lr_inprogress
}

// native jb_get_duel_name(iDuelid, sName[], iLen)
public _get_duel_name(plugin, argc)
{
	new iDuelid = get_param(1)
	
	if(0 > iDuelid || g_lr_items <= iDuelid)
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Duel id #%d", iDuelid)
		return 0;
	}
	
	new sDuelname[32]
	ArrayGetString(g_lr_itemname, iDuelid, sDuelname, charsmax(sDuelname))
	set_string(2, sDuelname, get_param(3))
	
	return 1;
}

// native jb_get_duels_registered()
public _get_duels_registered(plugin, argc)
{
	return g_lr_items
}

// native jb_get_duelid_byname(const duelname[])
public _get_duelid_byname(plugin, argc)
{
	new sDuelname[32]
	get_string(1, sDuelname, charsmax(sDuelname))
	
	return (get_itemid_inarray_bystring(sDuelname, g_lr_itemname));
}

// native get current day...
public _get_current_day()
{
	return g_day_inprogress
}

public task_remove_gag(const taskid)
{
	new id = taskid - TASK_PLAYER_GAG, szName[32], szAuthID[32];

	get_user_name(id, szName, charsmax(szName));
	get_user_authid(id, szAuthID, charsmax(szAuthID));
	g_iUserGagged[id] = 0;
	cprint_chat(id, _, "* !g%s !yis no longer gagged!", szName);
	nvault_remove(g_nvault_gag, szAuthID);
}

public jailbreak_commands(id, level, cid)
{
	new szCommand[32], sString[192];
	read_argv(0, szCommand, charsmax(szCommand));
	read_args(sString, charsmax(sString));
	remove_quotes(sString);

	new sOutput[4][32], userid, sName[32], iAmount;

	if( !((szCommand[ 0 ] == 's' || szCommand[ 0 ] == 'S') &&
		  (szCommand[ 1 ] == 'a' || szCommand[ 1 ] == 'A') &&
		  (szCommand[ 2 ] == 'y' || szCommand[ 2 ] == 'Y')) )
	{
		read_argv(1, sOutput[1], charsmax(sOutput[]));
		read_argv(2, sOutput[2], charsmax(sOutput[]));
		read_argv(3, sOutput[3], charsmax(sOutput[]));
		remove_quotes(sOutput[1]);
		remove_quotes(sOutput[2]);
		remove_quotes(sOutput[3]);
	}
	else
	{
		str_explode(sString, ' ', sOutput, sizeof sOutput, charsmax(sOutput[]));
	}

	if(equali(sOutput[0], "/class") || equali(sOutput[0], "!class"))
	{
		class_menu(id);
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_PURCHASE_DISCOUNT]))
	{
		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 1;
		}

		new szTarget[32];
		read_argv(1, szTarget, charsmax(szTarget));
		read_argv(2, sOutput[2], charsmax(sOutput[]));
		remove_quotes(szTarget);
		remove_quotes(sOutput[2]);
		userid = cmd_target(id, szTarget, CMDTARGET_ALLOW_SELF);

		if(!userid || (!!sOutput[2][0] && !is_str_num(sOutput[2]))) return 1;

		if(!sOutput[2][0])
		{
			get_user_name(userid, sName, charsmax(sName));
			console_print(id, "Player %s has a %d%% discount on purchasing!", sName, floatround(g_fPlayerDiscount[userid] * 100.0));
			return 1;
		}

		new Float:fDiscount = floatclamp(floatstr(sOutput[2]) / 100.0, 0.0, 1.0);
		jb_set_user_discount(userid, fDiscount);

		if( id )
		{
			new sPlayername[32];
			get_user_name(userid, sPlayername, charsmax(sPlayername));
			get_user_name(id, sName, charsmax(sName));
			cprint_chat(0, 'n', "%L", "LANG_PLAYER", "ADMIN_SET_PURCHASE_DISCOUNT", sName, sPlayername, floatround(fDiscount * 100.0));
		}

		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_VOTEDAY]) || equali(sOutput[0], "/voteday") || equali(sOutput[0], "/vd"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_VOTEDAY], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 1;
		}
		if(!Check_day_available(id, true))
		{
			return 1;
		}
		
		start_theday(VOTE_DAY);
		
		get_user_name(id, sName, charsmax(sName));
		logevent_message_action("Admin has started a voteday!", id, 0);
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_START_VOTEDAY", sName);
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_ENDDAY]) || equali(sOutput[0], "/eday") || equali(sOutput[0], "/endtheday") || equali(sOutput[0], "/endday"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_ENDDAY], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 1;
		}
		if(g_day_inprogress == JB_DAY_CAGEDAY)
		{
			id ?
			cprint_chat(id, _, "%L", id, "DAY_NOT_INPROGRESS") :
			server_print("%L", LANG_SERVER, "DAY_NOT_INPROGRESS");
			return 1;
		}
		
		// Retrieve the admin nickname!
		get_user_name(id, sName, charsmax(sName));

		if(g_day_inprogress == JB_DAY_VOTEDAY)
		{
			logevent_message_action("Admin has ended the special day vote!", id);
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_END_SPECIALDAY_VOTE", sName);
			
			_end_theday();
			return 1;
		}
		
		new sDayname[MAX_DAYITEM_NAME_LENGTH];
		ArrayGetString(g_days_itemname, g_day_inprogress, sDayname, charsmax(sDayname));
		logevent_message_action("Admin has ended the '%s'", id, 0, sDayname);
		
		_end_theday();
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_END_DAY", sName);
		
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_ENDDUEL]) || equali(sOutput[0], "/eduel") || equali(sOutput[0], "/endtheduel") || equali(sOutput[0], "/endduel"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_ENDDUEL], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 1;
		}
		if(g_lr_inprogress == DUEL_NONE)
		{
			id ?
			cprint_chat(id, _, "%L", id, "LR_NOT_INPROGRESS") :
			server_print("%L", LANG_SERVER, "LR_NOT_INPROGRESS");
			return 1;
		}
		
		_end_theduel();
		get_user_name(id, sName, charsmax(sName));
		cprint_chat(0, 'n', "%L", "LANG_PLAYER", "ADMIN_END_LR", sName);
		logevent_message_action("Admin has ended the lastrequest duel!", id, 0);
		return 1;
	}
	if(equali(sOutput[0], "/day") || equali(sOutput[0], "/dm"))
	{
		days_menu(id); return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_CELLS]) || equali(sOutput[0], "/open") || equali(sOutput[0], "/close"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_CELLS], .flags=level);

		if(cmd_access(id, level, cid, 0))
		{
			new any:bOpenCells = -1;
			
			if(equali(sOutput[0], "/open") || sOutput[1][0] == '1' || sOutput[1][0] == 'O' || sOutput[1][0] == 'o')
			{
				bOpenCells = true;
			}
			else if(equali(sOutput[0], "/close") || sOutput[1][0] == '0' || sOutput[1][0] == 'C' || sOutput[1][0] == 'c')
			{
				bOpenCells = false;
			}
			else
			{
				return 1;
			}

			get_user_name(id, sName, charsmax(sName));
			
			logevent_message_action("Admin has '%s' the cells!", id, 0, bOpenCells ? "opened":"closed");
			
			jb_cells(JB_CELLS_STATE:bOpenCells);
			cprint_chat(0, _, "%L", LANG_PLAYER, "COMMAND_OPEN_CELLS", sName, bOpenCells ? "^4opened^1":"^3closed^1");
		}
		else
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
		}
		
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_INITIATESLR]) || equali(sOutput[0], "/lr") || equali(sOutput[0], "/lastrequest"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_INITIATESLR], .flags=level);

		new iPrisoner = get_last_prisoner_alive(.bInclude_bots=true);

		if(Check_lr_available() && cmd_access(id, level, cid, 0) && iPrisoner != id && iPrisoner > 0)
		{
			g_iLRPrisoner = iPrisoner;

			new iGuard, itemid = random(g_lr_items), players[32], gnum, gfwReturn;
			get_players(players, gnum, "ahe", "CT");
			iGuard = players[ random(gnum) ];
			
			ExecuteForward(fw_lr_duel_start, gfwReturn, iPrisoner, iGuard, itemid);
			
			if(gfwReturn == JB_LR_NOT_AVAILABLE) return PLUGIN_HANDLED;
			
			g_lr_inprogress = JB_LR_IN_COUNTDOWN;
			
			new param[5];
			param[3] = 200; // alpha
			param[0] = 255; // red
			set_task(1.0, "player_beacon", iPrisoner+TASK_BEACON, param, sizeof param, "b");
			param[0] = 0; // red
			param[2] = 255; // blue
			set_task(1.0, "player_beacon", iGuard+TASK_BEACON, param, sizeof param, "b");
			
			EF_AttachToPlayer(iPrisoner, 40.0, red_duelSpr, 9999.0);
			EF_AttachToPlayer(iGuard, 40.0, blue_duelSpr, 9999.0);
			
			strip_weapons(iPrisoner);
			strip_weapons(iGuard);
			
			set_user_health(iPrisoner, 100);
			set_user_health(iGuard, 100);
			
			new sDuelname[MAX_LRITEM_NAME_LENGTH];
			ArrayGetString(g_lr_itemname, itemid, sDuelname, charsmax(sDuelname));
			
			logevent_message_action("LR '%s' challenging", iPrisoner, iGuard, sDuelname);
			
			param[0] = itemid;
			param[1] = iPrisoner;
			g_iLRGuard = param[2] = iGuard;
			
			if(!(LR_TIMER_LENGTH=clamp(get_pcvar_num(g_iCvar_identity[CVAR_LR_TIMER]), 0, 15)))
			{
				LR_TIMER(param, TASK_LR_TIMER);
			}
			else
			{
				set_task(1.0, "LR_TIMER", TASK_LR_TIMER, param, 3, "a", LR_TIMER_LENGTH + 1);
			}
			return 1;
		}
		
		Show_lastrequestmenu(id);
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_TRANSFER]) || equali(sOutput[0], "/transfer") || equali(sOutput[0], "/trans"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_TRANSFER], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 1;
		}
		
		userid = cmd_target(id, sOutput[1], CMDTARGET_ALLOW_SELF);
		
		if(sOutput[1][0] == '@') userid = true;
		
		new xTeam, szxTeam[32];
		switch( sOutput[userid ? 2:1][0] )
		{
			case 'C' , 'c', 'G', 'g': {
				xTeam = TEAM_GUARDS
				formatex(szxTeam, charsmax(szxTeam), "Counter-terrorist");
			}
			case 'T' , 't', 'P', 'p': {
				xTeam = TEAM_PRISONERS
				formatex(szxTeam, charsmax(szxTeam), "terrorist");
			}
			case 'S' , 's': {
				xTeam = TEAM_SPECTATOR
				formatex(szxTeam, charsmax(szxTeam), "spectators");
			}
			default: {
				id ?
				cprint_chat(id, 'n', "%L", id, "COMMAND_FAILED_TRANSFER") :
				server_print("%L", LANG_SERVER, "COMMAND_FAILED_TRANSFER") ;
				return 0;
			}
		}
		
		switch( sOutput[1][0] )
		{
			case '@':
			{
				new players[32], num, team[32];
				
				switch( sOutput[1][1] )
				{
					case 'C' , 'c': {
						get_players(players, num, "he", "CT");
						formatex(team, charsmax(team), "Counter-terrorist");
					}
					case 'T' , 't': {
						get_players(players, num, "he", "TERRORIST");
						formatex(team, charsmax(team), "terrorist");
					}
					case 'S' , 's': {
						get_players(players, num, "he", "SPECTATOR");
						formatex(team, charsmax(team), "spectators");
					}
					case 'A' , 'a': {
						get_players(players, num, "h");
						formatex(team, charsmax(team), "all players");
					}
					default: {
						id ?
						cprint_chat(id, 'n', "%L", id, "COMMAND_FAILED_TRANSFER") :
						server_print("%L", LANG_SERVER, "COMMAND_FAILED_TRANSFER") ;
						return 0;
					}
				}
				
				for(new i = 0; i < num; i++)
				{
					userid = players[ i ];
					
					set_user_team(userid, xTeam);
				}
				
				get_user_name(id, sName, charsmax(sName));
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_TRANSFERING_TEAM", sName, team, szxTeam);
				return 1
			}
			default:
			{
				if(!is_user_connected(userid))
				{
					if(!id)
					{
						server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 1;
					}

					userid = id
				}
			}
		}
		
		set_user_team(userid, xTeam);
		get_user_name(userid, sOutput[1], charsmax(sOutput[]));
		get_user_name(id, sName, charsmax(sName));
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_TRANSFERING_PLAYER", sName, sOutput[1], szxTeam);
		return 1
	}

	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_GAG]) || equali(sOutput[0], "/gag"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_GAG], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 1;
		}

		userid = cmd_target(id, sOutput[1], (CMDTARGET_NO_BOTS|CMDTARGET_ALLOW_SELF|CMDTARGET_OBEY_IMMUNITY));

		if(!userid)
		{
			if(!sOutput[1][0])
			{
				id ?
				cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
				server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
				return 1;
			}

			id ?
			cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
			server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
			return 1;
		}

		new szAuthID[32];

		get_user_authid(userid, szAuthID, charsmax(szAuthID));
		get_user_name(userid, sOutput[1], charsmax(sOutput[]));
		get_user_name(id, sName, charsmax(sName));
		switch( g_iUserGagged[userid] )
		{
			case 0: // User is not gagged!
			{
				iAmount = str_to_num(sOutput[2]);

				new szLength[32];

				if( iAmount <= 0 )
				{
					formatex(szLength, charsmax(szLength), "%L", LANG_SERVER, "PERMANENTLY");
					iAmount = -1;
				}
				else
				{
					formatex(szLength, charsmax(szLength), "'%d' minutes", iAmount);
					set_task( floatmax(60.0 * iAmount, 60.0), "task_remove_gag", userid + TASK_PLAYER_GAG );
				}

				logevent_message_action("Admin has gagged player %s!", id, userid, szLength);
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GAG_PLAYER", sName, sOutput[1], szLength);
				g_iUserGagged[userid] = iAmount;

				num_to_str(iAmount, szLength, charsmax(szLength));
				nvault_set(g_nvault_gag, szAuthID, szLength);
			}
			default:
			{
				remove_task(userid + TASK_PLAYER_GAG);
				logevent_message_action("Admin has removed player gag", id, userid);
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_UNGAG_PLAYER", sName, sOutput[1]);
				g_iUserGagged[userid] = 0;
				nvault_remove(g_nvault_gag, szAuthID);
			}
		}

		return 1;
	}

	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_GIVE]) || equali(sOutput[0], "/give"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_GIVE], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 1;
		}

		if(equali(sOutput[1], "blind", 5) || equali(sOutput[1], "sight"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					if(!sOutput[3][0])
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}
					
					iAmount = str_to_num(sOutput[3]);
					if(equali(sOutput[1], "sight")) iAmount = !iAmount;

					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT");
							formatex(team, charsmax(team), "Counter-terrorist");
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST");
							formatex(team, charsmax(team), "terrorist");
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR");
							formatex(team, charsmax(team), "spectators");
						}
						case 'A' , 'a': {
							get_players(players, num, "ah");
							formatex(team, charsmax(team), "players");
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", id, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}
					
					for(new i = 0; i < num; i++)
					{
						userid = players[ i ]
						
						switch( iAmount ) {
							case 0: UTIL_ScreenFade(userid, {0, 0, 0}, -1.0, 1.0, 0, FFADE_IN);
							default: UTIL_ScreenFade(userid, {0, 0, 0}, -1.0, 1.0, 255, FFADE_STAYOUT);
						}
					}
					
					new szAction[32];

					get_user_name(id, sName, charsmax(sName));
					switch( iAmount )
					{
						case 0:
						{
							copy(szAction, charsmax(szAction), "their sight back");
							cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_SIGHT_TEAM", sName, team);
						}
						default:
						{
							copy(szAction, charsmax(szAction), "the blindness disease");
							cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_BLINDNESS_TEAM", sName, team);
						}
					}

					logevent_message_action("Admin has give all the '%s' %s", id, 0, team, szAction);
					return 1;
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						if(!sOutput[2][0])
						{
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
							server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
							return 1;
						}

						if(!id)
						{
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 1;
						}

						userid = id;
						iAmount = str_to_num(sOutput[2]);

					}
					else if(!sOutput[3][0])
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}
					else
					{
						iAmount = str_to_num(sOutput[3]);
					}

					if(equali(sOutput[1], "sight")) iAmount = !iAmount;
				}
			}

			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			get_user_name(id, sName, charsmax(sName));
			switch( iAmount )
			{
				case 0:
				{
					UTIL_ScreenFade(userid, {0, 0, 0}, -1.0, 1.0, 0, FFADE_IN);
					logevent_message_action("Admin has give player his sight back", id, userid);
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_SIGHT_PLAYER", sName, sOutput[2]);
				}
				default:
				{
					UTIL_ScreenFade(userid, {0, 0, 0}, -1.0, 1.0, 255, FFADE_STAYOUT);
					logevent_message_action("Admin has give player the blindness disease", id, userid);
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_BLINDNESS_PLAYER", sName, sOutput[2]);
				}
			}

			return 1;
		}

		if(equali(sOutput[1], "weapon") || equali(sOutput[1], "gun"))
		{
			new szWeaponName[20];
			iAmount = 0;

			switch( sOutput[2][0] )
			{
				case '@':
				{
					for(new i = CSW_P228; i <= CSW_P90; i++)
					{
						if(get_weaponname(i, szWeaponName, charsmax(szWeaponName)) < 7) continue;

						if(containi(szWeaponName[7], sOutput[3]) != -1)
						{
							iAmount = 1;
							break;
						}
					}

					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}
					
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "players")
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}
					
					for(new cswid = get_weaponid(szWeaponName), i = 0; i < num; i++)
					{
						userid = players[ i ]
						
						give_item(userid, szWeaponName);
						if(cswid != CSW_KNIFE && cswid != CSW_C4 && cswid != CSW_SHIELDGUN) cs_set_user_bpammo(userid, cswid, 200);
						if(cswid == CSW_C4) cs_set_user_plant(userid, true, true);
					}
					
					strtoupper(szWeaponName[7]);
					logevent_message_action("Admin has give all the '%s' weapon '%s'", id, 0, team, szWeaponName[7]);
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_WEAPON_TEAM", sName, team, szWeaponName[7]);
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						if(!id)
						{
							//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 1;
						}

						userid = id;
						for(new i = CSW_P228; i <= CSW_P90; i++)
						{
							if(get_weaponname(i, szWeaponName, charsmax(szWeaponName)) < 7) continue;

							if(containi(szWeaponName[7], sOutput[2]) != -1)
							{
								iAmount = 1;
								break;
							}
						}
					}
					else
					{
						for(new i = CSW_P228; i <= CSW_P90; i++)
						{
							if(get_weaponname(i, szWeaponName, charsmax(szWeaponName)) < 7) continue;

							if(containi(szWeaponName[7], sOutput[3]) != -1)
							{
								iAmount = 1;
								break;
							}
						}
					}
					
					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}
				}
			}

			new csw_id = get_weaponid(szWeaponName);
			give_item(userid, szWeaponName);
			if(csw_id != CSW_KNIFE && csw_id != CSW_C4 && csw_id != CSW_SHIELDGUN) cs_set_user_bpammo(userid, csw_id, 200);
			if(csw_id == CSW_C4) cs_set_user_plant(userid, true, true);
			
			strtoupper(szWeaponName[7]);
			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			get_user_name(id, sName, charsmax(sName));
			logevent_message_action("Admin has give player a weapon '%s'", id, userid, szWeaponName[7]);
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_WEAPON_PLAYER", sName, sOutput[2], szWeaponName[7])
			return 1
		}
		if(equali(sOutput[1], "shield") )
		{
			new szWeaponName[20];

			switch( sOutput[2][0] )
			{
				case '@':
				{
					new players[32], num, team[32]

					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "players")
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}

					for(new cswid, aWeapons[32], wNums, i = 0; i < num; i++)
					{
						userid = players[ i ]

						if( cs_get_user_hasprim(userid) )
						{
							if((get_user_weapons(id, aWeapons, wNums) & (CSW_ALL_MACHINEGUNS|CSW_ALL_SNIPERRIFLES|CSW_ALL_RIFLES|CSW_ALL_SMGS|CSW_ALL_SHOTGUNS)) > 0)
							{
								while( wNums-- > 0 )
								{
									cswid = aWeapons[wNums];

									if((1<<cswid) & (CSW_ALL_MACHINEGUNS|CSW_ALL_SNIPERRIFLES|CSW_ALL_RIFLES|CSW_ALL_SMGS|CSW_ALL_SHOTGUNS))
									{
										get_weaponname(cswid, szWeaponName, charsmax(szWeaponName));
										engclient_cmd(id, "drop", szWeaponName);
									}
								}
							}
						}

						give_item(userid, "weapon_shield");
						cs_set_user_bpammo(userid, CSW_SHIELD, 1);
					}

					logevent_message_action("Admin has give all the '%s' a 'SHIELD'", id, 0, team);
					get_user_name(id, sName, charsmax(sName));
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_SHIELD_TEAM", sName, team, "SHIELD");
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)

					if(!userid)
					{
						if(!sOutput[2][0])
						{
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
							server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
							return 0;
						}
					}
				}
			}

			if( cs_get_user_hasprim(userid) )
			{
				new aWeapons[32], wNums, cswid;
				if((get_user_weapons(id, aWeapons, wNums)  & (CSW_ALL_MACHINEGUNS|CSW_ALL_SNIPERRIFLES|CSW_ALL_RIFLES|CSW_ALL_SMGS|CSW_ALL_SHOTGUNS)) > 0)
				{
					while( wNums-- > 0 )
					{
						cswid = aWeapons[wNums];

						if((1<<cswid) & (CSW_ALL_MACHINEGUNS|CSW_ALL_SNIPERRIFLES|CSW_ALL_RIFLES|CSW_ALL_SMGS|CSW_ALL_SHOTGUNS))
						{
							get_weaponname(cswid, szWeaponName, charsmax(szWeaponName));
							engclient_cmd(id, "drop", szWeaponName);
						}
					}
				}
			}

			give_item(userid, "weapon_shield");
			cs_set_user_bpammo(userid, CSW_SHIELD, 1);
			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			get_user_name(id, sName, charsmax(sName));
			logevent_message_action("Admin has give player a 'SHIELD'", id, userid);
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_SHIELD_PLAYER", sName, sOutput[2], "SHIELD");
			return 1;
		}

		id ?
		cprint_chat(id, _, "%L", id, "CHAT_GIVE_COMMAND_USAGE") :
		server_print("%L", LANG_SERVER, "COMMAND_GIVE_USAGE");
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_SET]) || equali(sOutput[0], "/set")) // health, armour, noclip, godmode, gravity. (TO DO :>> speed, flash)
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_SET], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 0;
		}
		if(equali(sOutput[1], "weapon") || equali(sOutput[1], "gun"))
		{
			new szWeaponName[20];
			iAmount = 0;

			switch( sOutput[2][0] )
			{
				case '@':
				{
					for(new i = CSW_P228; i <= CSW_P90; i++)
					{
						if(get_weaponname(i, szWeaponName, charsmax(szWeaponName)) < 7) continue;

						if(containi(szWeaponName[7], sOutput[3]) != -1)
						{
							iAmount = 1;
							break;
						}
					}

					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}

					new players[32], num, team[32]

					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "players")
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}

					for(new cswid = get_weaponid(szWeaponName), i = 0; i < num; i++)
					{
						userid = players[ i ]

						strip_weapons(userid);
						give_item(userid, szWeaponName);
						if(cswid != CSW_KNIFE && cswid != CSW_C4 && cswid != CSW_SHIELDGUN) cs_set_user_bpammo(userid, cswid, 200);
						if(cswid == CSW_C4) cs_set_user_plant(userid, true, true);
					}

					strtoupper(szWeaponName[7]);
					logevent_message_action("Admin has set all the '%s' weapon to '%s'", id, 0, team, szWeaponName[7]);
					get_user_name(id, sName, charsmax(sName));
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_SET_WEAPON_TEAM", sName, team, szWeaponName[7]);
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF);

					if(!userid)
					{
						if(!id)
						{
							return 1;
						}

						userid = id;
						for(new i = CSW_P228; i <= CSW_P90; i++)
						{
							if(get_weaponname(i, szWeaponName, charsmax(szWeaponName)) < 7) continue;

							if(containi(szWeaponName[7], sOutput[2]) != -1)
							{
								iAmount = 1;
								break;
							}
						}
					}
					else
					{
						for(new i = CSW_P228; i <= CSW_P90; i++)
						{
							if(get_weaponname(i, szWeaponName, charsmax(szWeaponName)) < 7) continue;

							if(containi(szWeaponName[7], sOutput[3]) != -1)
							{
								iAmount = 1;
								break;
							}
						}
					}

					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}
				}
			}

			strip_weapons(userid);

			new csw_id = get_weaponid(szWeaponName);
			give_item(userid, szWeaponName);
			if(csw_id != CSW_KNIFE && csw_id != CSW_C4 && csw_id != CSW_SHIELDGUN) cs_set_user_bpammo(userid, csw_id, 200);
			if(csw_id == CSW_C4) cs_set_user_plant(userid, true, true);

			strtoupper(szWeaponName[7]);
			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			get_user_name(id, sName, charsmax(sName));
			logevent_message_action("Admin has set player weapon to '%s'", id, userid, szWeaponName[7]);
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_SET_WEAPON_PLAYER", sName, sOutput[2], szWeaponName[7]);
			return 1
		}

		if(equali(sOutput[1], "health") || equali(sOutput[1], "hp"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = str_to_num(sOutput[3]);
					
					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}
					
					new players[32], num, team[32];
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT");
							formatex(team, charsmax(team), "Counter-terrorist");
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST");
							formatex(team, charsmax(team), "terrorist");
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR");
							formatex(team, charsmax(team), "spectators");
						}
						case 'A' , 'a': {
							get_players(players, num, "ah");
							formatex(team, charsmax(team), "players");
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0;
						}
					}
					
					new iColors[3]; 
					
					for(new i = 0; i < num; i++)
					{
						userid = players[ i ];
						
						iColors[0] = (get_user_health(userid) > iAmount) ? 255:0;
						iColors[1] = (get_user_health(userid) <= iAmount) ? 255:0;
						UTIL_ScreenFade(userid, iColors, -1.0, 3.0, 200, FFADE_MODULATE);
						set_user_health(userid, iAmount);
					}
					
					logevent_message_action("Admin has set all the '%s' HP to '%d'", id, 0, team, iAmount);
					get_user_name(id, sName, charsmax(sName));
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_HEALING_TEAM", sName, team, iAmount);
					return 1;
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF);
					
					if(!userid)
					{
						if(!id)
						{
							//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 1;
						}

						userid = id
						iAmount = str_to_num(sOutput[2]);
					}
					else iAmount = str_to_num(sOutput[3]);
					
					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
					}
				}
			}
			
			new iColors[3]; iColors[0] = (get_user_health(userid) > iAmount) ? 255:0;
			iColors[1] = (get_user_health(userid) <= iAmount) ? 255:0;
			UTIL_ScreenFade(userid, iColors, _, 3.0, 200, FFADE_MODULATE);
			set_user_health(userid, iAmount);
			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			get_user_name(id, sName, charsmax(sName));
			logevent_message_action("Admin has set player HP to '%d'", id, userid, iAmount);
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_HEALING_PLAYER", sName, sOutput[2], iAmount);
			return 1;
		}
		if(equali(sOutput[1], "armour") || equali(sOutput[1], "armor") || equali(sOutput[1], "ap"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = str_to_num(sOutput[3]);
					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0
					}
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "players")
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}
					
					for(new i = 0; i < num; i++)
					{
						userid = players[ i ]
						
						set_user_armor(userid, iAmount)
					}
					
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_AROMR_TEAM", sName, team, iAmount)
					logevent_message_action("Admin has set all the '%s' armor to '%d'", id, 0, team, iAmount);
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						if(!id)
						{
							//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 1;
						}

						userid = id
						iAmount = str_to_num(sOutput[2]);
					}
					else iAmount = str_to_num(sOutput[3]);
					
					if(!iAmount)
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0;
					}
				}
			}
			
			set_user_armor(userid, iAmount)
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			get_user_name(id, sName, charsmax(sName))
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_ARMOR_PLAYER", sName, sOutput[2], iAmount);
			logevent_message_action("Admin has set his armor to '%d'", id, userid, iAmount);
			return 1;
		}
		if(equali(sOutput[1], "noclip"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = clamp(str_to_num(sOutput[3]), 0, 1)
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "players")
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}
					
					for(new i = 0; i < num ;i++)
					{
						userid = players[ i ]
						
						set_user_noclip(userid, iAmount)
					}
					
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_NOCLIP_TEAM", sName, team, LANG_PLAYER, iAmount ? "ON":"OFF")
					logevent_message_action("Admin has set all the '%s' noclip to '%s'", id, 0, team, iAmount ? "ON":"OFF");
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						if(!id)
						{
							//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 1;
						}

						userid = id
					}
				}
			}
			
			set_user_noclip(userid, (iAmount=(get_user_noclip(userid) ? 0:1)));
			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			get_user_name(id, sName, charsmax(sName));
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_NOCLIP_PLAYER", sName, sOutput[2], LANG_PLAYER, iAmount ? "ON":"OFF")
			logevent_message_action("Admin has set his noclip to '%s'", id, userid, iAmount ? "ON":"OFF");
			return 1
		}
		if(equali(sOutput[1], "godmode"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = clamp(str_to_num(sOutput[3]), 0, 1)
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "players")
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}
					
					for(new i = 0; i < num ;i++)
					{
						userid = players[ i ]
						
						set_user_godmode(userid, iAmount)
					}
					
					get_user_name(id, sName, charsmax(sName));
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GODMODE_TEAM", sName, team, LANG_PLAYER, iAmount ? "ON":"OFF");
					logevent_message_action("Admin has set all the '%s' godmode to '%s'", id, 0, team, iAmount ? "ON":"OFF");
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						if(!id)
						{
							//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 1;
						}

						userid = id
					}
				}
			}
			
			set_user_godmode(userid, (iAmount=(get_user_godmode(userid) ? 0:1)));
			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			get_user_name(id, sName, charsmax(sName));
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GODMODE_PLAYER", sName, sOutput[2], LANG_PLAYER, get_user_godmode(userid) ? "ON":"OFF");
			logevent_message_action("Admin has set his godmode to '%s'", id, userid, iAmount ? "ON":"OFF");
			return 1
		}
		if(equali(sOutput[1], "gravity"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					if(!strlen(sOutput[3]))
					{
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
						server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
						return 0
					}
					
					iAmount = str_to_num(sOutput[3])
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "players")
						}
						default: {
							id ?
							cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
							server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 0
						}
					}
					
					new Float:fAmount = iAmount/800.0
					
					for(new i = 0; i < num ;i++)
					{
						userid = players[ i ]
						
						set_user_gravity(userid, fAmount)
					}
					
					get_user_name(id, sName, charsmax(sName));
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GRAVITY_TEAM", sName, team, iAmount);
					logevent_message_action("Admin has set all the '%s' gravity to '%d' units", id, 0, team, iAmount);
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF);
					
					if(!userid)
					{
						if(!id)
						{
							//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
							return 1;
						}

						userid = id;
						iAmount = str_to_num(sOutput[2]);
					}
					else iAmount = str_to_num(sOutput[3]);
				}
			}
			
			set_user_gravity(userid, (iAmount / 800.0))
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			get_user_name(id, sName, charsmax(sName))
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GRAVITY_PLAYER", sName, sOutput[2], iAmount)
			logevent_message_action("Admin has set his gravity to '%d'", id, userid, iAmount);
			return 1
		}
		if(id && (equali(sOutput[1], "cell", 4) || equali(sOutput[1], "button", 6)))
		{
			if(sOutput[2][0] == '*')
			{
				if(is_str_num(sOutput[2][1]))
				{
					new iCell = str_to_num(sOutput[2][1]);

					if(!pev_valid(iCell))
					{
						cprint_chat(id, _, "Entity #%d is not valid!", iCell);
						return 1;
					}

					new sClassname[16];
					pev(iCell, pev_classname, sClassname, charsmax(sClassname));

					if( !equal(sClassname, "func_button") && !equal(sClassname, "button_target") &&
						!equal(sClassname, "func_rot_button") )
		        	{
		        		cprint_chat(id, _, "The entity #%d is not a valid entity button!", iCell);
		        		return 1;
		        	}

					remove_map_cells_button();
					save_map_cells_button(iCell);

					cprint_chat(id, _, "The cells button was successfully set to button entity index #%d !", CELLS_BUTTON);
					return 1;
				}

				remove_map_cells_button();
				if( search_for_cellsbutton() )
				{
					cprint_chat(id, _, "The cells button was successfully set to button entity index #%d !", CELLS_BUTTON);
				}
				else
				{
					cprint_chat(id, _, "Failed to automatically find the cells button!");
				}

				return 1;
			}

			new target, body;
			get_user_aiming(id, target, body, 9999);

			if( !target )
			{
		        new ent, iAim[3], Float:fEntityOrigin[3], Float:fSight[3], sClassname[16], Float:fDistance, iClosestTarget;
		        pev(target, pev_classname, sClassname, charsmax(sClassname));
		        fDistance = 50.0; iClosestTarget = 0;
		        get_user_origin(id, iAim, Origin_AimEndEyes);
		        IVecFVec(iAim, fSight);

		        while( (ent = find_ent_in_sphere(ent, fSight, 3.0)) )
		        {
		            if(pev(ent, pev_movetype) != MOVETYPE_NONE)
		            {
						pev(ent, pev_classname, sClassname, charsmax(sClassname));

						if( equal(sClassname, "func_button") || equal(sClassname, "button_target") ||
							equal(sClassname, "func_rot_button") )
		                {
							get_brush_entity_origin(ent, fEntityOrigin);
							if(fDistance > get_distance_f(fEntityOrigin, fSight))
							{
								iClosestTarget = ent;
								fDistance = get_distance_f(fEntityOrigin, fSight);
							}
			            }
		            }
		        }

		        target = iClosestTarget;
			}
			
			if(pev_valid(target))
			{
				new sClassname[24];
				pev(target, pev_classname, sClassname, charsmax(sClassname));
				
				if( !equal(sClassname, "func_button") && !equal(sClassname, "button_target") &&
					!equal(sClassname, "func_door") && !equal(sClassname, "func_rot_button") &&
					!equal(sClassname, "func_door_rotating") )
				{
					client_print(id, print_center, "Invalid Cells Button '%s'", sClassname);
					cprint_chat(id, _, "%L", id, "INVAILD_CELLS_BUTTON");
					return 1;
				}
				
				new szMapname[32];
				get_mapname(szMapname, charsmax(szMapname));
				save_map_cells_button(target);
				cprint_chat(id, _, "%L", id, "MAP_CELLS_BUTTON_SAVED", target, szMapname);
				logevent_message_action("Admin has assigned the cells button to entity '%d'", id, 0, target);
			}
			else
			{
				cprint_chat(id, _, "%L", id, "CHAT_TARGET_NOT_FOUND");
			}
			
			return 1;
		}
		
		id ?
			cprint_chat(id, _, "%L", id, "CHAT_SET_COMMAND_USAGE") :
			server_print("%L", LANG_SERVER, "COMMAND_SET_USAGE");
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_TELEPORT]) || equali(sOutput[0], "/tele"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_TELEPORT], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 0;
		}

		new players[32], num, team[32], sFlags[5];

		switch( sOutput[1][0] )
		{
			case '@':
			{
				switch( sOutput[1][2] )
				{
					case 'A', 'a': {
						add(sFlags, charsmax(sFlags), "ah");
						formatex(team, charsmax(team), "(%L) ", LANG_PLAYER, "ALIVE");
					}
					case 'D', 'd': {
						add(sFlags, charsmax(sFlags), "bh");
						formatex(team, charsmax(team), "(%L) ", LANG_PLAYER, "DEAD");
					}
					default: add(sFlags, charsmax(sFlags), "h");
				}
				switch( sOutput[1][1] )
				{
					case 'C' , 'c': {
						add(sFlags, charsmax(sFlags), "e");
						get_players(players, num, sFlags, "CT");
						format(team, charsmax(team), "%sCounter-terrorist", team);
					}
					case 'T' , 't': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "TERRORIST");
						format(team, charsmax(team), "%sTerrorist", team);
					}
					case 'S' , 's': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "SPECTATOR");
						format(team, charsmax(team), "%sSpectators", team);
					}
					case 'A' , 'a': {
						get_players(players, num, sFlags);
						format(team, charsmax(team), "all %sPlayers", team);
					}
					default: {
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
						server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 0
					}
				}
			}
			default:
			{
				userid = cmd_target(id, sOutput[1], CMDTARGET_ALLOW_SELF);

				if(!userid)
				{
					if(!id)
					{
						return 1;
					}

					if(sOutput[1][0] != EOS)
					{
						cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
						return 1;
					}

					userid = id;
				}

				players[ 0 ] = userid;
				num = 1;
			}
		}

		userid = cmd_target(id, sOutput[2][1], CMDTARGET_ALLOW_SELF);

		if( !userid )
		{
			id ?
			cprint_chat(id, _, "%L", id, "CHAT_TARGET_NOT_FOUND") :
			server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
			return 0;
		}

		new Array:aLocations = Invalid_Array, bool:bExact = true, Float:fDest[3];
		pev(userid, pev_origin, fDest);

		if( sOutput[2][0] == '~' )
		{
			bExact = false;
			find_location_around_origin(fDest, Float:{16.0, 16.0, 36.0}, Float:{-16.0, -16.0, -36.0}, 32.0 * num, .pArrayLocations = aLocations);
		}

		if( !bExact )
		{
			for(new i, iChosen; i < num; i++)
			{
				iChosen = ArraySize(aLocations);

				if( iChosen > 0 )
				{
					iChosen = random(iChosen);
					ArrayGetArray(aLocations, iChosen, fDest);
					ArrayDeleteItem(aLocations, iChosen);
				}

				engfunc(EngFunc_SetOrigin, players[i], fDest);
			}
		}
		else
		{
			for(new i; i < num; i++)
			{
				engfunc(EngFunc_SetOrigin, players[i], fDest);
			}
		}

		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_REVIVE]) || equali(sOutput[0], "/revive"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_REVIVE], .flags=level);

		if(!cmd_access(id, level, cid, 0))
		{
			id ?
			cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
			server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
			return 0;
		}
		
		switch( sOutput[1][0] )
		{
			case '@':
			{
				new players[32], num, team[32], sFlags[5];
				
				switch( sOutput[1][2] )
				{
					case 'A', 'a': {
						add(sFlags, charsmax(sFlags), "ah")
						formatex(team, charsmax(team), "(%L) ", LANG_PLAYER, "ALIVE")
					}
					case 'D', 'd': {
						add(sFlags, charsmax(sFlags), "bh")
						formatex(team, charsmax(team), "(%L) ", LANG_PLAYER, "DEAD")
					}
					default: add(sFlags, charsmax(sFlags), "h")
				}
				switch( sOutput[1][1] )
				{
					case 'C' , 'c': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "CT")
						format(team, charsmax(team), "%sCounter-terrorist", team)
					}
					case 'T' , 't': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "TERRORIST")
						format(team, charsmax(team), "%sTerrorist", team)
					}
					case 'S' , 's': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "SPECTATOR")
						format(team, charsmax(team), "%sSpectators", team)
					}
					case 'A' , 'a': {
						get_players(players, num, sFlags)
						format(team, charsmax(team), "all %sPlayers", team)
					}
					default: {
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
						server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 0
					}
				}
				
				for(new i = 0; i < num ;i++)
				{
					userid = players[ i ]
					
					ExecuteHamB(Ham_CS_RoundRespawn, userid)
				}
				
				get_user_name(id, sName, charsmax(sName))
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_REVIVE_TEAM", sName, team)
				logevent_message_action("Admin has revived all the '%s'", id, userid, team);
				return 1
			}
			default:
			{
				userid = cmd_target(id, sOutput[1], CMDTARGET_ALLOW_SELF);
				
				if(!userid)
				{
					if(!id)
					{
						//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 1;
					}

					if(sOutput[1][0] != EOS)
					{
						cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
						return 1;
					}
					
					userid = id;
				}
			}
		}
		
		ExecuteHamB(Ham_CS_RoundRespawn, userid)
		get_user_name(userid, sOutput[1], charsmax(sOutput[]))
		get_user_name(id, sName, charsmax(sName))
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_REVIVE_PLAYER", sOutput[1], sName)
		logevent_message_action("Admin has revived", id, userid);
		return 1
	}
	else if(equali(sOutput[0], "/donate"))
	{
		if( !get_pcvar_num(g_iCvar_identity[CVAR_DONATE]) )
		{
			cprint_chat(id, 'n', "%L", id, "CHAT_DONATION_IS_DISABLED");
			return 1;
		}

		if(sOutput[1][0] == EOS)
		{
			cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_IS_MISSING");
		}

		userid = cmd_target(id, sOutput[1], CMDTARGET_NO_BOTS);
		iAmount = str_to_num(sOutput[2]);
		
		if(!userid)
		{
			cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
			return 0;
		}
		if(userid == id)
		{
			cprint_chat(id, 'n', "%L", id, "DONATION_SELF");
			return 0;
		}
		if(!strlen(sOutput[2]) || !iAmount || contain(sOutput[2], "-") != -1)
		{
			cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING");
			return 0;
		}
		if(user_cash[id] < iAmount)
		{
			cprint_chat(id, 'n', "%L", id, "DONATION_DONT_HAVE");
			return 0;
		}
		
		get_user_name(userid, sOutput[1], charsmax(sOutput[]));
		get_user_name(id, sName, charsmax(sName));
		jb_set_user_cash(userid, iAmount+jb_get_user_cash(userid));
		jb_set_user_cash(id, jb_get_user_cash(id)-iAmount);
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "DONATION_PROGRESS", sName, sOutput[1], iAmount);
		logevent_message_action("has donated '%d' to", id, userid, iAmount);
		log_amx("Player '%s' has donated to '%s' %d$.", sName, sOutput[1], iAmount);
		log_to_file("jb_donation.txt", "Player '%s' has donated to '%s' %d$.", sName, sOutput[1], iAmount);
		return 1;
	}
	if(equali(sOutput[0], "/shop") || equali(sOutput[0], "!shop"))
	{
		shop_menu(id);
		return 1;
	}
	if(equali(szCommand, g_szJB_CONCOMMANDS[CONCMD_CASH]) || equali(sOutput[0], "/cash"))
	{
		get_concmd_flags(g_iJB_CONCOMMAND_ID[CONCMD_CASH], .flags=level);

		if(equali(sOutput[1], "give"))
		{
			if(!cmd_access(id, level, cid, 0))
			{
				id ?
				cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
				server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
				return 1;
			}
			if(sOutput[2][0] == EOS)
			{
				id ?
				cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
				server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
				return 1;
			}

			new players[32], pnum = 1;
			iAmount = str_to_num(sOutput[3]);

			if(sOutput[2][0] != '@')
			{
				players[ 0 ] = userid = cmd_target(id, sOutput[2], CMDTARGET_NO_BOTS|CMDTARGET_ALLOW_SELF);

				if(!userid)
				{
					if(!id)
					{
						server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 1;
					}

					cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
					return 1;
				}
			}
			else
			{
				switch( sOutput[2][1] )
				{
					case 'A', 'a': get_players(players, pnum, "ch");
					case 'C', 'c', 'G', 'g': get_players(players, pnum, "che", "CT");
					case 'T', 't', 'P', 'p': get_players(players, pnum, "che", "TERRORIST");
					case 'S', 's': get_players(players, pnum, "che", "SPECTATOR");
					default: {
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
						server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 1;
					}
				}
			}

			if(!strlen(sOutput[3]) || !iAmount)
			{
				id ?
				cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
				server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
				return 1;
			}
			
			for(new i; i < pnum; i++)
			{
				userid = players[ i ];

				jb_set_user_cash(userid, iAmount+jb_get_user_cash(userid));
			}

			get_user_name(id, sName, charsmax(sName));
			if(pnum > 1)
			{
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_CASH_GROUP", sName, iAmount, sOutput[2]);
				logevent_message(0, "Admin '%s' gave cash '%d' to '%s'", sName, iAmount, sOutput[2]);
				return 1;
			}

			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GIVE_CASH_PLAYER", sName, sOutput[2], iAmount);
			logevent_message_action("Admin gave cash '%d' to", id, userid, iAmount);
			return 1;
		}
		if(equali(sOutput[1], "take"))
		{
			if(!cmd_access(id, level, cid, 0))
			{
				id ?
				cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
				server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
				return 1;
			}
			if(sOutput[2][0] == EOS)
			{
				id ?
				cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
				server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
				return 1;
			}

			new players[32], pnum = 1;
			iAmount = str_to_num(sOutput[3]);

			if(sOutput[2][0] != '@')
			{
				players[ 0 ] = userid = cmd_target(id, sOutput[2], CMDTARGET_NO_BOTS|CMDTARGET_ALLOW_SELF);

				if(!userid)
				{
					if(!id)
					{
						//server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 1;
					}

					cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
					return 1;
				}
			}
			else
			{
				switch( sOutput[2][1] )
				{
					case 'A', 'a': get_players(players, pnum, "ch");
					case 'C', 'c', 'G', 'g': get_players(players, pnum, "che", "CT");
					case 'T', 't', 'P', 'p': get_players(players, pnum, "che", "TERRORIST");
					case 'S', 's': get_players(players, pnum, "che", "SPECTATOR");
					default: {
						id ?
						cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
						server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
						return 1;
					}
				}
			}

			if(!strlen(sOutput[3]) || !iAmount)
			{
				id ?
				cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
				server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
				return 1;
			}

			for(new i; i < pnum; i++)
			{
				userid = players[ i ];

				jb_set_user_cash(userid, jb_get_user_cash(userid)-iAmount);
			}

			get_user_name(id, sName, charsmax(sName));
			if(pnum > 1)
			{
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_TOOK_CASH_GROUP", sName, sOutput[2], iAmount);
				logevent_message(0, "Admin '%s' took cash '%d' from '%s'", sName, iAmount, sOutput[2]);
				return 1;
			}

			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_TOOK_CASH_PLAYER", sName, sOutput[2], iAmount);
			logevent_message_action("Admin took cash '%d' from", id, userid, iAmount);
			return 1;
		}
		if(equali(sOutput[1], "set"))
		{
			if(!cmd_access(id, level, cid, 0))
			{
				id ?
				cprint_chat(id, _, "%L", id, "COMMAND_NOACCESS") :
				server_print("%L", LANG_SERVER, "COMMAND_NOACCESS");
				return 1;
			}
			if(sOutput[2][0] == EOS)
			{
				id ?
				cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
				server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
				return 1;
			}

			new players[32], pnum;
			iAmount = str_to_num(sOutput[3]);

			if(!cmd_targets(id, sOutput[2], CMDTARGET_NO_BOTS|CMDTARGET_ALLOW_SELF, players, pnum))
			{
				if(!id)
				{
					server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
					return 1;
				}

				cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
				return 1;
			}
			if(!strlen(sOutput[3]) || !iAmount)
			{
				id ?
				cprint_chat(id, 'n', "%L", id, "CHAT_VALUE_ISMISSING") :
				server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
				return 1;
			}

			for(new i; i < pnum; i++)
			{
				jb_set_user_cash(players[ i ], iAmount);
			}

			get_user_name(id, sName, charsmax(sName));
			if(pnum > 1)
			{
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_SET_CASH_GROUP", sName, sOutput[2], iAmount);
				logevent_message(0, "Admin '%s' set cash '%d' to '%s'", sName, iAmount, sOutput[2]);
				return 1;
			}

			userid = players[ 0 ];
			get_user_name(userid, sOutput[2], charsmax(sOutput[]));
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_SET_CASH_PLAYER", sName, sOutput[2], iAmount);
			logevent_message_action("Admin set cash '%d' to", id, userid, iAmount);
			return 1;
		}

		if(sOutput[1][0] != EOS)
		{
			userid = cmd_target(id, sOutput[1], CMDTARGET_NO_BOTS & ~CMDTARGET_ALLOW_SELF);

			if(userid > 0)
			{
				get_user_name(userid, sOutput[2], charsmax(sOutput[]));

				if( id )
				{
					cprint_chat(id, 'n', "%L", id, "CHAT_CHECK_PLAYER_CASH", sOutput[2], user_cash[userid]);
					logevent_message_action("checked player cash '%d'", id, userid, user_cash[userid]);
					return 1;
				}

				server_print("%L", LANG_SERVER, "COMMAND_CHECK_PLAYER_CASH", sOutput[2], user_cash[userid]);
				return 1;
			}

			new iValue;
			switch( find_player_account(sOutput[1], iValue, id) )
			{
				case 1:
				{
					get_user_name(id, sName, charsmax(sName));

					if( id )
					{
						cprint_chat(id, 'n', "%L", id, "CHAT_CHECK_PLAYER_CASH", sOutput[1], iValue);
						logevent_message(0, "'%s' checked player '%s' cash '%d'", sName, sOutput[1], iValue);
						return 1;
					}

					server_print("%L", LANG_SERVER, "COMMAND_CHECK_PLAYER_CASH", sOutput[1], iValue);
					return 1;
				}
				case 2:
				{
					return 1;
				}
			}

			if(!id)
			{
				server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
				return 1;
			}

			cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND");
			return 1;
		}

		if(!id)
		{
			server_print("%L", LANG_SERVER, "COMMAND_MISSING_VALUE");
			return 1;
		}
		
		cprint_chat(id, 'n',"%L", id, "PLAYER_CHECK_CASH", user_cash[id]);
		logevent_message_action("checked his cash '%d'", id, 0, user_cash[id]);
		
		return 1;
	}

	if(g_iUserGagged[id] != 0)
	{
		client_cmd(id, "spk ^"barney/youtalkmuch.wav^"");
		client_print(id, print_center, "You talk too much!!!");
		return PLUGIN_HANDLED;
	}
	
	return 0;
}

cmd_targets(const id, const szArgs[], const flags=CMDTARGET_ALLOW_SELF|CMDTARGET_OBEY_IMMUNITY, targetlist[32], &targetcount=0)
{
	switch( szArgs[0] )
	{
		case '@':
		{
			new players[32], szFlags[6], num;
			
			if(flags & CMDTARGET_ONLY_ALIVE) add(szFlags, charsmax(szFlags), "a");
			if(flags & CMDTARGET_NO_BOTS) add(szFlags, charsmax(szFlags), "c");
			add(szFlags, charsmax(szFlags), "h");
			
			switch( szArgs[1] )
			{
				case 'C' , 'c', 'G', 'g': {
					add(szFlags, charsmax(szFlags), "e");
					get_players(players, num, szFlags, "CT");
				}
				case 'T' , 't', 'P', 'p': {
					add(szFlags, charsmax(szFlags), "e");
					get_players(players, num, szFlags, "TERRORIST");
				}
				case 'S' , 's': {
					add(szFlags, charsmax(szFlags), "e");
					get_players(players, num, szFlags, "SPECTATOR");
				}
				case 'A' , 'a': {
					get_players(players, num, szFlags);
				}
				default:
				{
					id ?
					cprint_chat(id, 'n', "%L", id, "CHAT_TARGET_NOT_FOUND") :
					server_print("%L", LANG_SERVER, "COMMAND_TARGET_NOT_FOUND");
					return 0;
				}
			}
			
			for(new i, player; i < num; i++)
			{
				player = players[i];
				if((!(flags & CMDTARGET_ALLOW_SELF) && player == id) ||
					((flags & CMDTARGET_OBEY_IMMUNITY) && get_user_flags(player) & ADMIN_IMMUNITY) )
				{
					players[i--] = players[--num];
					players[num] = 0;
				}
			}
			
			targetlist = players;
			targetcount = num;
		}
		default:
		{
			if((targetlist[0] = cmd_target(id, szArgs, flags)) > 0)
				targetcount = 1;
			else
				targetcount = 0;
		}
	}
	
	return targetcount;
}

str_explode(const string[], delimiter, output[][], output_size, output_len)
{
	new i, pos, len = strlen(string);
	
	do
	{
		pos += (copyc(output[i++], output_len, string[pos], delimiter) + 1);
	}
	while(pos < len && i < output_size)
	
	return i;
}

bool:Check_shop_available(id, bool:bMsg=false)
{
	if(g_lr_inprogress != -1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "LR_INPROGRESS");
		return false;
	}
	if(!check_flag(IsUserAlive,id))
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_NOT_ALIVE");
		return false;
	}
	
	return true;
}

shop_menu(id)
{
	if(!g_shop_items)
	{
		log_amx("There are no items in the API jailbreak shop.");
		return;
	}
	if(!Check_shop_available(id, true)) return;
	
	new sText[196], JBSmenu, sItemname[32], iItemcost, sData[3], uteam, iteam_team, sIteminfo[32];
	
	uteam = get_user_team(id);
	
	new iLen = formatex(sText, charsmax(sText), "%L", id, "SHOP_MENU_TITLE", user_cash[id]);

	if(g_fPlayerDiscount[id] > 0.0)
	{
		formatex(sText[iLen], charsmax(sText)-iLen, "^n\r%d%% \yDiscount!", floatround(g_fPlayerDiscount[id] * 100.0));
	}

	JBSmenu = menu_create(sText, "shop_menu_handle", true);
	
	new bitsum_day = (1<<(g_day_inprogress + 1)), iShopItemS, trie_count, xArray3[DAY_SHOP_ITEMS];
	
	static Trie:i_pTrie = Invalid_Trie;
	if(i_pTrie == Invalid_Trie) i_pTrie = g_pTrie_SHOP;
	
	for(new x, z, loop = ArraySize(g_iDayShopItems); x < loop; x++)
	{
		ArrayGetArray(g_iDayShopItems, x, xArray3);
		z = get_itemid_inarray_bystring(xArray3[ITEM_DAY_NAME], g_days_itemname);
		
		if(g_day_inprogress != z) continue;
		
		TrieSetArray(i_pTrie, xArray3[ITEM_SHOP_ITEM_NAME], xArray3, sizeof xArray3);
		trie_count++;
	}
	
	if(!trie_count)
	{
		TrieClear(i_pTrie);
	}
	
	for(new i, x, xArray4[XVAR_DATA], xArray_Limit[ITEM_LIMITATION_DATA], Limit_UserID, gfwReturn, iItemaccess, iDiscount; i < g_shop_items; i++)
	{
		if(!(bitsum_day & ArrayGetCell(g_shop_items_bitsumdays, i)))
		{
			continue;
		}
		
		iteam_team = ArrayGetCell(g_shop_items_team, i);
		
		ArrayGetString(g_shop_items_name, i, sItemname, charsmax(sItemname));
		ArrayGetString(g_shop_items_info, i, sIteminfo, charsmax(sIteminfo));
		iItemcost = ArrayGetCell(g_shop_items_cost, i);

		iItemaccess = ArrayGetCell(g_shop_items_access, i);
		TrieGetArray(g_trie_shop_item_limit, sItemname, xArray_Limit, sizeof xArray_Limit);
		
		sData[1] = 0;
		if(trie_count > 0)
		{
			if(TrieKeyExists(i_pTrie, sItemname))
			{
				sData[1] = any:i_pTrie;
				TrieGetArray(i_pTrie, sItemname, xArray3, sizeof xArray3);
				if(xArray3[ITEM_TEAM] != -1) iteam_team = xArray3[ITEM_TEAM];
				if(xArray3[ITEM_ACCESS] != -1) iItemaccess = xArray3[ITEM_ACCESS];
				if(xArray3[ITEM_NEWCOST][0] != EOS) iItemcost = str_to_num(xArray3[ITEM_NEWCOST]);
				if(xArray3[ITEM_SHOP_ITEM_INFO][0] != EOS) copy(sIteminfo, charsmax(sIteminfo), xArray3[ITEM_SHOP_ITEM_INFO]);
				if((x=xArray3[ITEM_SHOP_LIMITS][LIMIT_TIMES]) != -1)
				{
					xArray_Limit[LIMIT_TIMES] = x;
					arrayset(xArray_Limit[LIMIT_USER], xArray3[ITEM_SHOP_LIMITS][LIMIT_USER], sizeof xArray_Limit[LIMIT_USER]);
				}
				if((x=xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS]) != -1)
				{
					xArray_Limit[LIMIT_ROUNDS] = x;
					arrayset(xArray_Limit[LIMIT_ROUNDS_COUNTER], x, sizeof xArray_Limit[LIMIT_ROUNDS_COUNTER]);
				}
				if((x=xArray3[ITEM_SHOP_LIMITS][LIMIT_FOR_EVERYONE]) != -1) xArray_Limit[LIMIT_FOR_EVERYONE] = x;
				if(xArray3[ITEM_ARRAY_XVARS] != any:Invalid_Array)
				{
					x = ArraySize(xArray3[ITEM_ARRAY_XVARS]);
					while( x-- > 0 )
					{
						ArrayGetArray(xArray3[ITEM_ARRAY_XVARS], x, xArray4);
						
						switch( xArray4[XVAR_TYPE] )
						{
							case XVAR_TYPE_INTEGER, XVAR_TYPE_CHARS: 
							{
								if(get_xvar_num(xArray4[XVAR_ID]) != xArray4[XVAR_VALUE])
								{
									x = -99;
									break;
								}
							}
							case XVAR_TYPE_BITS:
							{
								if( (((get_xvar_num(xArray4[XVAR_ID]) & (1<<(id&31))) > 0) ? 1 : 0 ) != xArray4[XVAR_VALUE])
								{
									x = -99;
									break;
								}
							}
							case XVAR_TYPE_FLOAT:
							{
								if(get_xvar_float(xArray4[XVAR_ID]) != xArray4[XVAR_VALUE])
								{
									x = -99;
									break;
								}
							}
						}
					}
					
					if(x == -99)
					{
						continue;
					}
				}
			}
		}
		
		if(iteam_team != uteam && iteam_team != TEAM_ANY)
		{
			continue;
		}
		
		sData[0] = i+1;
		sData[2] = '^0';

		if((iDiscount = floatround( (float(iItemcost) * g_fPlayerDiscount[id]) )))
		{
			iItemcost -= iDiscount;
		}
		
		ExecuteForward(fw_shop_item_select_pre, gfwReturn, id, i);
		
		if(gfwReturn == JB_MENU_ITEM_DONT_SHOW)
		{
			continue;
		}
		
		Limit_UserID = (xArray_Limit[LIMIT_FOR_EVERYONE] > 0) ? 0 : id;
		
		if(gfwReturn == JB_MENU_ITEM_UNAVAILABLE)
		{
			formatex(sText, charsmax(sText), "%L", id, "SHOP_MENU_ITEM_UNAV", sItemname, sIteminfo, iItemcost);
			iItemaccess = ADMIN_NOACCESS;
		}
		else if(xArray_Limit[LIMIT_TIMES] > 0)
		{
			if(xArray_Limit[LIMIT_USER][Limit_UserID] <= 0)
			{
				formatex(sText, charsmax(sText), "%L", id, "SHOP_MENU_ITEM_LIMIT_REACHED", sItemname, sIteminfo, iItemcost, xArray_Limit[LIMIT_USER][Limit_UserID], xArray_Limit[LIMIT_TIMES], max(xArray_Limit[LIMIT_ROUNDS_COUNTER][Limit_UserID] + 1, 1));
				iItemaccess = ADMIN_NOACCESS;
			}
			else
			{
				user_cash[id] < iItemcost ? formatex(sText, charsmax(sText), "%L", id, "SHOP_M_ITEM_NOENFCASH_LIMIT", sItemname, sIteminfo, iItemcost, xArray_Limit[LIMIT_USER][Limit_UserID], xArray_Limit[LIMIT_TIMES]):formatex(sText, charsmax(sText), "%L", id, "SHOP_MENU_ITEM_LIMIT", sItemname, sIteminfo, iItemcost, xArray_Limit[LIMIT_USER][Limit_UserID], xArray_Limit[LIMIT_TIMES])
			}
		}
		else
		{
			user_cash[id] < iItemcost ? formatex(sText, charsmax(sText), "%L", id, "SHOP_MENU_ITEM_NOENF_CASH", sItemname, sIteminfo, iItemcost):formatex(sText, charsmax(sText), "%L", id, "SHOP_MENU_ITEM", sItemname, sIteminfo, iItemcost)
		}
		
		menu_additem(JBSmenu, sText, sData, iItemaccess);
		iShopItemS ++;
	}
	
	if(!iShopItemS)
	{
		if(g_day_inprogress > DAY_NONE) cprint_chat(id, _, "%L", id, "SHOP_MENU_EVENT_NOITEMS");
		menu_destroy(JBSmenu);
		return;
	}
	
	menu_setprop(JBSmenu, MPROP_PERPAGE, 5);
	menu_setprop(JBSmenu, MPROP_EXIT, MEXIT_ALL);
	
	menu_display(id, JBSmenu);
}

public shop_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT || !Check_shop_available(id, false))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}

	new paccess, sData[3], sName[64], iIndex;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), sName, charsmax(sName), iIndex);
	
	new sItemname[32], iItemcost, gfwReturn;
	menu_destroy(menu);
	iIndex = sData[0]-1;
	
	if(!((1<<(g_day_inprogress + 1)) & ArrayGetCell(g_shop_items_bitsumdays, iIndex)))
	{
		return PLUGIN_HANDLED;
	}
	
	new Trie:i_pTrie = Trie:sData[1], xArray3[DAY_SHOP_ITEMS], iteam_team, iItemaccess, Trie:trie_limits = g_trie_shop_item_limit;
	ArrayGetString(g_shop_items_name, iIndex, sItemname, charsmax(sItemname))
	
	new xArray_Limit[ITEM_LIMITATION_DATA], Limit_UserID = -1;
	
	if(TrieKeyExists(g_trie_shop_item_limit, sItemname))
	{
		TrieGetArray(g_trie_shop_item_limit, sItemname, xArray_Limit, sizeof xArray_Limit);
		
		Limit_UserID = (xArray_Limit[LIMIT_FOR_EVERYONE] > 0) ? 0 : id;
	}
	
	if(i_pTrie != Invalid_Trie && TrieKeyExists(i_pTrie, sItemname))
	{
		TrieGetArray(i_pTrie, sItemname, xArray3, sizeof xArray3);
		
		if((iItemaccess=xArray3[ITEM_ACCESS]) != -1)
		{
			if(!access(id, iItemaccess)) return PLUGIN_HANDLED;
		}
		if((iteam_team=xArray3[ITEM_TEAM]) != -1)
		{
			if(fm_get_user_team(id) != iteam_team && iteam_team != TEAM_ANY)
				return PLUGIN_HANDLED;
		}
		if(xArray3[ITEM_SHOP_LIMITS][LIMIT_FOR_EVERYONE] != -1)
		{
			Limit_UserID = (xArray3[ITEM_SHOP_LIMITS][LIMIT_FOR_EVERYONE] > 0) ? 0 : id;
		}
		if(xArray3[ITEM_SHOP_LIMITS][LIMIT_TIMES] != -1)
		{
			trie_limits = i_pTrie;

			if(Limit_UserID == -1)
			{
				Limit_UserID = 0;
			}

			xArray_Limit[LIMIT_ROUNDS_COUNTER][Limit_UserID] = xArray3[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER][Limit_UserID];
			xArray_Limit[LIMIT_USER][Limit_UserID] = xArray3[ITEM_SHOP_LIMITS][LIMIT_USER][Limit_UserID];
			xArray_Limit[LIMIT_TIMES] = xArray3[ITEM_SHOP_LIMITS][LIMIT_TIMES];
		}
	}
	
	if(xArray3[ITEM_NEWCOST][0] != EOS)
	{
		iItemcost = str_to_num(xArray3[ITEM_NEWCOST]);
	}
	else
	{
		iItemcost = ArrayGetCell(g_shop_items_cost, iIndex);
	}

	new iDiscount = floatround( (float(iItemcost) * g_fPlayerDiscount[id]) );

	if( iDiscount )
	{
		iItemcost -= iDiscount;
	}
	
	ExecuteForward(fw_shop_item_select_post, gfwReturn, id, iIndex);
	
	if(gfwReturn == JB_MENU_ITEM_UNAVAILABLE)
	{
		logevent_message_action("Couldn't buy '%s' Item is not available", id, 0, sItemname);
		cprint_chat(id, 'n', "%L", id, "SHOP_ITEM_NOT_AVAILABLE");
		return PLUGIN_HANDLED;
	}
	
	if(Limit_UserID > -1 && xArray_Limit[LIMIT_TIMES] > 0)
	{
		if(xArray_Limit[LIMIT_USER][Limit_UserID] <= 0)
		{
			logevent_message_action("Couldn't buy '%s' Item is out of stocks!", id, 0, sItemname);
			cprint_chat(id, 'n', "%L", id, "SHOP_ITEM_LIMIT_REACHED", max(xArray_Limit[LIMIT_ROUNDS_COUNTER][Limit_UserID],1))
			return PLUGIN_HANDLED;
		}
	}
	
	if(gfwReturn == JB_SHOP_ITEM_IGNORE_COST)
	{
		logevent_message_action("Got '%s' for free!", id, 0, sItemname);
		
		ExecuteForward(fw_shop_item_bought, g_fw_return, id, iIndex)
		cprint_chat(id, 'n', "%L", id, "SHOP_FREE_ITEM", sItemname)
		return PLUGIN_HANDLED;
	}
	
	if(user_cash[id] < iItemcost)
	{
		logevent_message_action("Couldn't Buy '%s' No enough cash!", id, 0, sItemname);
		cprint_chat(id, 'n', "%L", id, "SHOP_NO_ENOUGH_CASH");
		return PLUGIN_HANDLED;
	}
	
	ExecuteForward(fw_shop_item_bought, g_fw_return, id, iIndex);
	cprint_chat(id, 'n', "%L", id, "SHOP_ITEM_BOUGHT", sItemname, iItemcost);
	jb_set_user_cash(id, jb_get_user_cash(id)-iItemcost);
	
	logevent_message_action("Bought '%s'", id, 0, sItemname);
	
	if(Limit_UserID > -1)
	{
		if( trie_limits == g_trie_shop_item_limit )
		{
			xArray_Limit[LIMIT_USER][Limit_UserID] --;
			TrieSetArray(g_trie_shop_item_limit, sItemname, xArray_Limit, sizeof xArray_Limit );
		}
		else
		{
			new x, bool:bFound = false;
			for(new loop = ArraySize(g_iDayShopItems); x < loop; x++)
			{
				ArrayGetArray(g_iDayShopItems, x, xArray3);
				if(equal(xArray3[ITEM_SHOP_ITEM_NAME], sItemname))
				{
					bFound = true;
					break;
				}
			}
			
			if(bFound)
			{
				xArray3[ITEM_SHOP_LIMITS][LIMIT_USER][Limit_UserID]--;
				ArraySetArray(g_iDayShopItems, x, xArray3);
			}
		}
	}
	
	return PLUGIN_HANDLED;
}

// native register_jailbreak_shopitem(const name[], const info[], cost, team, const access=0, const bitsum_days=0)
public _register_jailbreak_shopitem(plugin, argc)
{
	if(argc != 6) return -2;
	
	new item_name[MAX_SHOPITEM_NAME_LENGTH], item_info[MAX_SHOPITEM_INFO_LENGTH], item_cost, item_team, item_bitsum_days
	get_string(1, item_name, charsmax(item_name));
	get_string(2, item_info, charsmax(item_info));
	item_cost = get_param(3);
	item_team = get_param(4);
	new item_access = get_param(5);
	item_bitsum_days = get_param(6);
	
	if(strlen(item_name) < 3)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item name is too short!", plugin, 1)
		return -1;
	}
	if(!(TEAM_ANY <= item_team <= TEAM_SPECTATOR))
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item team is not defined!", plugin, 4)
		return -1;
	}
	if(get_itemid_inarray_bystring(item_name, g_shop_items_name) > -1)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item with this name is already registered!", plugin, 1)
		return -1;
	}
	
	new szCost[32], szTeam[4],  szDay[4] = "YES", szFlags[22], szLimit[10];
	
	get_file_keyvalue(jb_shop_ini_file, item_name, "FLAGS", szFlags, charsmax(szFlags));
	item_access = read_flags(szFlags);
	
	get_file_keyvalue(jb_shop_ini_file, item_name, "INFO", item_info, charsmax(item_info));
	
	num_to_str(item_cost, szCost, charsmax(szCost))
	get_file_keyvalue(jb_shop_ini_file, item_name, "COST", szCost, charsmax(szCost));
	
	num_to_str(item_team, szTeam, charsmax(szTeam))
	get_file_keyvalue(jb_shop_ini_file, item_name, "TEAM", szTeam, charsmax(szTeam));
	
	get_file_keyvalue(jb_shop_ini_file, item_name, "DAY_NONE", szDay, charsmax(szDay));
	if(equali(szDay, "YES")) item_bitsum_days |= (1<<0);
	
	new xArray_Limit[ITEM_LIMITATION_DATA];
	
	num_to_str(0, szLimit, charsmax(szLimit));
	get_file_keyvalue(jb_shop_ini_file, item_name, "LIMIT", szLimit, charsmax(szLimit));
	arrayset(xArray_Limit[LIMIT_USER], (xArray_Limit[LIMIT_TIMES] = str_to_num(szLimit)), sizeof xArray_Limit[LIMIT_USER]);
	
	num_to_str(0, szLimit, charsmax(szLimit));
	get_file_keyvalue(jb_shop_ini_file, item_name, "LIMIT_ROUNDS", szLimit, charsmax(szLimit));
	arrayset(xArray_Limit[LIMIT_ROUNDS_COUNTER], (xArray_Limit[LIMIT_ROUNDS] = str_to_num(szLimit)), sizeof xArray_Limit[LIMIT_ROUNDS_COUNTER]);

	num_to_str(0, szLimit, charsmax(szLimit));
	get_file_keyvalue(jb_shop_ini_file, item_name, "LIMIT_PER_USER", szLimit, charsmax(szLimit));
	xArray_Limit[LIMIT_FOR_EVERYONE] = !str_to_num(szLimit) ? true:false;
	
	TrieSetArray(g_trie_shop_item_limit, item_name, xArray_Limit, sizeof xArray_Limit);
	
	ArrayPushString(g_shop_items_name, item_name)
	ArrayPushString(g_shop_items_info, item_info)
	ArrayPushCell(g_shop_items_cost, str_to_num(szCost))
	ArrayPushCell(g_shop_items_team, str_to_num(szTeam))
	ArrayPushCell(g_shop_items_bitsumdays, item_bitsum_days)
	ArrayPushCell(g_shop_items_access, item_access)
	
	g_shop_items ++
	return g_shop_items-1
}

// jb_get_shop_items_registered()
public _get_shop_items_registered(plugin, argc)
{
	return g_shop_items;
}

// jb_update_shop_item(itemid, const newname[], const newinfo[], const newcost, const newaccess, const newteam[], const newbitsumdays)
public _update_shop_item(plugin, argc)
{
	new itemid = get_param(1);
	
	if(!(0 <= itemid < g_shop_items))
	{
		log_error(AMX_ERR_NATIVE, "Native Error itemid is not valid!")
		return -1;
	}
	
	new name[MAX_SHOPITEM_NAME_LENGTH], info[MAX_SHOPITEM_INFO_LENGTH];
	get_string(2, name, charsmax(name))
	get_string(3, info, charsmax(info))
	new cost = get_param(4);
	new paccess = get_param(5);
	new team = get_param(6);
	new item_bitsdays = get_param(7);
	
	if(strlen(name) > 0)
	{
		new xLimits[ITEM_LIMITATION_DATA], szOldName[MAX_SHOPITEM_NAME_LENGTH];
		ArrayGetString(g_shop_items_name, itemid, szOldName, charsmax(szOldName));
		TrieGetArray(g_trie_shop_item_limit, szOldName, xLimits, sizeof xLimits);
		ArraySetString(g_shop_items_name, itemid, name);
		TrieSetArray(g_trie_shop_item_limit, name, xLimits, sizeof xLimits);
		TrieDeleteKey(g_trie_shop_item_limit, szOldName);
	}
	if(strlen(info) > 0)
		ArraySetString(g_shop_items_info, itemid, info);
	if(cost > -1)
		ArraySetCell(g_shop_items_cost, itemid, cost);
	if(paccess > -1)
		ArraySetCell(g_shop_items_access, itemid, paccess);
	if(TEAM_SPECTATOR >= team >= TEAM_ANY)
		ArraySetCell(g_shop_items_team, itemid, team);
	if(item_bitsdays > -1)
		ArraySetCell(g_shop_items_bitsumdays, itemid, item_bitsdays);
	
	return 0;
}

// native jb_set_user_cash(index, amount)
public _set_user_cash(plugin, argc) jb_set_user_cash(get_param(1), get_param(2));
jb_set_user_cash(id, amount)
{
	if(!is_user_connected(id) && !is_user_connecting(id))
	{
		log_error(AMX_ERR_NATIVE, "Native Error user id is not (valid/connected)!");
		return -1;
	}
	
	// ignore if the id of the player is a bot or hltv.
	if(is_user_bot(id) || is_user_hltv(id)) return 0;
	
	user_cash[id] = amount;
	
	const MONEY_DISPLAY_ADDITION = 1;
	message_begin(MSG_ONE, g_msgMoney, _, id);
	write_long(amount);
	write_byte(MONEY_DISPLAY_ADDITION);
	message_end();
	
	new szFlags[4];
	get_pcvar_string(g_iCvar_identity[CVAR_SAVE_CASH_EVENT], szFlags, charsmax(szFlags));
	if(read_flags("c") & read_flags(szFlags))
	{
		save_user_cash(id);
	}
	
	return 1
}

// native jb_get_user_cash(index)
public _get_user_cash(plugin, argc) return jb_get_user_cash(get_param(1));
jb_get_user_cash(id)
{
	if(!is_user_connected(id) && !is_user_connecting(id))
	{
		log_error(AMX_ERR_NATIVE, "Native Error user id is not (valid/connected)!");
		return -1;
	}
	
	return user_cash[id];
}

// native jb_set_user_discount(index, Float:amount)
public _set_user_discount(plugin, argc) return jb_set_user_discount(get_param(1), get_param_f(2));
jb_set_user_discount(id, Float:fAmount)
{
	if(!is_user_connected(id) && !is_user_connecting(id))
	{
		log_error(AMX_ERR_NATIVE, "Native Error user id is not (valid/connected)!");
		return -1;
	}

	g_fPlayerDiscount[id] = floatclamp(fAmount, 0.0, 1.0);
	return 1;
}

// native jb_get_user_discount(index)
public Float:_get_user_discount(plugin, argc) return jb_get_user_discount(get_param(1));
Float:jb_get_user_discount(id)
{
	if(!is_user_connected(id) && !is_user_connecting(id))
	{
		log_error(AMX_ERR_NATIVE, "Native Error user id is not (valid/connected)!")
		return -1.0
	}

	return g_fPlayerDiscount[id];
}

public _end_theday()
{
	if(g_day_inprogress != JB_DAY_CAGEDAY)
	{
		new gfwReturn;
		ExecuteForward(fw_day_end, gfwReturn, g_day_inprogress);
		
		if(gfwReturn >= JB_HANDLED) return;
		
		if(g_day_inprogress > DAY_NONE)
		{
			new sDayname[64];
			ArrayGetString(g_days_itemname, g_day_inprogress, sDayname, charsmax(sDayname));
			logevent_message(0, "Specialday '%s' has ended!", sDayname);
			log_amx("JAILBREAK Terminating specialday %s !", sDayname);
		}
		
		ExecuteForward(fw_day_ended, gfwReturn, g_day_inprogress);
		
		if(g_day_inprogress == JB_DAY_VOTEDAY)
		{
			remove_task(TASK_VOTEDAY_TIMER);

			new players[32], player, pnum;
			get_players(players, pnum, "h");

			for(new i, menu, newmenu, iPage; i < pnum; i++)
			{
				player = players[i];
				if(check_flag(g_has_avotedaymenu,player))
				{
					if(player_menu_info(player, menu, newmenu, iPage))
					{
						if(newmenu != -1)
						{
							menu_cancel(player);
						}

						show_menu(player, 0, " ^n ", -1);
					}
				}

				set_user_godmode(player, check_flag(g_user_has_godmode,player) ? 1:0);
				set_entity_flags(player, FL_FROZEN, 0);
			}
		}

		g_day_inprogress = JB_DAY_CAGEDAY;
		FUNDAY_TIMER_LENGTH = 0.0;
		
		arrayset(g_user_wpns_blocked, 0, sizeof g_user_wpns_blocked);

		for(new i = 1; i <= MAX_PLAYERS; i++)
		{
			if(g_bUser_allies_HasBoundVar[i])
			{
				set_xvar_num(g_iUser_allies[i], JB_ALLIES_DEFAULT);
			}
			else
			{
				g_iUser_allies[i] = JB_ALLIES_DEFAULT;
			}

			if(g_bUser_enemies_HasBoundVar[i])
			{
				set_xvar_num(g_iUser_enemies[i], JB_ALLIES_DEFAULT);
			}
			else
			{
				g_iUser_enemies[i] = JB_ALLIES_DEFAULT;
			}
		}
		
		if( !get_prisonersnum(FLAG_ALIVE_ONLY) || !get_guardsnum(FLAG_ALIVE_ONLY) )
		{
			if(!bHAS_ROUND_ENDED && !bHAS_ROUND_ENDING)
			{
				bHAS_ROUND_ENDING = true;
				g_WinnerTeam = TeamWinning_None;

				static const Float:ROUND_TIME_LEFT = 5.0;
				// end round if both teams or one of them have been exterminated during the event!
				remove_task(TASK_END_ROUND);
				set_task(ROUND_TIME_LEFT, "task_end_the_round", TASK_END_ROUND);
				set_roundtime_hud( floatround(ROUND_TIME_LEFT) );
			}
		}
	}
}

set_roundtime_hud(const iValue)
{
	static g_iUserMsg_RoundTime = 0;
	if(!g_iUserMsg_RoundTime) g_iUserMsg_RoundTime = get_user_msgid("RoundTime");
	message_begin(MSG_ALL, g_iUserMsg_RoundTime, _, 0);
	write_short(iValue);
	message_end();
}

bool:Check_day_available(id=0, bool:msg=false)
{
	if( !(0 <= id <= g_iMaxplayers) )
	{
		return false;
	}
	if(g_day_inprogress > JB_DAY_CAGEDAY)
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "DAY_INPROGRESS");
		return false;
	}
	if(g_day_inprogress == JB_DAY_VOTEDAY)
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "VOTEDAY_INPROGRESS");
		return false;
	}
	if(g_lr_inprogress != JB_LR_DEACTIVATED)
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "LR_INPROGRESS");
		return false;
	}
	if( get_prisonersnum(FLAG_ALIVE_ONLY) < SPECIALDAY_INMATES_REQUIREMENT )
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "DAY_REQUIRES");
		return false;
	}
	return true;
}

public votedays_menu_timer(Taskid)
{
	if(VOTEDAY_TIMER_LENGTH >= 0)
	{
		new players[32], pnum, player, iPage, menu, newmenu;
		get_players(players, pnum, "ch");
		
		for(new i = 0; i < pnum; i++)
		{
			player = players[i];
			
			if(check_flag(g_has_avotedaymenu,player))
			{
				if(player_menu_info(player, menu, newmenu, iPage))
				{
					if(newmenu != -1)
					{
						menu_cancel(player);
					}
				}

				votedays_menu(player, iPage);
			}
		}
		
		VOTEDAY_TIMER_LENGTH--;
	}
	else
	{
		remove_task(Taskid)
		
		new votes_bigger, votes, bigger, iLoops = MAX_VOTEDAYS;
		
		if(iLoops > g_days_items)
		{
			iLoops = g_days_items;
		}
		
		for(new i = 1; i < iLoops; i++)
		{
			votes = g_votedays_vote[i];
			votes_bigger = g_votedays_vote[bigger];
			
			if(votes_bigger < votes)
			{
				bigger = i;
			}
		}
		
		new chosen_day = g_votedays_chosen[bigger];
		new sDayname[MAX_DAYITEM_NAME_LENGTH];
		ArrayGetString(g_days_itemname, chosen_day, sDayname, charsmax(sDayname))
		
		new players[32], pnum;
		get_players(players, pnum, "h");
		
		for(new i, menu, newmenu, iPage; i < pnum; i++)
		{
			bigger = players[i];
			if(check_flag(g_has_avotedaymenu,bigger))
			{
				if(player_menu_info(bigger, menu, newmenu, iPage))
				{
					if(newmenu != -1)
					{
						menu_cancel(bigger);
					}

					show_menu(bigger, 0, "^n ", -1);
				}
			}
			
			set_entity_flags(bigger, FL_FROZEN, 0);
		}
		
		VOTEDAY_TIMER_LENGTH = clamp(get_pcvar_num(g_iCvar_identity[CVAR_VDAY_TIMER2]),-1,60);
		cprint_chat(0, _, "%L", LANG_PLAYER, "VOTEDAY_CHOSEN_DAY", sDayname, sDayname);
		if(VOTEDAY_TIMER_LENGTH > -1)
			set_task(1.0, "chosen_voteday", chosen_day+TASK_VOTEDAY_TIMER, sDayname, sizeof sDayname, "b");
		else
			chosen_voteday(sDayname, chosen_day+TASK_VOTEDAY_TIMER);
		logevent_message(.szMessage="Voteday has finished!");
	}
}

public chosen_voteday(const sParam[], taskid)
{
	if(g_day_inprogress != VOTE_DAY)
	{
		new plyrs[32], pnum;
		get_players(plyrs, pnum, "ah")
	
		for(new i = 0, player; i < pnum; i++)
			{
				player = plyrs[i];
				set_user_godmode(player, check_flag(g_user_has_godmode,player) ? 1:0);
			}
		remove_task(taskid);
		return;
	}
	
	if(VOTEDAY_TIMER_LENGTH >= 0)
	{
		client_print(0, print_center, "%L", LANG_PLAYER, "CENTER_VOTEDAY_STARTS", sParam, VOTEDAY_TIMER_LENGTH)
		VOTEDAY_TIMER_LENGTH--;
		return;
	
	}
	
	remove_task(taskid);
	
	new plyrs[32], pnum;
	get_players(plyrs, pnum, "ah");
	
	for(new i = 0, player; i < pnum; i++)
		{
			player = plyrs[i];
			set_user_godmode(player, check_flag(g_user_has_godmode,player) ? 1:0);
		}
	
	// iDayid = taskid - TASK_VOTEDAY_TIMER;
	start_theday( (taskid - TASK_VOTEDAY_TIMER) );
}

public votedays_menu(id, iPage)
{
	if(VOTEDAY_TIMER_LENGTH <= -1)
	{
		return;
	}
	
	new sText[96];
	
	formatex(sText, charsmax(sText), "\r[ \yJailbreak \r] %L", id, "VOTEDAY_MENU", VOTEDAY_TIMER_LENGTH);
	if(!check_flag(g_votedays_voted,id)) format(sText, charsmax(sText), "%s^n%L", sText, id, "VOTEDAY_MENU_CHOOSEDAY");
	new iMenu = menu_create(sText, "votedays_menu_handle");
	
	new sItem[32], iAccess, sData[4];
	
	new gloop = MAX_VOTEDAYS, iDayid;
	
	if(gloop > g_days_items)
	{
		gloop = g_days_items;
	}
	
	new players[32], pnum;
	get_players(players, pnum, "ch");
	
	new voters, AdminVoteWeight = get_pcvar_num(g_iCvar_identity[CVAR_VDAY_ADMIN_EXVOTE]) + 1, iDaysForVote = 0;
	for(new x, player; x < pnum; x++)
	{
		player = players[x];
		if(check_flag(g_votedays_voted,player))
		{
			voters += (is_user_admin(player) && AdminVoteWeight > 1) ? AdminVoteWeight : 1;
		}
	}
	
	for(new i, vote_percent, gfwReturn; i < gloop; i++)
	{
		iDayid = g_votedays_chosen[i];

		if(iDayid <= DAY_NONE)
		{
			continue;
		}

		vote_percent = floatround(min(g_votedays_vote[i],voters) * 100.0 / max(voters, 1));
		
		ArrayGetString(g_days_itemname, iDayid, sItem, charsmax(sItem));
		iAccess = ArrayGetCell(g_days_itemaccess, iDayid);
		
		ExecuteForward(fw_day_preselected, gfwReturn, id, iDayid, iAccess);
		
		switch( gfwReturn )
		{
			case JB_MENU_ITEM_DONT_SHOW: continue;
			case JB_MENU_ITEM_UNAVAILABLE:
			{
				formatex(sText, charsmax(sText), "\d%s       (~ %d%% ~)", sItem, vote_percent);
				iAccess = ADMIN_NOACCESS;
			}
			default: formatex(sText, charsmax(sText), "\r%s       \y(~ %d%% ~)", sItem, vote_percent);
		}
		
		num_to_str(iDayid, sData, charsmax(sData));
		menu_additem(iMenu, sText, sData, iAccess);
		iDaysForVote++;
	}

	if(iDaysForVote == 0)
	{
		menu_destroy(iMenu);
		return;
	}
	
	menu_display(id, iMenu, iPage);
	set_flag(g_has_avotedaymenu,id);
}

public votedays_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT || !task_exists(TASK_VOTEDAY_TIMER))
	{
		remove_flag(g_has_avotedaymenu,id);
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sDayname[MAX_DAYITEM_NAME_LENGTH], sData[4];
	new iAccess, iCallback;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sDayname, charsmax(sDayname), iCallback);
	
	new oldmenu, newmenu, iPage
	player_menu_info(id, oldmenu, newmenu, iPage);
	
	if(contain(sDayname, "\d") != -1)
	{
		menu_destroy(menu);
		votedays_menu(id, iPage);
		return PLUGIN_HANDLED;
	}
	
	new dayid = str_to_num(sData), gfwReturn;
	
	ExecuteForward(fw_day_postselected, gfwReturn, id, dayid, iAccess)
	
	if(gfwReturn == JB_MENU_ITEM_UNAVAILABLE)
	{
		menu_destroy(menu);
		votedays_menu(id, iPage)
		return PLUGIN_HANDLED;
	}
	
	if(!check_flag(g_votedays_voted,id))
	{
		set_flag(g_votedays_voted,id);
		new AdminVoteWeight = get_pcvar_num(g_iCvar_identity[CVAR_VDAY_ADMIN_EXVOTE]), sName[32];
		g_votedays_vote[item] += (is_user_admin(id) && AdminVoteWeight++) ? AdminVoteWeight : 1;
		
		get_user_name(id, sName, charsmax(sName));
		ArrayGetString(g_days_itemname, dayid, sDayname, charsmax(sDayname));
		logevent_message_action("has voted for '%s'", id, 0, sDayname);
		
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "VOTEDAY_PLAYER_VOTED", sName, sDayname);
		
		// Destroy the menu !?!?
		menu_destroy(menu);

		new players[32], pnum, player;
		get_players(players, pnum, "ch");
		
		for(new i = 0; i < pnum; i++)
		{
			player = players[i];
			
			if(check_flag(g_has_avotedaymenu,player))
			{
				if(player_menu_info(player, oldmenu, newmenu, iPage))
				{
					if(newmenu != -1)
					{
						menu_cancel(player);
					}
				}

				votedays_menu(player, iPage);
			}
		}
	}
	else
	{
		menu_destroy(menu);
		client_print(id, print_center, "%L", id, "CENTER_CANT_VOTE_TWICE");
		votedays_menu(id, iPage);
	}
	
	return PLUGIN_HANDLED;
}

public days_menu(id)
{
	if(!Check_day_available(id, true))
	{
		return;
	}
	if(!is_user_admin(id))
	{
		cprint_chat(id, 'n', "%L", id, "MENU_NOACCESS");
		return;
	}
	
	new iMenu = menu_create("\r[ \yJailbreak \r]  \wDay's", "days_menu_handle");
	
	new sItem[64], iAccess, sData[4], iDaysCount;
	
	for(new i, iReturn; i < g_days_items; i++)
	{
		iAccess = ArrayGetCell(g_days_itemaccess, i);
		
		ExecuteForward(fw_day_preselected, iReturn, id, i, iAccess);
		
		switch( iReturn )
		{
			case JB_MENU_ITEM_DONT_SHOW: continue;
			case JB_MENU_ITEM_UNAVAILABLE:
			{
				ArrayGetString(g_days_itemname, i, sItem, charsmax(sItem));
				format(sItem, charsmax(sItem), "\d%s", sItem);
				iAccess = ADMIN_NOACCESS;
			}
			default: ArrayGetString(g_days_itemname, i, sItem, charsmax(sItem));
		}
		
		num_to_str(i, sData, charsmax(sData));
		menu_additem(iMenu, sItem, sData, iAccess);
		iDaysCount++;
	}

	if(!iDaysCount)
	{
		menu_destroy(iMenu);
		return;
	}
	
	menu_display(id, iMenu);
}

public days_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	if(!Check_day_available(.msg=true))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}

	new sDayname[MAX_DAYITEM_NAME_LENGTH], sData[4];
	new iAccess, iCallback;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sDayname, charsmax(sDayname), iCallback);
	
	menu_destroy(menu);
	
	if(contain(sDayname, "\d") != -1)
	{
		days_menu(id);
		return PLUGIN_HANDLED;
	}
	
	new dayid = str_to_num(sData), gfwReturn;
	
	ExecuteForward(fw_day_postselected, gfwReturn, id, dayid, iAccess);
	
	if(gfwReturn == JB_MENU_ITEM_UNAVAILABLE)
	{
		days_menu(id);
		return PLUGIN_HANDLED;
	}
	
	new sAdminname[32];
	get_user_name(id, sAdminname, charsmax(sAdminname));
	cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_START_ASPECIFIED_DAY", sAdminname, sDayname);
	
	logevent_message_action("Started a specialday '%s'",id, 0, sDayname);
	
	start_theday(dayid);
	
	return PLUGIN_HANDLED;
}

public task_day_length(taskid)
{
	if(FUNDAY_TIMER_LENGTH <= 0.0)
	{
		remove_task(taskid);
		_end_theday();
		
		return;
	}
	
	FUNDAY_TIMER_LENGTH -= 1.0;
}

// native jb_get_days_registered()
public _get_days_registered(plugin, argc)
{
	return g_days_items;
}

// native jb_get_dayid_byname(const dayname[])
public _get_dayid_byname(plugin, argc)
{
	new sDayname[MAX_DAYITEM_NAME_LENGTH];
	get_string(1, sDayname, charsmax(sDayname));
	
	return (get_itemid_inarray_bystring(sDayname, g_days_itemname));
}

// native jb_get_day_name(iDayid, sName[], iLen)
public _get_day_name(plugin, argc)
{
	new iDayid = get_param(1)
	
	if(0 > iDayid || g_days_items <= iDayid)
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Day id #%d", iDayid)
		return 0;
	}
	
	new sDayname[MAX_DAYITEM_NAME_LENGTH];
	ArrayGetString(g_days_itemname, iDayid, sDayname, charsmax(sDayname));
	set_string(2, sDayname, get_param(3));
	
	return 1;
}

// native get the day length time
public Float:_get_day_length(plugin, argc)
{
	return Float:ArrayGetCell(g_days_itemlength, get_param(1));
}

// native set the day length time
public _set_day_length(plugin, argc)
{
	new dayid = get_param(1);
	
	if(!(0 <= dayid < g_days_items))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Day id")
		return;
	}
	
	new Float:fLength = get_param_f(2);
	ArraySetCell(g_days_itemlength, dayid, fLength);

	if(g_day_inprogress == dayid)
	{
		FUNDAY_TIMER_LENGTH = fLength;

		if(fLength > 0.0)
		{
			if(!task_exists(TASK_DAY_LENGTH))
			{
				set_task(1.0, "task_day_length", TASK_DAY_LENGTH, _, _, "b");
			}
		}
		else
		{
			remove_task(TASK_DAY_LENGTH);
		}
	}
}

// native jb_start_theday(iDayid)
public _start_theday(plugin, argc)
{
	new dayid = get_param(1);
	if(!(0 <= dayid < g_days_items) && dayid != VOTE_DAY)
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Day id #%d", dayid);
		return -1;
	}
	
	if(g_day_inprogress > -1)
	{
		log_error(AMX_ERR_NATIVE, "Error: There is already a day started!");
		return -1;
	}
	
	return start_theday(dayid);
}

PrepareVotedayMenu()
{
	if(!g_days_items)
	{
		return;
	}

	new gloop = MAX_VOTEDAYS, iSpecialdaysCount;

	if(gloop > g_days_items)
	{
		gloop = g_days_items;
	}

	new Array:VDays = ArrayCreate(1, 1);

	for(new i = 0, iGuardsNum = get_guardsnum(); i < g_days_items; i++)
	{
		if( !iGuardsNum )
		{
			if( ArrayGetCell(g_days_dayendtype, i) == DAY_GUARDS_VS_PRISONERS )
			{
				continue;
			}
		}

		ArrayPushCell(VDays, i);
		iSpecialdaysCount++;
	}

	new VDChosen;
	arrayset(g_votedays_chosen, -1, sizeof g_votedays_chosen);
	arrayset(g_votedays_vote, -1, sizeof g_votedays_vote);

	iSpecialdaysCount = min(iSpecialdaysCount, gloop);

	for(new i = 0; i < iSpecialdaysCount; i++)
	{
		VDChosen = random(ArraySize(VDays));
		g_votedays_chosen[i] = ArrayGetCell(VDays, VDChosen);
		ArrayDeleteItem(VDays, VDChosen);
		g_votedays_vote[i] = 0;
	}

	ArrayDestroy(VDays);
}

start_theday(iDayid)
{
	new gfwReturn;
	ExecuteForward(fw_day_start, gfwReturn, iDayid);
	
	if(gfwReturn >= JB_HANDLED)
	{
		_end_theday();
		return 0;
	}
	
	g_day_inprogress = iDayid;

	if( iDayid > DAY_NONE )
	{
		for(new i = 1, DayEndType = ArrayGetCell(g_days_dayendtype, iDayid); i <= MAX_PLAYERS; i++)
		{
			if(g_bUser_allies_HasBoundVar[i])
			{
				set_xvar_num(g_iUser_allies[i], JB_ALLIES_DEFAULT);
			}
			else
			{
				g_iUser_allies[i] = JB_ALLIES_DEFAULT;
			}

			if(g_bUser_enemies_HasBoundVar[i])
			{
				switch( DayEndType )
				{
					case DAY_ONE_SURVIVOR: set_xvar_num(g_iUser_enemies[i], JB_ENEMIES_EVERYONE);
					default: set_xvar_num(g_iUser_enemies[i], JB_ENEMIES_DEFAULT);
				}
			}
			else
			{
				switch( DayEndType )
				{
					case DAY_ONE_SURVIVOR: g_iUser_enemies[i] = JB_ENEMIES_EVERYONE;
					default: g_iUser_enemies[i] = JB_ENEMIES_DEFAULT;
				}
			}
		}

		new sDayname[MAX_DAYITEM_NAME_LENGTH];
		ArrayGetString(g_days_itemname, iDayid, sDayname, charsmax(sDayname));

		logevent_message(0, "Specialday '%s' has started!", sDayname);

		new Float:fLength = ArrayGetCell(g_days_itemlength, iDayid);

		if(fLength > 0.0)
		{
			FUNDAY_TIMER_LENGTH = fLength;
			remove_task(TASK_DAY_LENGTH);
			set_task(1.0, "task_day_length", TASK_DAY_LENGTH, _, _, "b");
		}

		log_amx("JAILBREAK Initiating specialday %s | Length : %d seconds!", sDayname, floatround(fLength));
	}
	else if(iDayid == VOTE_DAY)
	{
		PrepareVotedayMenu();

		new players[32], pnum, player;
		get_players(players, pnum, "h");

		g_votedays_voted = 0;
		VOTEDAY_TIMER_LENGTH = get_pcvar_num(g_iCvar_identity[CVAR_VDAY_TIMER]);

		for(new i = 0; i < pnum; i++)
		{
			player = players[i];

			if(check_flag(IsUserAlive,player))
			{
				remove_flag(g_user_has_godmode,player);
				if(pev_valid(player) && get_user_godmode(player)) set_flag(g_user_has_godmode,player);
				set_user_godmode(player, 1);
			}

			if(!is_user_bot(player))
			{
				votedays_menu(player, 0);
			}
		}

		if(get_pcvar_num(g_iCvar_identity[CVAR_FREEZE_PLAYERS_ONVOTEDAY]) > 0)
		{
			get_players(players, pnum, "ah");

			for(new i = 0; i < pnum; i++)
			{
				set_entity_flags(players[i], FL_FROZEN, 1);
			}
		}

		logevent_message(.szMessage="Specialdays vote has begin!");

		remove_task(TASK_VOTEDAY_TIMER);
		set_task(1.0, "votedays_menu_timer", TASK_VOTEDAY_TIMER, _, _, "b");
	}

	ExecuteForward(fw_day_started, gfwReturn, iDayid);
	return 1;
}

// native register_jailbreak_day(const name[], iAccess, Float:fDay_Length=0.0, const Day_End)
public _register_jailbreak_day(plugin, argc)
{
	if(argc != 4)
	{
		log_error(AMX_ERR_NATIVE, "Error: Arguments doesn't match!")
		return -2;
	}
	
	new sItem[MAX_DAYITEM_NAME_LENGTH], iAccess, Float:fLength;
	get_string(1, sItem, charsmax(sItem));
	iAccess = get_param(2);
	fLength = get_param_f(3);
	
	if(strlen(sItem) < 3)
	{
		formatex(sItem, charsmax(sItem), "Error : Invalid day name (PLUGIN : %d | ARGC : %d)!", plugin, argc)
		log_error(AMX_ERR_NATIVE, sItem);
		return -1;
	}
	
	ArrayPushString(g_days_itemname, sItem);
	ArrayPushCell(g_days_itemaccess, iAccess);
	ArrayPushCell(g_days_itemlength, fLength);
	ArrayPushCell(g_days_dayendtype, Day_EndType:get_param(4));
	
	g_days_items++;
	return g_days_items-1;
}

// native jb_block_user_weapons(const id, bool:block, bitsum_wpns(allowed/disallowed))
public _block_user_weapons(plugin, argc)
{
	new id = get_param(1);
	
	if(!(1 <= id <= g_iMaxplayers))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid user-id #%d", id)
		return;
	}
	
	new szWpnname[32], bitsum_wpns = get_param(3);
	
	if(get_param(2))
	{
		for(new i = CSW_P228; i <= CSW_P90; i++)
		{
			if((player_flag(i) & bitsum_wpns) || bitsum_wpns == 0)
			{
				if(get_weaponname(i, szWpnname, charsmax(szWpnname)))
				{
					set_flag(g_user_wpns_blocked[id],i);
					if(is_user_alive(id)) ham_strip_weapon(id, szWpnname);
				}
			}
		}
	}
	else
	{
		if(!bitsum_wpns)
		{
			g_user_wpns_blocked[id] = 0
		}
		else
		{
			g_user_wpns_blocked[id] &= ~bitsum_wpns;
		}
	}
}

// native jb_is_user_weapons_blocked(const id, bitsum_wpns)
public _is_user_weapons_blocked(plugin, argc)
{
	new id = get_param(1)
	
	if(!(0 < id <= g_iMaxplayers))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid user-id #%d", id)
		return -1;
	}
	
	new wpns_not_blocked = ~g_user_wpns_blocked[id];
	new bitsum_wpns = get_param(2)
	
	if(!bitsum_wpns)
	{
		return wpns_not_blocked;
	}
	
	return ((g_user_wpns_blocked[id] & bitsum_wpns) == bitsum_wpns) ? 0:wpns_not_blocked;
}

// native jb_cells(JB_CELLS_STATE:state)
public _cells(plugin, argc)
{
	return jb_cells(JB_CELLS_STATE:get_param(1));
}

jb_cells(const JB_CELLS_STATE:iState)
{
	switch( iState )
	{
		case JB_CELLS_OPEN: g_cells_iState = JB_CELLS_CLOSE;
		case JB_CELLS_CLOSE: g_cells_iState = JB_CELLS_OPEN;
		case JB_CELLS_ENTITY_INDEX: return CELLS_BUTTON;
	}
	
	if(CELLS_BUTTON >= 0)
	{
		if(iState == JB_CELLS_OPEN)
		{
			ExecuteHamB(Ham_Use, CELLS_BUTTON, 0, 0, USE_ON, 0.0);
		}
		else
		{
			new iEnt = -1, szValue[64];
			pev(CELLS_BUTTON, pev_target, szValue, charsmax(szValue));

			while( (iEnt = find_ent_by_tname(iEnt, szValue)) > 0 )
			{
				ExecuteHamB(Ham_CS_Restart, iEnt);
			}
		}
		
		return CELLS_BUTTON;
	}
	
	new iEnt = -1;
	while( (iEnt = engfunc(EngFunc_FindEntityByString, iEnt, "classname", "func_door")) > 0)
	{
		if(iState == JB_CELLS_OPEN)
		{
			ExecuteHamB(Ham_Use, iEnt, 0, 0, 1, 1.0);
		}
		else
		{
			ExecuteHamB(Ham_CS_Restart, iEnt);
		}
	}
	
	return -1;
}

stock get_itemid_inarray_bystring(const info[], Array:array_name, bool:Equali=true)
{
	for(new itemname[64], maxloop = ArraySize(array_name), i = 0; i < maxloop; i++)
	{
		ArrayGetString(array_name, i, itemname, charsmax(itemname));
		
		switch( Equali )
		{
			case false: if(containi(itemname, info) > -1) return i;
			case true: if(equali(itemname, info)) return i;
		}
	}
	return -1;
}

// native register_jailbreak_class(const name[], const playermodel[], const priweapons[], const secweapons[], const flag=0, const team, const vknife[], const pknife[], const knifesounds[], const playerMDLBody=0, const playerMDLSkin=0)
public _create_class(pluginid, argc)
{
	if(argc != 9)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | Arguments: %d/9 are not what expected!", pluginid, argc) 
		return -1;
	}
	
	new xArray[CLASSES_DATA], szFlags[32], szSkin[4], szBody[4];
	get_string(1, xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]));
	get_string(2, xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]));
	get_string(3, xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]));
	get_string(4, xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]));
	get_flags(get_param(5), szFlags, charsmax(szFlags));
	copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), SZTEAMS[clamp(get_param(6), TEAM_ANY, TEAM_SPECTATOR)]);
	get_string(7, xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]));
	get_string(8, xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]));
	get_string(9, xArray[CLASS_KNIFE_SOUNDS], charsmax(xArray[CLASS_KNIFE_SOUNDS]));
	xArray[CLASS_MODEL_BODY] = get_param(10);
	xArray[CLASS_MODEL_SKIN] = get_param(11);
	
	new bool:bDefaultVKnife = false, bool:bDefaultPKnife = false;
	if(xArray[CLASS_V_KNIFE_MDL][0] == 0)
	{
		copy(xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]), default_vknife_model);
		bDefaultVKnife = true;
	}
	if(xArray[CLASS_P_KNIFE_MDL][0] == 0)
	{
		copy(xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]), default_pknife_model);
		bDefaultPKnife = true;
	}
	
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_MODEL], xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_MDL_SKIN], szSkin, charsmax(szSkin));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_MDL_BODY], szBody, charsmax(szBody));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_PRIMARY_WEAPON], xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_SECONDARY_WEAPON], xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_V_KNIFE], xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_P_KNIFE], xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_KNIFE_SOUNDS], xArray[CLASS_KNIFE_SOUNDS], charsmax(xArray[CLASS_KNIFE_SOUNDS]));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_FLAGS], szFlags, charsmax(szFlags));
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_TEAM], xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]));
	xArray[CLASS_FLAGS] = str_to_num(szFlags);
	xArray[CLASS_MODEL_BODY] = str_to_num(szBody);
	xArray[CLASS_MODEL_SKIN] = str_to_num(szSkin);
	
	new szFile[64];
	formatex(szFile, charsmax(szFile), "models/player/%s/%s.mdl", xArray[CLASS_MODEL], xArray[CLASS_MODEL]);
	PRECACHE_PLAYER_MODEL(szFile);
	formatex(szFile, charsmax(szFile), "models/player/%s/%sT.mdl", xArray[CLASS_MODEL], xArray[CLASS_MODEL])
	if(file_exists(szFile)) PRECACHE_PLAYER_MODEL(szFile);
	
	if(!bDefaultVKnife)
	{
		PRECACHE_WEAPON_VIEW_MODEL(xArray[CLASS_V_KNIFE_MDL]);
	}
	
	if(!bDefaultPKnife)
	{
		PRECACHE_WEAPON_PLAYER_MODEL(xArray[CLASS_P_KNIFE_MDL]);
	}
	
	if(xArray[CLASS_KNIFE_SOUNDS][0] != 0)
	{
		for(new i; i < sizeof knife_sounds; i++)
		{
			formatex(szFile, charsmax(szFile), "%s%s", xArray[CLASS_KNIFE_SOUNDS], knife_sounds[i]);
			PRECACHE_SOUND(szFile);
		}
	}
	
	ArrayPushArray(g_classes_array, xArray);
	g_iClasses ++;
	return g_iClasses-1;
}

public _get_user_classid(plugin, argc)
{
	new id = get_param(1);
	
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	return g_iClass[id][fm_get_user_team(id)];
}

public _set_user_classid(plugin, argc)
{
	new classid = get_param(2), id = get_param(1);
	
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	if(!(0 <= (classid = get_param(2)) < g_iClasses))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id!");
		return 0;
	}
	
	if(jb_is_user_class_valid(id,classid) <= 0)
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id for player team (#%d)", id);
		return 0;
	}
	
	g_iClass[id][clamp(fm_get_user_team(id), 0, charsmax(g_iClass[]))] = classid;
	return 1;
}

public _get_classes_count(pl, arg)
{
	return g_iClasses;
}

// native jb_get_classdata(classid, &team=-1, &flags=-1, &primarys=-1, &secondarys=-1, 
// vknifemdl[]="", vKLen=0, pknifemdl="", pKLen=0, KSounds[]="", sKLen=0, model[]="", mlen=0, &modelbody=-1, &modelskin=-1)
public _get_classdata(plugin, argc)
{
	new classid;
	if(!(0 <= (classid = get_param(1)) < g_iClasses))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id!");
		return 0;
	}
	
	new xArray[CLASSES_DATA];
	new team = get_param_byref(2), flags = get_param_byref(3), primarys = get_param_byref(4), secondarys = get_param_byref(5),
		modelbody = get_param_byref(14), modelskin = get_param_byref(15);
	ArrayGetArray(g_classes_array, classid, xArray);
	if(team != -1)
	{
		new i = sizeof SZTEAMS;
		while ( --i >= 0 ) if(equali(SZTEAMS[i], xArray[CLASS_TEAM], strlen(SZTEAMS[i]))) break;
		set_param_byref(2, i);
	}
	
	if(flags != -1)
	{
		set_param_byref(3, xArray[CLASS_FLAGS]);
	}
	
	new sOutput[MAX_WEAPONS][24];
	if(primarys != -1)
	{
		str_explode(xArray[CLASS_PRIMWEAPONS], ',', sOutput, MAX_WEAPONS, charsmax(sOutput[]));
		
		new iWpns;
		for(new i, j; i < MAX_WEAPONS; i++) if((j=get_weaponid(sOutput[i])) > 0) iWpns |= (1<<j);
		set_param_byref(4, iWpns);
	}
	
	if(secondarys != -1)
	{
		str_explode(xArray[CLASS_SECWEAPONS], ',', sOutput, MAX_WEAPONS, charsmax(sOutput[]));
		
		new iWpns;
		for(new i, j; i < MAX_WEAPONS; i++) if((j=get_weaponid(sOutput[i])) > 0) iWpns |= (1<<j);
		set_param_byref(5, iWpns);
	}
	
	new iLen;
	if((iLen=get_param(7)) > 0)
	{
		set_string(6, xArray[CLASS_V_KNIFE_MDL], iLen);
	}
	if((iLen=get_param(9)) > 0)
	{
		set_string(8, xArray[CLASS_P_KNIFE_MDL], iLen);
	}
	if((iLen=get_param(11)) > 0)
	{
		set_string(10, xArray[CLASS_KNIFE_SOUNDS], iLen);
	}
	if((iLen=get_param(13)) > 0)
	{
		set_string(12, xArray[CLASS_MODEL], iLen);
	}
	if(modelbody != -1)
	{
		set_param_byref(14, xArray[CLASS_MODEL_BODY]);
	}
	if(modelskin != -1)
	{
		set_param_byref(15, xArray[CLASS_MODEL_SKIN]);
	}
	
	return 1;
}

public _get_classname(plugin, argc)
{
	if(argc != 3)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | Arguments(%d/3) doesn't match!", plugin, argc) 
		return -1;
	}
	
	new classid;
	if(!(0 <= (classid = get_param(1)) < g_iClasses))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id!");
		return 0;
	}
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, classid, xArray);
	set_string(2, xArray[CLASS_NAME], get_param(3));
	return 1;
}

public _set_class_newname(plugin, argc)
{
	new classid;
	if(!(0 <= (classid = get_param(1)) < g_iClasses))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id!");
		return 0;
	}
	
	new new_name[32];
	get_string(2, new_name, charsmax(new_name));
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, classid, xArray);
	copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), new_name);
	ArraySetArray(g_classes_array, classid, xArray);
	return 1;
}

public _set_user_class_model(plugin, argc)
{
	new id = get_param(1);
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	jb_set_user_class_model(id);
	return 1;
}

jb_set_user_class_model(index)
{
	new iTeam = fm_get_user_team(index);

	if( !(TEAM_PRISONERS <= iTeam <= TEAM_GUARDS) ) return;

	new classid = g_iClass[index][iTeam];
	
	if( jb_is_user_class_valid(index, classid) > 0 )
	{	
		new xArray[CLASSES_DATA], sCurrentmodel[32];
		ArrayGetArray(g_classes_array, classid, xArray);
		get_user_info(index, "model", sCurrentmodel, charsmax(sCurrentmodel));
		
		if(!equal(sCurrentmodel, xArray[CLASS_MODEL]) || pev(index, pev_body) != xArray[CLASS_MODEL_BODY] || pev(index, pev_skin) != xArray[CLASS_MODEL_SKIN])
		{
			if(!equali(xArray[CLASS_MODEL], "NONE"))
			{
				cs_set_player_model(index, xArray[CLASS_MODEL]);
				set_pev(index, pev_body, xArray[CLASS_MODEL_BODY]);
				set_pev(index, pev_skin, xArray[CLASS_MODEL_SKIN]);
				return;
			}
			
			switch( iTeam )
			{
				case TEAM_GUARDS: cs_set_player_model(index, gclasses_defmodels[random(sizeof gclasses_defmodels)]);
				case TEAM_PRISONERS: cs_set_player_model(index, pclasses_defmodels[random(sizeof pclasses_defmodels)]);
			}
		}
	}
}

public _is_user_class_valid(plugin, argc)
{
	new id = get_param(1);
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	
	return jb_is_user_class_valid(id, get_param(2));
}

jb_is_user_class_valid(id, classid)
{
	if( (0 <= classid < g_iClasses))
	{
		new iTeam = fm_get_user_team(id);
		if( !(TEAM_PRISONERS <= iTeam <= TEAM_GUARDS) ) return -1;

		new xArray[CLASSES_DATA];
		ArrayGetArray(g_classes_array, classid, xArray);
		if(equali(SZTEAMS[TEAM_ANY], xArray[CLASS_TEAM], strlen(SZTEAMS[TEAM_ANY]))) return 1;
		return equali(SZTEAMS[iTeam], xArray[CLASS_TEAM], strlen(SZTEAMS[iTeam])) ? 1:0;
	}
	
	return -1;
}

// native jb_ini_get_keyvalue(const category[], const key[], value[], len)
public jb_get_keyvalue(plugin, cid)
{
	if(cid != 4) return 0;
	
	static cata[48], szKey[48], szValue[140], iLen, iRet;
	get_string(1, cata, charsmax(cata));
	get_string(2, szKey, charsmax(szKey));
	get_string(3, szValue, (iLen = get_param(4)));
	iRet = get_file_keyvalue(jailbreak_ini_file, cata, szKey, szValue, iLen);
	set_string(3, szValue, iLen);

	return iRet;
}

// native jb_logmessage(const action[]="", taker, upon=0)
public _logmessage_action(plugin, cid)
{
	static szAction[MAX_LOG_MESSAGE_LENGTH];
	get_string(1, szAction, charsmax(szAction));
	return logevent_message_action(szAction, get_param(2), get_param(3));
}

// native jb_logmessage(const message[], any:...)
public _logmessage(plugin, cid)
{
	if(cid < 1)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | function requires atleast 1 parameter", plugin, cid);
		return -1;
	}
	
	static szLogMessage[MAX_LOG_MESSAGE_LENGTH];
	get_string(1, szLogMessage, charsmax(szLogMessage));
	vdformat(szLogMessage, charsmax(szLogMessage), 1, 2);
	
	logevent_message(.szMessage=szLogMessage);
	return 1;
}

// native register_jailbreak_logmessages(const func[], const logmessage[]);
public register_logmessages(plugin, cid)
{
	if(cid != 2)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | Arguments: %d/2 doesn't equal the requested quantity!", plugin, cid);
		return -1;
	}
	
	new szString[32], xArray[LOGS_MESSAGES_DATA];
	xArray[LOGMESSAGE_FUNC_PLUGIN_ID] = plugin;
	get_string(1, szString, charsmax(szString));
	xArray[LOGMESSAGE_FUNC_ID] = get_func_id(szString, plugin);
	get_string(2, xArray[LOGMESSAGE_MESSAGE], charsmax(xArray[LOGMESSAGE_MESSAGE]));
	
	ArrayPushArray(g_array_logmessages, xArray);
	
	g_logmessages_hooks ++;
	return g_logmessages_hooks-1;
}

public task_radar_update(const taskid)
{
	static id; id = taskid - TASK_RADAR_SHOW_PLAYERS;

	if(!is_user_connected(id))
	{
		return;
	}

	static msgBombDrop = 0, msgHostagePos = 0, m_fakeHostageDie = 0;
	if(!msgBombDrop) msgBombDrop = get_user_msgid("BombDrop");
	if(!msgHostagePos) msgHostagePos = get_user_msgid("HostagePos");
	if(!m_fakeHostageDie) m_fakeHostageDie = get_user_msgid("HostageK"); 
	
	static index_pointer[MAX_PLAYERS+1] = {0, 0, ...}, players[32], pnum, iTemp, iOrigin[3], x, iHostageNum;

	switch( get_user_team(id) )
	{
		case TEAM_GUARDS:
		{
			get_players(players, pnum, "ahe", "TERRORIST");

			if( pnum )
			{
				for(x = 0, iTemp = pnum; x < iTemp; x++)
				{
					if(!check_flag(g_user_playersOnRadar[id],players[x]))
					{
						players[x] = players[--pnum];
					}
				}

				if( !pnum ) return;

				for(x = 0, iHostageNum = -1; x < min(pnum, 4); x++)
				{
					index_pointer[ id ] = (++index_pointer[ id ] % pnum);
					get_user_origin(players[ index_pointer[ id ] ], iOrigin);
					iHostageNum = (++iHostageNum % 4) + 1;
					message_begin(MSG_ONE_UNRELIABLE, msgHostagePos, {0,0,0}, id);
					write_byte(players[ index_pointer[ id ] ]);
					write_byte(iHostageNum);	//The number of the hostage, 1-4
					write_coord(iOrigin[0]);	//X Coordinate
					write_coord(iOrigin[1]);	//Y Coordinate
					write_coord(iOrigin[2]);	//Z Coordinate
					message_end();

					message_begin(MSG_ONE_UNRELIABLE, m_fakeHostageDie, {0,0,0}, id);
					write_byte(iHostageNum);
					message_end();
				}
			}
		}
		case TEAM_PRISONERS:
		{
			get_players(players, pnum, "ahe", "CT");

			if( pnum )
			{
				for(x = 0, iTemp = pnum; x < iTemp; x++)
				{
					if(!check_flag(g_user_playersOnRadar[id],players[x]))
					{
						players[x] = players[--pnum];
					}
				}

				if( !pnum ) return;

				index_pointer[ id ] = (++index_pointer[ id ] % pnum);
				get_user_origin(players[ index_pointer[ id ] ], iOrigin);
				message_begin(MSG_ONE_UNRELIABLE, msgBombDrop, {0,0,0}, id);
				write_coord(iOrigin[0]);	//X Coordinate
				write_coord(iOrigin[1]);	//Y Coordinate
				write_coord(iOrigin[2]);	//Z Coordinate
				write_byte(0);
				message_end();
			}
		}
	}
}

// native jb_display_on_player_radar(const player, const bitsOthers);
public _display_on_player_radar(plugin, arg)
{
	new player = get_param(1),
	bitsOthers = get_param(2);
	if( bitsOthers != 0 )
	{
		remove_task(player + TASK_RADAR_SHOW_PLAYERS);
		g_user_playersOnRadar[player] = bitsOthers;
		set_task(0.5, "task_radar_update", TASK_RADAR_SHOW_PLAYERS + player, _, _, "b");
	}
	else if(task_exists(TASK_RADAR_SHOW_PLAYERS + player))
	{
		remove_task(player + TASK_RADAR_SHOW_PLAYERS);
		g_user_playersOnRadar[player] = 0;

		if(is_user_connected(player) && get_user_team(player) == TEAM_PRISONERS)
		{
			static msgBombPickup = 0;
			if(!msgBombPickup) msgBombPickup = get_user_msgid("BombPickup");
			message_begin(MSG_ONE_UNRELIABLE, msgBombPickup, {0,0,0}, player);
			message_end();
		}
	}
}

// native jb_whats_today();
public _whats_today()
{
	return g_iTODAY;
}

// native jb_get_weekdays_name(index, szDayname, iLength);
public _get_weekdays_name(plugin, cid)
{
	new iDay = get_param(1);
	
	if(0 <= iDay < sizeof sDays)
	{
		new sString[32];
		formatex(sString, charsmax(sString), "%L", LANG_SERVER, sDays[iDay]);
		set_string(2, sString, get_param(3));
		return 1;
	}
	
	return 0;
}

public native_jb_get_user_enemies(plugin, argc)
{
	new id = get_param(1);
	if(1 > id || id > g_iMaxplayers)
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) does not exist!", id);
		return -2;
	}
	
	return g_bUser_enemies_HasBoundVar[id] ? get_xvar_num(g_iUser_enemies[id]) : g_iUser_enemies[id];
}

public native_jb_get_user_allies(plugin, argc)
{
	new id = get_param(1);
	if(1 > id || id > g_iMaxplayers)
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) does not exist!", id);
		return -2;
	}
	
	return g_bUser_allies_HasBoundVar[id] ? get_xvar_num(g_iUser_allies[id]) : g_iUser_allies[id];
}

public native_jb_set_user_enemies(plugin, argc)
{
	new id = get_param(1);
	if(1 > id || id > g_iMaxplayers)
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) does not exist!", id);
		return 0;
	}
	
	new bits_players = get_param(2);
	
	// cannot be an aly with himself/herself can he/she?
	remove_flag(bits_players,id);
	
	g_iUser_enemies[id] = bits_players;
	g_bUser_enemies_HasBoundVar[id] = false;
	return 1;
}

public native_jb_bind_user_enemies_var(plugin, argc)
{
	new id = get_param(1);
	if(1 > id || id > g_iMaxplayers)
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) does not exist!", id);
		return 0;
	}

	new szVariable[32];
	get_string(2, szVariable, charsmax(szVariable));

	g_iUser_enemies[id] = get_xvar_id(szVariable);
	g_bUser_enemies_HasBoundVar[id] = true;
	return 1;
}

public native_jb_set_user_allies(plugin, argc)
{
	new id = get_param(1);
	if(1 > id || id > g_iMaxplayers)
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) does not exist!", id);
		return 0;
	}
	
	new bits_players = get_param(2);
	
	// cannot be an aly with himself/herself can he/she?
	remove_flag(bits_players,id);
	
	g_iUser_allies[id] = bits_players;
	g_bUser_allies_HasBoundVar[id] = false;
	return 1;
}

public native_jb_bind_user_allies_var(plugin, argc)
{
	new id = get_param(1);
	if(1 > id || id > g_iMaxplayers)
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) does not exist!", id);
		return 0;
	}

	new szVariable[32];
	get_string(2, szVariable, charsmax(szVariable));

	g_iUser_allies[id] = get_xvar_id(szVariable);
	g_bUser_allies_HasBoundVar[id] = true;
	return 1;
}

fw_logmessages(const szLogMessage[MAX_LOG_MESSAGE_LENGTH])
{
	new xArray[LOGS_MESSAGES_DATA], szValue[64], iLen = charsmax(szLogMessage), i, n;
	
	for(i = 0; i < g_logmessages_hooks; i++)
	{
		ArrayGetArray(g_array_logmessages, i, xArray);
		
		n = 0;
		while(contain(xArray[LOGMESSAGE_MESSAGE], "#%??") != -1)
		{
			if( (n >= iLen) ||
			    ((n=strfind(szLogMessage, "'", .pos = n)) == -1) ||
			    (strfind(szLogMessage, "'", .pos = n + 1) == -1) ) break;

			n += copyc(szValue, charsmax(szValue), szLogMessage[++n], '^'') + 2;
			
			replace(xArray[LOGMESSAGE_MESSAGE], charsmax(xArray[LOGMESSAGE_MESSAGE]), "#%??", szValue);
		}

		if(containi(szLogMessage, xArray[LOGMESSAGE_MESSAGE]) > -1)
		{
			if(callfunc_begin_i(xArray[LOGMESSAGE_FUNC_ID], xArray[LOGMESSAGE_FUNC_PLUGIN_ID]) == 1)
			{
				callfunc_push_str(szLogMessage, false);
				callfunc_end();
			}
		}
	}
}

get_file_keyvalue(const file[], const cata[], const key[], value[], len=0)
{
	static sFile[MAX_FILE_DIRECTORY_LEN], fp;
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, file);
	
	fp = fopen(sFile, "at+");
	
	if(!fp)
	{
		set_fail_state("Error opening the file!");
		return 0;
	}
	
	static sBuffer[256], szCata[64], szKey[64], key_found, cata_found, line, bool:keyvalue_update;
	key_found = INVALID_KEY;
	cata_found = INVALID_CATEGORY;
	line = INVALID_LINE;
	keyvalue_update = false;
	
	fseek(fp, 0, SEEK_SET);
	while(!feof(fp))
	{
		line ++;
		
		fgets(fp, sBuffer, charsmax(sBuffer));
		trim(sBuffer);
		
		if(!sBuffer[0] || strlen(sBuffer) <= 3 || sBuffer[0] == ';' || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			continue;
		
		if(sBuffer[0] == '[' && contain(sBuffer[1], "]") > -1)
		{
			if(cata_found != INVALID_CATEGORY)
			{
				break;
			}
			
			copyc(szCata, charsmax(szCata), sBuffer[1], ']');
			
			if(equali(szCata, cata))
			{
				cata_found = line;
			}
			
			continue;
		}
		
		if(cata_found != INVALID_CATEGORY && key_found == INVALID_KEY)
		{
			strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=');
			trim(szKey);
			trim(sBuffer);
			remove_quotes(szKey);
			remove_quotes(sBuffer);
			
			if(equali(szKey, key))
			{
				key_found = line;
				
				if(sBuffer[0] == EOS)
				{
					if(value[0] != EOS)
					{
						keyvalue_update = true;
						break;
					}

					fclose(fp);
					return FILE_KEYVALUE_EMPTY;
				}
				
				copy(value, len, sBuffer);

				fclose(fp);
				return FILE_KEYVALUE_BUFFERED;
			}
		}
	}
	
	if(cata_found == INVALID_CATEGORY)
	{
		formatex(szCata, charsmax(szCata), "^n[%s]^n", cata);
		fputs(fp, szCata);
		
		formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^" ^n", key, value)
		fputs(fp, sBuffer);
	}
	
	else if((cata_found != INVALID_CATEGORY && key_found == INVALID_KEY) || keyvalue_update == true)
	{
		static sFile2[128], fp2;
		formatex(sFile2, charsmax(sFile2), "%s/2_%s", CONFIGS_DIR, file);
		
		fp2 = fopen(sFile2, "at+");
		
		if(!fp2)
		{
			set_fail_state("Error opening the file!");
			return 0;
		}
		
		line = INVALID_LINE;
		fseek(fp, 0, SEEK_SET);
		while( !feof(fp) )
		{
			line ++;
			if(fgets(fp, sBuffer, charsmax(sBuffer)) == 0) continue;
			
			if(keyvalue_update == true)
			{
				if(key_found == line)
				{
					formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^" ^n", key, value)
				}
			}
			else if(cata_found == line)
			{
				formatex(szCata, charsmax(szCata), "[%s]^n", cata);
				fputs(fp2, szCata);
				formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^"^n", key, value)
			}
			
			fputs(fp2, sBuffer);
		}
		fclose(fp);
		fclose(fp2);
		
		delete_file(sFile);
		if(!rename_file(sFile2, sFile,1))
		{
			delete_file(sFile2);
			return FILE_ERROR;
		}

		return keyvalue_update ? FILE_KEYVALUE_UPDATED : FILE_KEYVALUE_CREATED;
	}

	fclose(fp);
	return FILE_CATEGORY_CREATED;
}

load_ini_days_shopitems(const file[])
{
	static sFile[128], fp;
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, file);
	
	if(!file_exists(sFile))
	{
		write_file(sFile, "; Edit / Configure each shop items for each day!^n");
		write_file(sFile, "; [ Shop item name ]");
		write_file(sFile, "; 	[ Day name ]");
		write_file(sFile, "; 	TEAM = GUARDS/PRISONERS/ANY");
		write_file(sFile, "; 	COST = Item new cost");
		write_file(sFile, "; 	ACCESS = Item new access abcdefg...etc");
		write_file(sFile, "; 	INFO = item new info^n");
		write_file(sFile, "; 	LIMIT = item new limit^n");
		write_file(sFile, "; 	LIMIT_ROUNDS = item rounds limit^n");
		write_file(sFile, "; 	LIMIT_PER_USER = 1 - limit per users 0 - limit for all^n");
		write_file(sFile, "; 	XVAR_TYPE.XVARIABLE_NAME = value^n");
		write_file(sFile, "; 	XVAR_TYPE could be INT, BITS, CHARS, FLOAT^n^n");
		return 0;
	}
	
	fp = fopen(sFile, "a+");
	
	if(!fp)
	{
		set_fail_state("Error opening the file!");
		return -1;
	}
	
	static sBuffer[256], szDayItemName[MAX_DAYITEM_NAME_LENGTH], szShopItemName[MAX_SHOPITEM_NAME_LENGTH],
	szKey[64], bool:ShopItem_found, iTeam, iCounter, xArray[DAY_SHOP_ITEMS], any:xArray2[XVAR_DATA], szType[16], iDots, iPos; 
	ShopItem_found = false;
	iCounter = 0;
	
	while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
	{
		trim(sBuffer);
		
		if(!sBuffer[0] || strlen(sBuffer) <= 3 || sBuffer[0] == ';' || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			continue;
		
		if(sBuffer[0] == '[' && contain(sBuffer[1], "]") > -1)
		{
			copyc(szShopItemName, charsmax(szShopItemName), sBuffer[1], ']');
			copyc(szDayItemName, charsmax(szDayItemName), sBuffer[1], ']');
			
			if(get_itemid_inarray_bystring(szShopItemName, g_shop_items_name, false) != -1)
			{
				copy(xArray[ITEM_SHOP_ITEM_NAME], charsmax(xArray[ITEM_SHOP_ITEM_NAME]), szShopItemName);
				ShopItem_found = true;
			}
			else if(get_itemid_inarray_bystring(szDayItemName, g_days_itemname, false) != -1)
			{
				if(ShopItem_found != false)
				{
					iCounter ++;
					copy(xArray[ITEM_DAY_NAME], charsmax(xArray[ITEM_DAY_NAME]), szDayItemName);
					xArray[ITEM_TEAM] = -1;
					xArray[ITEM_ACCESS] = -1;
					xArray[ITEM_SHOP_ITEM_INFO][0] = EOS;
					xArray[ITEM_NEWCOST][0] = EOS;
					xArray[ITEM_ARRAY_XVARS] = any:Invalid_Array;
					xArray[ITEM_SHOP_LIMITS][LIMIT_TIMES] = -1;
					xArray[ITEM_SHOP_LIMITS][LIMIT_ROUNDS] = -1;
					xArray[ITEM_SHOP_LIMITS][LIMIT_FOR_EVERYONE] = -1;
					ArrayPushArray(g_iDayShopItems, xArray);
				}
			}
			
			continue;
		}
		
		if(ShopItem_found != false && iCounter > 0)
		{
			strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=')
			trim(szKey);
			trim(sBuffer);
			remove_quotes(szKey);
			remove_quotes(sBuffer);
			
			if(equali(szKey, "TEAM"))
			{
				for(iTeam = TEAM_ANY; iTeam < sizeof SZTEAMS; iTeam++)
				{
					if(equali(SZTEAMS[iTeam], sBuffer, strlen(SZTEAMS[iTeam])))
					{
						break;
					}
				}
				
				xArray[ITEM_TEAM] = iTeam;
			}
			else if(equali(szKey, "ACCESS"))
			{
				xArray[ITEM_ACCESS] = isalpha(sBuffer[0]) ? read_flags(sBuffer) : str_to_num(sBuffer);
			}
			else if(equali(szKey, "INFO"))
			{
				copy(xArray[ITEM_SHOP_ITEM_INFO], charsmax(xArray[ITEM_SHOP_ITEM_INFO]), sBuffer);
			}
			else if(equali(szKey, "COST"))
			{
				copy(xArray[ITEM_NEWCOST], charsmax(xArray[ITEM_NEWCOST]), sBuffer);
			}
			else if(equali(szKey, "LIMIT"))
			{
				arrayset(xArray[ITEM_SHOP_LIMITS][LIMIT_USER], (xArray[ITEM_SHOP_LIMITS][LIMIT_TIMES] = str_to_num(sBuffer)), 33);
			}
			else if(equali(szKey, "LIMIT_ROUNDS"))
			{
				arrayset(xArray[ITEM_SHOP_LIMITS][LIMIT_ROUNDS_COUNTER], (xArray[ITEM_SHOP_LIMITS][LIMIT_ROUNDS] = str_to_num(sBuffer)), MAX_PLAYERS+1);
			}
			else if(equali(szKey, "LIMIT_PER_USER"))
			{
				xArray[ITEM_SHOP_LIMITS][LIMIT_FOR_EVERYONE] = !str_to_num(sBuffer) ? true:false;
			}
			else
			{
				iDots = iPos = 0;
				while( ((iPos=(contain(szKey[iPos], ".") + 1)) > 0) )
				{
					iDots++;
				}
				
				xArray2[XVAR_TYPE] = XVAR_TYPE_INTEGER;
				
				switch( iDots )
				{
					case 1:
					{
						strtok(szKey, szType, charsmax(szType), szKey, charsmax(szKey), '.');
						
						for(iPos = 0; iPos < sizeof szXVAR_TYPES; iPos++)
						{
							if(equali(szType, szXVAR_TYPES[iPos], strlen(szXVAR_TYPES[iPos])))
							{
								xArray2[XVAR_TYPE] = iPos;
								break;
							}
						}
					}
				}
				
				if(!xvar_exists(szKey))
				{
					continue;
				}
				
				xArray2[XVAR_ID] = get_xvar_id(szKey);
				
				switch( is_str_float(sBuffer) )
				{
					case true:
					{
						if(contain(sBuffer, ".") != -1)
						{
							xArray2[XVAR_VALUE] = floatstr(sBuffer);
						}
						else
						{
							xArray2[XVAR_VALUE] = str_to_num(sBuffer);
						}
					}
					case false:
					{
						switch ( isalpha(sBuffer[0]) )
						{
							case false:
							{
								switch(is_str_num(sBuffer))
								{
									case true: xArray2[XVAR_VALUE] = str_to_num(sBuffer);
									case false: xArray2[XVAR_VALUE] = sBuffer[0];
								}
							}
							default:
							{
								if(equali(sBuffer, "TRUE"))
								{
									xArray2[XVAR_VALUE] = true;
								}
								else if(equali(sBuffer, "FALSE"))
								{
									xArray2[XVAR_VALUE] = false;
								}
								else
								{
									xArray2[XVAR_VALUE] = sBuffer[0];
								}
							}
						}
					}
				}	
				
				if(xArray[ITEM_ARRAY_XVARS] == any:Invalid_Array)
				{
					xArray[ITEM_ARRAY_XVARS] = ArrayCreate(XVAR_DATA,1);
				}
				
				ArrayPushArray(xArray[ITEM_ARRAY_XVARS], xArray2);
			}
			
			ArraySetArray(g_iDayShopItems, max(iCounter - 1, 0), xArray);
		}
	}
	fclose(fp);
	return 1;
}

bool:is_str_float(const string[])
{
	new c, i, p;
	while(is_char(c = string[i++]))	
	{
		if(!isdigit(c))
		{
			if(c != '.' || p)
			{
				return false;
			}
			
			p = 1;
		}
	}
	return (i > 1);
}

logevent_message_action(const action[], taker, upon=0, any:...)
{
	if(g_iMaxplayers >= taker > 0)
	{
		enum (+=1)
		{
			TAKER = 0,
			VICTIM
		}
		
		static szName[2][32], sAuthid[2][32], sTeam[2][16], szAction[MAX_LOG_MESSAGE_LENGTH];
		get_user_name(taker, szName[TAKER], charsmax(szName[]));
		get_user_authid(taker, sAuthid[TAKER], charsmax(sAuthid[]));
		get_user_team(taker, sTeam[TAKER], charsmax(sTeam[]));
		
		vformat(szAction, charsmax(szAction), action, 4);
		
		if(g_iMaxplayers >= upon > 0)
		{
			get_user_name(upon, szName[VICTIM], charsmax(szName[]));
			get_user_authid(upon, sAuthid[VICTIM], charsmax(sAuthid[]));
			get_user_team(upon, sTeam[VICTIM], charsmax(sTeam[]));
			
			logevent_message(taker, "^"%s<%d><%s><%s>^" %s ^"%s<%d><%s><%s>^"", szName[TAKER], get_user_userid(taker),
			sAuthid[TAKER], sTeam[TAKER], szAction, szName[VICTIM], get_user_userid(upon), sAuthid[VICTIM], sTeam[VICTIM]);
			return 2;
		}
		
		logevent_message(taker, "^"%s<%d><%s><%s>^" %s", szName[TAKER], get_user_userid(taker), sAuthid[TAKER], sTeam[TAKER], szAction);
		return 1;
	}
	
	return 0;
}

/* print colorful chat :) */
cprint_chat(id, const team='n', const message[], any:...)
{
	static sBuffer[MAX_CHAT_MESSAGE_LENGTH+1];
	vformat(sBuffer, charsmax(sBuffer), message, 4);
	replace_all(sBuffer, charsmax(sBuffer), "!g", "^4");
	replace_all(sBuffer, charsmax(sBuffer), "!y", "^1");
	replace_all(sBuffer, charsmax(sBuffer), "!t", "^3");
	format(sBuffer, charsmax(sBuffer), "%s %s", TAG, sBuffer);
	
	// max is 192 chars...
	sBuffer[MAX_CHAT_MESSAGE_LENGTH] = 0;
	
	if(!id) // when id is 0 or negative, the team parameter has - effect.
	{
		static players[32], num, i; i = 0;
		
		switch( team ) 
		{
			case 'C', 'c': get_players(players, num, "che", "CT")
			case 'T', 't': get_players(players, num, "che", "TERRORIST")
			default: get_players(players, num, "ch");
		}
		
		while( i < num )
		{
			id = players[i++];
			
			message_begin(MSG_ONE, g_msgSayText, _, id);
			write_byte(id);
			write_string(sBuffer);
			message_end();
		}
	}
	else
	{
		if(is_user_connected(id)) // to a specified player...
		{
			message_begin(MSG_ONE, g_msgSayText, _, id);
			write_byte(id);
			write_string(sBuffer);
			message_end();
		}
	}
}

find_location_around_origin(Float:fOrigin[3], const Float:fMaxs[3], const Float:fMins[3], const Float:fDistance, const bool:bRandom=false, &Array:pArrayLocations = any:-1)
{
    fOrigin[2] += floatabs(fMins[2]);

    static iTr2, Float:fTestOrigin[3], Float:fStart[3], Float:fEnd[3], Float:fYShift, Float:fXShift, i, d, iSafe;

    static iOrder[][][3] =
    {
        { {  0,  0,  1 }, {  0,  0, -1 } }, // Inner line
        { {  1,  1,  1 }, {  1,  1, -1 } }, // 4 square lines SIDES
        { { -1, -1,  1 }, { -1, -1, -1 } },
        { { -1,  1,  1 }, { -1,  1, -1 } },
        { {  1, -1,  1 }, {  1, -1, -1 } },
        { {  1,  1,  1 }, { -1,  1,  1 } }, // 4 square lines TOP
        { {  1,  1,  1 }, {  1, -1,  1 } },
        { { -1, -1,  1 }, { -1,  1,  1 } },
        { { -1, -1,  1 }, {  1, -1,  1 } },
        { {  1,  1, -1 }, { -1,  1, -1 } }, // 4 square lines BOTTOM
        { {  1,  1, -1 }, {  1, -1, -1 } },
        { { -1, -1, -1 }, { -1,  1, -1 } },
        { { -1, -1, -1 }, {  1, -1, -1 } },
        { {  1,  1,  1 }, { -1,  1, -1 } }, // front cross
        { {  1,  1, -1 }, { -1,  1,  1 } },
        { {  1, -1,  1 }, { -1, -1, -1 } }, // back cross
        { {  1, -1, -1 }, { -1, -1,  1 } },
        { {  1,  1,  1 }, {  1, -1, -1 } }, // right cross
        { {  1,  1, -1 }, {  1, -1,  1 } },
        { { -1,  1,  1 }, { -1, -1, -1 } }, // left cross
        { { -1,  1, -1 }, { -1, -1,  1 } },
        { {  1,  1,  1 }, { -1, -1,  1 } }, // up cross
        { {  1, -1,  1 }, { -1,  1,  1 } },
        { {  1,  1, -1 }, { -1, -1, -1 } }, // down cross
        { {  1, -1, -1 }, { -1,  1, -1 } }
    };

    fXShift = (fMaxs[0] - fMins[0]) ;
    fYShift = (fMaxs[1] - fMins[1]) ;

    const sizeofOrder = sizeof iOrder;

    iTr2 = create_tr2();

    fTestOrigin[1] = fOrigin[1] + fDistance;
    fTestOrigin[2] = fOrigin[2];

    static Float:flFraction, Float:fAngle, Float:fvBegin[3], Array:pTempArray=Invalid_Array;

    if(bRandom || pArrayLocations != Array:-1)
    {
        pTempArray = ArrayCreate(3, 1);
    }

    while( floatabs(fTestOrigin[1] - fOrigin[1]) <= fDistance  )
    {
        fAngle = floatasin( (fTestOrigin[1] - fOrigin[1]) / fDistance, degrees );
        fvBegin[0] = floatcos(fAngle,degrees) * fDistance;
        fvBegin[1] = floatsin(fAngle,degrees) * fDistance;
        fTestOrigin[0] = fOrigin[0] + fvBegin[0];

        while( get_distance_f(fTestOrigin, fOrigin) <= fDistance )
        {
            for( i = iSafe = 0; i < sizeofOrder; i++ )
            {
                for( d = 0; d < 3; d++ )
                {
                    switch( iOrder[i][0][d] )
                    {
                        case -1: fStart[d] = fTestOrigin[d] + fMins[d];
                        case 0: fStart[d] = fTestOrigin[d];
                        case 1: fStart[d] = fTestOrigin[d] + fMaxs[d];
                    }

                    switch( iOrder[i][1][d] )
                    {
                        case -1: fEnd[d] = fTestOrigin[d] + fMins[d];
                        case 0: fEnd[d] = fTestOrigin[d];
                        case 1: fEnd[d] = fTestOrigin[d] + fMaxs[d];
                    }
                }

                // Traces...
                engfunc(EngFunc_TraceLine, fStart, fEnd, DONT_IGNORE_MONSTERS, -1, iTr2);
                get_tr2(iTr2, TR_flFraction, flFraction);
                if(flFraction == 1.0 && get_tr2(iTr2, TR_InOpen) && !get_tr2(iTr2, TR_StartSolid) && !get_tr2(iTr2, TR_AllSolid))
                {
                    iSafe++;
                    continue;
                }

                break;
            }

            if(iSafe >= sizeofOrder)
            {
                if(pTempArray == Invalid_Array)
                {
                    xs_vec_copy(fTestOrigin, fOrigin);
                    free_tr2(iTr2);
                    return 1;
                }

                ArrayPushArray(pTempArray, fTestOrigin);
            }

            fTestOrigin[0] -= fXShift;
        }

        fTestOrigin[1] -= fYShift;
    }

    if(pTempArray != Invalid_Array)
    {
        if((i=ArraySize(pTempArray)) && bRandom)
        {
            ArrayGetArray(pTempArray, random(i), fOrigin);
        }

        if(pArrayLocations == any:-1)
        {
            ArrayDestroy(pTempArray);
        }
        else
        {
            pArrayLocations = pTempArray;
        }

        pTempArray = Invalid_Array;
        free_tr2(iTr2);
        return i;
    }

    free_tr2(iTr2);
    return 0;
}
